{
  "openapi" : "3.1.0",
  "info" : {
    "contact" : {
      "email" : "support@example.com",
      "name" : "Trovio Pty Ltd.",
      "url" : "https://example.com"
    },
    "description" : "\n\nThis section documents the main APIs for interfacing with CorTenX.\nDepending on how your system is deployed, these APIs may or may not be publicly available, and you might need additional API keys or authorization tokens from an IDP.\n\nThe API documentation is divided into these sections:\n\n* Account: Wallet endpoints for retrieving an account's holdings, access controls, and transaction history.\n* Inventory: Issuer endpoints for retrieving inventory-related details.\n* Access: Issuer endpoints for retrieving access control related details.\n* System information: General endpoints for accessing the block storage, and system-wide status and definitions.\n* Transaction request: Endpoints that facilitate transaction requests using binary encoded, signed messages.\n* Unsigned transaction request: Endpoints that facilitate transaction requests using OIDC authorization tokens.\n* Wallet: Wallet-specific functions for signing pending transactions, transaction proofs, etc...\n\nThe JSON encoding of requests and responses use a text representation for some internal simple types.\nThis includes:\n* `AccountId` is represented as `0x` followed by the hexadecimal representation of the AccountId's bytes.\n* `ProductId`, `ProductItemId`, `EscrowId`, `BlockAndIndex`, and similar are represented as `x:y` where x is the `blockNumber` and y is the index within the block.\n* `TransactionId` is represented as `0x` followed by the hexadecimal representation of the `TransactionId` bytes\n* All other binary data uses standard base64 encoding.\n\nGeneral API Request Limits:\n* Max URI: 1024 bytes\n* Max Body: 262144 bytes (256 KiB)\n* Max Query String: 4096 bytes\n* Max Cookie size: 10240 bytes\n\nUpload URIs Limits:\n* Max Body: 10485760 bytes (10 MiB)\n\n        ",
    "title" : "Trovio CorTenX APIs",
    "version" : "11.13467.0"
  },
  "servers" : [ {
    "url" : "/",
    "description" : "This host"
  } ],
  "tags" : [ {
    "description" : "The Account API provides endpoints that return information in the scope of holdings of an account.\nInitially, a client will want to retrieve information about the access key used to authenticate to the \nsystem and retrieve the accessible account permissions. Balance endpoints are provided to retrieve\ncurrent balances and holdings. Historic endpoints provide transaction history queries.",
    "name" : "Account"
  }, {
    "description" : "The Inventory API is available for Issuers and provides endpoints to query current inventory of product.",
    "name" : "Product inventory"
  }, {
    "description" : "The Access API is available for Issuers and provides endpoints to query account group and security group\ninformation.",
    "name" : "Access"
  }, {
    "description" : "The System Info API provides general status and information endpoints.",
    "name" : "System info"
  }, {
    "description" : "The Transaction Request API allows clients to queue transaction requests. The transaction request\ndata is binary-encoded using the Yabor encoding and signed using the client's access key. Invalid requests\nwill return an HTTP error code immediately. Valid requests that have incomplete signatures will be stored\nas a pending request and other signatories will be notified.",
    "name" : "Transaction request"
  }, {
    "description" : "The Unsigned Transaction Request API allows clients to queue transaction requests using JSON encoding and\nan Authorization Token from a registered OIDC provider. The transaction request is encoded and signed by\nthe service, after which it is processed in the same way as a signed transaction requests.",
    "name" : "Unsigned transaction request"
  }, {
    "description" : "The Wallet API provides various endpoints for other functions of the wallet host. This includes pending \ntransaction management and limited metadata access.",
    "name" : "Wallet functions"
  }, {
    "description" : "The Metadata API provides endpoints to define and manager issuer metadata. This includes \nprivate(limited access) and public metadata values of different types.",
    "name" : "Metadata"
  } ],
  "paths" : {
    "/api/auth/tx/account" : {
      "post" : {
        "description" : "Creates a new account with full access to the requested account.",
        "operationId" : "createAccountAndWait",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateAccountRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CreateAccountResponse"
                }
              }
            },
            "description" : "Account(s) were created and details returned."
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          },
          "504" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The transaction request was submitted but no response was received."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Creates a new account with full access to the requested account.",
        "tags" : [ "Unsigned transaction request" ]
      }
    },
    "/api/auth/tx/async" : {
      "post" : {
        "description" : "Sign and submit transaction request.\n Encodes and signs the request data and submits the request.\n The token provided in the `Authorization` header is verified and the user id is mapped to a generated key\n in the secure key storage.\n\n #### Errors specific to the endpoint\n | Error | Cause |\n |:----|:----|\n | [UserNotFound] | The user identified by the authorization token was not found. |\n | [TooManyRequests] | Too many concurrent requests. Back off and try again later |\n | [AccessKeyIdIncorrectForSignatureRequest] | The provided access key id does not match the authenticated user's account id |\n | [InternalError] | An internal error occurred during execution |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed)|\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type |\n | [IncorrectSignatureType] | The signature type is not supported for the key type |\n | [IncorrectTransactionId] | The transaction id in the request does not match the hash of the encoded transaction data |",
        "operationId" : "signAndSubmitTransaction",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "examples" : {
                "AdjustHoldingRequest" : {
                  "description" : "AdjustHoldingRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "AdjustHoldingRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "holdingIds" : [ "41756:0" ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "AssignHoldingRequest" : {
                  "description" : "AssignHoldingRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "AssignHoldingRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "holdingIds" : [ "41756:0" ],
                      "productItems" : [ "41755:0" ],
                      "inflationMode" : "Inflate",
                      "deflationMode" : "Deflate"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "BakeHoldingRequest" : {
                  "description" : "BakeHoldingRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "BakeHoldingRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "nonce" : 1701978529748,
                      "from" : {
                        "type" : "HoldingAmount",
                        "inputList" : [ "41768:0" ],
                        "amount" : "20"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CancelEscrowRequest" : {
                  "description" : "CancelEscrowRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CancelEscrowRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "controllerAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "erIsController" : true,
                      "escrowId" : "41767:0"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CancelPendingTransactionRequest" : {
                  "description" : "CancelPendingTransactionRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CancelPendingTransactionRequest",
                      "txId" : "0x35c75d88db98186e28af63863acf1a6e5e230a1fbcbda160f19dde188361a873",
                      "byAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "nonce" : 1701984875811
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateAccessKeysRequest" : {
                  "description" : "CreateAccessKeysRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateAccessKeysRequest",
                      "owner" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantId" : "1",
                      "subClaims" : [ "Test0", "Test1", "Test2", "Test3", "Test4", "Test5" ],
                      "attributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateEscrowRequest" : {
                  "description" : "CreateEscrowRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateEscrowRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "controllerAccountId" : "0x028b8c230af8950ea1c1ab2ff66e0461",
                      "attributes" : {
                        "comment" : "some comment",
                        "limit_price" : "50.99"
                      },
                      "from" : {
                        "type" : "ProductAmount",
                        "productId" : "41542:0",
                        "amount" : "20"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateIdentityProviderRequest" : {
                  "description" : "CreateIdentityProviderRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateIdentityProviderRequest",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantId" : "3",
                      "issuerUri" : "http://cognito-idp-eu-central-1/dev/trovio",
                      "displayName" : "Trovio Cognito CorTenX Client",
                      "clientId" : "1111-22222-3333-44444",
                      "applicationId" : "abcd-1111-2222-3333-4444",
                      "responseType" : "code",
                      "scopes" : [ "openid", "offline_access" ],
                      "enabled" : true,
                      "nonce" : 1701978529748,
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "identityProviderAttributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateIdentityTenantRequest" : {
                  "description" : "CreateIdentityTenantRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateIdentityTenantRequest",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantDisplayName" : "Trovio Cognito User Pool",
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "tenantAttributes" : {
                        "comment" : "some comment"
                      },
                      "nonce" : 1701978529748
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateProductItemRequest" : {
                  "description" : "CreateProductItemRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productId" : "41542:0",
                      "isUnassigned" : false,
                      "canInflate" : false,
                      "initialAmount" : "55",
                      "canFractionalize" : true,
                      "unitAmount" : "1",
                      "attributes" : {
                        "serial_number" : "1234567890"
                      },
                      "toAccountId" : "0x65d8a412a35e39c36ee5ab5b9e722804"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateProductRequest" : {
                  "description" : "CreateProductRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateProductRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "code" : "gold",
                      "name" : "gold",
                      "minDecimalPos" : 0,
                      "maxDecimalPos" : "0",
                      "canInflate" : true,
                      "canFractionalize" : true,
                      "canSpendUnassigned" : false,
                      "assignIfAvailable" : false,
                      "assignAfterSeconds" : 0,
                      "underlying" : [ ],
                      "itemAttributes" : [ {
                        "tag" : "serial_number",
                        "required" : true,
                        "validationRules" : [ ]
                      } ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "DefineAttributeRequest" : {
                  "description" : "DefineAttributeRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "DefineAttributeRequest",
                      "definition" : {
                        "createdBy" : "0x9a15455d013392c8b7f18d468eaf45ec",
                        "tag" : 199,
                        "name" : "timestamp",
                        "valueType" : "TIMESTAMP",
                        "validationRules" : [ ]
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "DeflateProductItemRequest" : {
                  "description" : "DeflateProductItemRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "DeflateProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "from" : {
                        "type" : "HoldingAmount",
                        "inputList" : [ "41756:0" ]
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "DeleteIdentityProviderRequest" : {
                  "description" : "DeleteIdentityProviderRequest",
                  "value" : "\n{\n   \"transactionId\": \"0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36\",\n   \"request\": \n{\n   \"type\":\"DeleteIdentityProviderRequest\",\n   \"account\":\"0x9a15455d013392c8b7f18d468eaf45ec\",\n   \"version\":1,\n   \"id\": 12,\n   \"attributes\":{\n      \"comment\":\"some comment\"\n   },\n}\n,\n   \"accessKeyId\":\"0x9a15455d013392c8b7f18d468eaf45ec\",\n   \"signatures\": [\n    {\n      \"accessKeyId\": \"0x65d8a412a35e39c36ee5ab5b9e722804\",\n      \"keyType\": \"EC_P_521\",\n      \"publicKeyData\": \"MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=\",\n      \"signatureData\": \"MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU\",\n      \"signatureType\": \"ES521\"\n    }\n  ]\n}\n"
                },
                "DeleteIdentityTenantRequest" : {
                  "description" : "DeleteIdentityTenantRequest",
                  "value" : "\n{\n   \"transactionId\": \"0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36\",\n   \"request\": \n{\n   \"type\":\"DeleteIdentityTenantRequest\",\n   \"account\":\"0x9a15455d013392c8b7f18d468eaf45ec\",\n   \"id\":\"23\",\n   \"attributes\":{\n      \"comment\":\"some comment\"\n   },\n}\n,\n   \"accessKeyId\":\"0x9a15455d013392c8b7f18d468eaf45ec\",\n   \"signatures\": [\n    {\n      \"accessKeyId\": \"0x65d8a412a35e39c36ee5ab5b9e722804\",\n      \"keyType\": \"EC_P_521\",\n      \"publicKeyData\": \"MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=\",\n      \"signatureData\": \"MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU\",\n      \"signatureType\": \"ES521\"\n    }\n  ]\n}\n"
                },
                "DeleteProductItemRequest" : {
                  "description" : "DeleteProductItemRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "DeleteProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productItemId" : "41755:0"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "DeleteProductRequest" : {
                  "description" : "DeleteProductRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "DeleteProductRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productId" : "41542:0"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "InflateProductItemRequest" : {
                  "description" : "InflateProductItemRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "InflateProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productItemId" : "41755:0",
                      "amount" : "20",
                      "toAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "SetAttributeRequest" : {
                  "description" : "SetAttributeRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "SetAttributeRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "entity" : {
                        "type" : "Product",
                        "id" : "41542:0",
                        "version" : "41542:0"
                      },
                      "setAttributes" : {
                        "comment" : "Lorem ipsum",
                        "project_id" : "1234"
                      },
                      "removeAttributes" : [ ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "TransferRequest" : {
                  "description" : "TransferRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "TransferRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "nonce" : 1701977224470,
                      "attributes" : {
                        "comment" : "Some comment"
                      },
                      "outputList" : [ {
                        "from" : {
                          "type" : "ProductAmount",
                          "productId" : "41542:0",
                          "amount" : "10"
                        },
                        "toAccountId" : "0x65d8a412a35e39c36ee5ab5b9e722804"
                      } ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "UpdateAccountAccessRequest" : {
                  "description" : "UpdateAccountAccessRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "UpdateAccountAccessRequest",
                      "forAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "updates" : [ {
                        "accessKeyId" : "0x028b8c230af8950ea1c1ab2ff66e0461",
                        "type" : "PRIMARY"
                      } ],
                      "nonce" : 233
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "UpdateIdentityProviderRequest" : {
                  "description" : "UpdateIdentityProviderRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "UpdateIdentityProviderRequest",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "version" : 1,
                      "id" : 12,
                      "tenantId" : "5",
                      "issuerUri" : "http://cognito-idp-eu-central-1/dev/trovio",
                      "displayName" : "Trovio Cognito CorTenX Client",
                      "clientId" : "1111-22222-3333-44444",
                      "applicationId" : "abcd-1111-2222-3333-4444",
                      "responseType" : "code",
                      "scopes" : [ "openid", "offline_access" ],
                      "enabled" : true,
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "identityProviderAttributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "UpdateIdentityTenantRequest" : {
                  "description" : "UpdateIdentityTenantRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "UpdateIdentityTenantRequest",
                      "version" : "1",
                      "id" : "3",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantDisplayName" : "Trovio Cognito User Pool",
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "tenantAttributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                }
              },
              "schema" : {
                "$ref" : "#/components/schemas/SignAndSubmitTransactionRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PendingTransactionData"
                }
              }
            },
            "description" : "The transaction request requires more approval signatures and has been stored as a 'pending transaction' and possible approvers have been notified."
          },
          "202" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SignAndSubmitTransactionResponse"
                }
              }
            },
            "description" : "The transaction request was valid and has been queued for processing."
          },
          "208" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MintTransactionResponse"
                }
              }
            },
            "description" : "The transaction request was already processed. The result returned is the result of the previous processing."
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Sign and submit transaction request.",
        "tags" : [ "Unsigned transaction request" ]
      }
    },
    "/api/auth/tx/request" : {
      "post" : {
        "description" : "Sign and submit transaction request (synchronous).\n Encodes and signs the request data and submits the request.\n The token provided in the `Authorization` header is verified and the user id is mapped to a generated key\n in the secure key storage.\n NOTE: This endpoint returns the response after the transaction request has been processed, which requires the\n service to wait for the response. Use this endpoint only for development and testing.\n\n #### Errors specific to the endpoint\n | Error | Cause |\n |:----|:----|\n | [UserNotFound] | The user identified by the authorization token was not found. |\n | [TooManyRequests] | Too many concurrent requests. Back off and try again later |\n | [AccessKeyIdIncorrectForSignatureRequest] | The provided access key id does not match the authenticated user's account id |\n | [InternalError] | An internal error occurred during execution |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed)|\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type |\n | [IncorrectSignatureType] | The signature type is not supported for the key type |\n | [IncorrectTransactionId] | The transaction id in the request does not match the hash of the encoded transaction data |",
        "operationId" : "signAndSubmitTransactionAndWait",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "examples" : {
                "AdjustHoldingRequest" : {
                  "description" : "AdjustHoldingRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "AdjustHoldingRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "holdingIds" : [ "41756:0" ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "AssignHoldingRequest" : {
                  "description" : "AssignHoldingRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "AssignHoldingRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "holdingIds" : [ "41756:0" ],
                      "productItems" : [ "41755:0" ],
                      "inflationMode" : "Inflate",
                      "deflationMode" : "Deflate"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "BakeHoldingRequest" : {
                  "description" : "BakeHoldingRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "BakeHoldingRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "nonce" : 1701978529748,
                      "from" : {
                        "type" : "HoldingAmount",
                        "inputList" : [ "41768:0" ],
                        "amount" : "20"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CancelEscrowRequest" : {
                  "description" : "CancelEscrowRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CancelEscrowRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "controllerAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "erIsController" : true,
                      "escrowId" : "41767:0"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CancelPendingTransactionRequest" : {
                  "description" : "CancelPendingTransactionRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CancelPendingTransactionRequest",
                      "txId" : "0x35c75d88db98186e28af63863acf1a6e5e230a1fbcbda160f19dde188361a873",
                      "byAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "nonce" : 1701984875811
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateAccessKeysRequest" : {
                  "description" : "CreateAccessKeysRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateAccessKeysRequest",
                      "owner" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantId" : "1",
                      "subClaims" : [ "Test0", "Test1", "Test2", "Test3", "Test4", "Test5" ],
                      "attributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateEscrowRequest" : {
                  "description" : "CreateEscrowRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateEscrowRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "controllerAccountId" : "0x028b8c230af8950ea1c1ab2ff66e0461",
                      "attributes" : {
                        "comment" : "some comment",
                        "limit_price" : "50.99"
                      },
                      "from" : {
                        "type" : "ProductAmount",
                        "productId" : "41542:0",
                        "amount" : "20"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateIdentityProviderRequest" : {
                  "description" : "CreateIdentityProviderRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateIdentityProviderRequest",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantId" : "3",
                      "issuerUri" : "http://cognito-idp-eu-central-1/dev/trovio",
                      "displayName" : "Trovio Cognito CorTenX Client",
                      "clientId" : "1111-22222-3333-44444",
                      "applicationId" : "abcd-1111-2222-3333-4444",
                      "responseType" : "code",
                      "scopes" : [ "openid", "offline_access" ],
                      "enabled" : true,
                      "nonce" : 1701978529748,
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "identityProviderAttributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateIdentityTenantRequest" : {
                  "description" : "CreateIdentityTenantRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateIdentityTenantRequest",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantDisplayName" : "Trovio Cognito User Pool",
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "tenantAttributes" : {
                        "comment" : "some comment"
                      },
                      "nonce" : 1701978529748
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateProductItemRequest" : {
                  "description" : "CreateProductItemRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productId" : "41542:0",
                      "isUnassigned" : false,
                      "canInflate" : false,
                      "initialAmount" : "55",
                      "canFractionalize" : true,
                      "unitAmount" : "1",
                      "attributes" : {
                        "serial_number" : "1234567890"
                      },
                      "toAccountId" : "0x65d8a412a35e39c36ee5ab5b9e722804"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "CreateProductRequest" : {
                  "description" : "CreateProductRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "CreateProductRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "code" : "gold",
                      "name" : "gold",
                      "minDecimalPos" : 0,
                      "maxDecimalPos" : "0",
                      "canInflate" : true,
                      "canFractionalize" : true,
                      "canSpendUnassigned" : false,
                      "assignIfAvailable" : false,
                      "assignAfterSeconds" : 0,
                      "underlying" : [ ],
                      "itemAttributes" : [ {
                        "tag" : "serial_number",
                        "required" : true,
                        "validationRules" : [ ]
                      } ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "DefineAttributeRequest" : {
                  "description" : "DefineAttributeRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "DefineAttributeRequest",
                      "definition" : {
                        "createdBy" : "0x9a15455d013392c8b7f18d468eaf45ec",
                        "tag" : 199,
                        "name" : "timestamp",
                        "valueType" : "TIMESTAMP",
                        "validationRules" : [ ]
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "DeflateProductItemRequest" : {
                  "description" : "DeflateProductItemRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "DeflateProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "from" : {
                        "type" : "HoldingAmount",
                        "inputList" : [ "41756:0" ]
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "DeleteIdentityProviderRequest" : {
                  "description" : "DeleteIdentityProviderRequest",
                  "value" : "\n{\n   \"transactionId\": \"0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36\",\n   \"request\": \n{\n   \"type\":\"DeleteIdentityProviderRequest\",\n   \"account\":\"0x9a15455d013392c8b7f18d468eaf45ec\",\n   \"version\":1,\n   \"id\": 12,\n   \"attributes\":{\n      \"comment\":\"some comment\"\n   },\n}\n,\n   \"accessKeyId\":\"0x9a15455d013392c8b7f18d468eaf45ec\",\n   \"signatures\": [\n    {\n      \"accessKeyId\": \"0x65d8a412a35e39c36ee5ab5b9e722804\",\n      \"keyType\": \"EC_P_521\",\n      \"publicKeyData\": \"MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=\",\n      \"signatureData\": \"MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU\",\n      \"signatureType\": \"ES521\"\n    }\n  ]\n}\n"
                },
                "DeleteIdentityTenantRequest" : {
                  "description" : "DeleteIdentityTenantRequest",
                  "value" : "\n{\n   \"transactionId\": \"0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36\",\n   \"request\": \n{\n   \"type\":\"DeleteIdentityTenantRequest\",\n   \"account\":\"0x9a15455d013392c8b7f18d468eaf45ec\",\n   \"id\":\"23\",\n   \"attributes\":{\n      \"comment\":\"some comment\"\n   },\n}\n,\n   \"accessKeyId\":\"0x9a15455d013392c8b7f18d468eaf45ec\",\n   \"signatures\": [\n    {\n      \"accessKeyId\": \"0x65d8a412a35e39c36ee5ab5b9e722804\",\n      \"keyType\": \"EC_P_521\",\n      \"publicKeyData\": \"MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=\",\n      \"signatureData\": \"MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU\",\n      \"signatureType\": \"ES521\"\n    }\n  ]\n}\n"
                },
                "DeleteProductItemRequest" : {
                  "description" : "DeleteProductItemRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "DeleteProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productItemId" : "41755:0"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "DeleteProductRequest" : {
                  "description" : "DeleteProductRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "DeleteProductRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productId" : "41542:0"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "InflateProductItemRequest" : {
                  "description" : "InflateProductItemRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "InflateProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productItemId" : "41755:0",
                      "amount" : "20",
                      "toAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "SetAttributeRequest" : {
                  "description" : "SetAttributeRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "SetAttributeRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "entity" : {
                        "type" : "Product",
                        "id" : "41542:0",
                        "version" : "41542:0"
                      },
                      "setAttributes" : {
                        "comment" : "Lorem ipsum",
                        "project_id" : "1234"
                      },
                      "removeAttributes" : [ ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "TransferRequest" : {
                  "description" : "TransferRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "TransferRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "nonce" : 1701977224470,
                      "attributes" : {
                        "comment" : "Some comment"
                      },
                      "outputList" : [ {
                        "from" : {
                          "type" : "ProductAmount",
                          "productId" : "41542:0",
                          "amount" : "10"
                        },
                        "toAccountId" : "0x65d8a412a35e39c36ee5ab5b9e722804"
                      } ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "UpdateAccountAccessRequest" : {
                  "description" : "UpdateAccountAccessRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "UpdateAccountAccessRequest",
                      "forAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "updates" : [ {
                        "accessKeyId" : "0x028b8c230af8950ea1c1ab2ff66e0461",
                        "type" : "PRIMARY"
                      } ],
                      "nonce" : 233
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "UpdateIdentityProviderRequest" : {
                  "description" : "UpdateIdentityProviderRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "UpdateIdentityProviderRequest",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "version" : 1,
                      "id" : 12,
                      "tenantId" : "5",
                      "issuerUri" : "http://cognito-idp-eu-central-1/dev/trovio",
                      "displayName" : "Trovio Cognito CorTenX Client",
                      "clientId" : "1111-22222-3333-44444",
                      "applicationId" : "abcd-1111-2222-3333-4444",
                      "responseType" : "code",
                      "scopes" : [ "openid", "offline_access" ],
                      "enabled" : true,
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "identityProviderAttributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                },
                "UpdateIdentityTenantRequest" : {
                  "description" : "UpdateIdentityTenantRequest",
                  "value" : {
                    "transactionId" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36",
                    "request" : {
                      "type" : "UpdateIdentityTenantRequest",
                      "version" : "1",
                      "id" : "3",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantDisplayName" : "Trovio Cognito User Pool",
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "tenantAttributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                    "signatures" : [ {
                      "accessKeyId" : "0x65d8a412a35e39c36ee5ab5b9e722804",
                      "keyType" : "EC_P_521",
                      "publicKeyData" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4=",
                      "signatureData" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU",
                      "signatureType" : "ES521"
                    } ]
                  }
                }
              },
              "schema" : {
                "$ref" : "#/components/schemas/SignAndSubmitTransactionRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MintTransactionResponse"
                }
              }
            },
            "description" : "The transaction request was processed and the response is returned."
          },
          "201" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PendingTransactionData"
                }
              }
            },
            "description" : "The transaction request requires more approval signatures and has been stored as a 'pending transaction' and possible approvers have been notified."
          },
          "208" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MintTransactionResponse"
                }
              }
            },
            "description" : "The transaction request was already processed. The result returned is the result of the previous processing."
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          },
          "504" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The transaction request was submitted but no response was received."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Sign and submit transaction request (synchronous).",
        "tags" : [ "Unsigned transaction request" ]
      }
    },
    "/api/auth/tx/sign" : {
      "post" : {
        "description" : "Sign a transaction request.\n Encodes and signs the request data and returns the signed encoded version. The response can be used with the\n [CoreSignedTransactionApi.submitTransaction] endpoint, so the flow is the same for requests signed\n by the service and requests signed by the client.\n\n #### Errors specific to the endpoint\n | Error | Cause |\n |:----|:----|\n | [UserNotFound] | The user identified by the authorization token was not found. |\n | [TooManyRequests] | Too many concurrent requests. Back off and try again later |\n | [AccessKeyIdIncorrectForSignatureRequest] | The provided access key id does not match the authenticated user's account id |\n | [InternalError] | An internal error occurred during execution |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed)|\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type |\n | [IncorrectSignatureType] | The signature type is not supported for the key type |\n | [IncorrectTransactionId] | The transaction id in the request does not match the hash of the encoded transaction data |",
        "operationId" : "signTransactionRequest",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "examples" : {
                "AdjustHoldingRequest" : {
                  "description" : "AdjustHoldingRequest",
                  "value" : {
                    "request" : {
                      "type" : "AdjustHoldingRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "holdingIds" : [ "41756:0" ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "AssignHoldingRequest" : {
                  "description" : "AssignHoldingRequest",
                  "value" : {
                    "request" : {
                      "type" : "AssignHoldingRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "holdingIds" : [ "41756:0" ],
                      "productItems" : [ "41755:0" ],
                      "inflationMode" : "Inflate",
                      "deflationMode" : "Deflate"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "BakeHoldingRequest" : {
                  "description" : "BakeHoldingRequest",
                  "value" : {
                    "request" : {
                      "type" : "BakeHoldingRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "nonce" : 1701978529748,
                      "from" : {
                        "type" : "HoldingAmount",
                        "inputList" : [ "41768:0" ],
                        "amount" : "20"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "CancelEscrowRequest" : {
                  "description" : "CancelEscrowRequest",
                  "value" : {
                    "request" : {
                      "type" : "CancelEscrowRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "controllerAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "erIsController" : true,
                      "escrowId" : "41767:0"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "CancelPendingTransactionRequest" : {
                  "description" : "CancelPendingTransactionRequest",
                  "value" : {
                    "request" : {
                      "type" : "CancelPendingTransactionRequest",
                      "txId" : "0x35c75d88db98186e28af63863acf1a6e5e230a1fbcbda160f19dde188361a873",
                      "byAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "nonce" : 1701984875811
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "CreateAccessKeysRequest" : {
                  "description" : "CreateAccessKeysRequest",
                  "value" : {
                    "request" : {
                      "type" : "CreateAccessKeysRequest",
                      "owner" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantId" : "1",
                      "subClaims" : [ "Test0", "Test1", "Test2", "Test3", "Test4", "Test5" ],
                      "attributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "CreateEscrowRequest" : {
                  "description" : "CreateEscrowRequest",
                  "value" : {
                    "request" : {
                      "type" : "CreateEscrowRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "controllerAccountId" : "0x028b8c230af8950ea1c1ab2ff66e0461",
                      "attributes" : {
                        "comment" : "some comment",
                        "limit_price" : "50.99"
                      },
                      "from" : {
                        "type" : "ProductAmount",
                        "productId" : "41542:0",
                        "amount" : "20"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "CreateIdentityProviderRequest" : {
                  "description" : "CreateIdentityProviderRequest",
                  "value" : {
                    "request" : {
                      "type" : "CreateIdentityProviderRequest",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantId" : "3",
                      "issuerUri" : "http://cognito-idp-eu-central-1/dev/trovio",
                      "displayName" : "Trovio Cognito CorTenX Client",
                      "clientId" : "1111-22222-3333-44444",
                      "applicationId" : "abcd-1111-2222-3333-4444",
                      "responseType" : "code",
                      "scopes" : [ "openid", "offline_access" ],
                      "enabled" : true,
                      "nonce" : 1701978529748,
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "identityProviderAttributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "CreateIdentityTenantRequest" : {
                  "description" : "CreateIdentityTenantRequest",
                  "value" : {
                    "request" : {
                      "type" : "CreateIdentityTenantRequest",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantDisplayName" : "Trovio Cognito User Pool",
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "tenantAttributes" : {
                        "comment" : "some comment"
                      },
                      "nonce" : 1701978529748
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "CreateProductItemRequest" : {
                  "description" : "CreateProductItemRequest",
                  "value" : {
                    "request" : {
                      "type" : "CreateProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productId" : "41542:0",
                      "isUnassigned" : false,
                      "canInflate" : false,
                      "initialAmount" : "55",
                      "canFractionalize" : true,
                      "unitAmount" : "1",
                      "attributes" : {
                        "serial_number" : "1234567890"
                      },
                      "toAccountId" : "0x65d8a412a35e39c36ee5ab5b9e722804"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "CreateProductRequest" : {
                  "description" : "CreateProductRequest",
                  "value" : {
                    "request" : {
                      "type" : "CreateProductRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "code" : "gold",
                      "name" : "gold",
                      "minDecimalPos" : 0,
                      "maxDecimalPos" : "0",
                      "canInflate" : true,
                      "canFractionalize" : true,
                      "canSpendUnassigned" : false,
                      "assignIfAvailable" : false,
                      "assignAfterSeconds" : 0,
                      "underlying" : [ ],
                      "itemAttributes" : [ {
                        "tag" : "serial_number",
                        "required" : true,
                        "validationRules" : [ ]
                      } ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "DefineAttributeRequest" : {
                  "description" : "DefineAttributeRequest",
                  "value" : {
                    "request" : {
                      "type" : "DefineAttributeRequest",
                      "definition" : {
                        "createdBy" : "0x9a15455d013392c8b7f18d468eaf45ec",
                        "tag" : 199,
                        "name" : "timestamp",
                        "valueType" : "TIMESTAMP",
                        "validationRules" : [ ]
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "DeflateProductItemRequest" : {
                  "description" : "DeflateProductItemRequest",
                  "value" : {
                    "request" : {
                      "type" : "DeflateProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "from" : {
                        "type" : "HoldingAmount",
                        "inputList" : [ "41756:0" ]
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "DeleteIdentityProviderRequest" : {
                  "description" : "DeleteIdentityProviderRequest",
                  "value" : "\n{\n   \"request\": \n{\n   \"type\":\"DeleteIdentityProviderRequest\",\n   \"account\":\"0x9a15455d013392c8b7f18d468eaf45ec\",\n   \"version\":1,\n   \"id\": 12,\n   \"attributes\":{\n      \"comment\":\"some comment\"\n   },\n}\n,\n   \"accessKeyId\":\"0x9a15455d013392c8b7f18d468eaf45ec\"\n}\n"
                },
                "DeleteIdentityTenantRequest" : {
                  "description" : "DeleteIdentityTenantRequest",
                  "value" : "\n{\n   \"request\": \n{\n   \"type\":\"DeleteIdentityTenantRequest\",\n   \"account\":\"0x9a15455d013392c8b7f18d468eaf45ec\",\n   \"id\":\"23\",\n   \"attributes\":{\n      \"comment\":\"some comment\"\n   },\n}\n,\n   \"accessKeyId\":\"0x9a15455d013392c8b7f18d468eaf45ec\"\n}\n"
                },
                "DeleteProductItemRequest" : {
                  "description" : "DeleteProductItemRequest",
                  "value" : {
                    "request" : {
                      "type" : "DeleteProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productItemId" : "41755:0"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "DeleteProductRequest" : {
                  "description" : "DeleteProductRequest",
                  "value" : {
                    "request" : {
                      "type" : "DeleteProductRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productId" : "41542:0"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "InflateProductItemRequest" : {
                  "description" : "InflateProductItemRequest",
                  "value" : {
                    "request" : {
                      "type" : "InflateProductItemRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "productItemId" : "41755:0",
                      "amount" : "20",
                      "toAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "SetAttributeRequest" : {
                  "description" : "SetAttributeRequest",
                  "value" : {
                    "request" : {
                      "type" : "SetAttributeRequest",
                      "issuerId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "entity" : {
                        "type" : "Product",
                        "id" : "41542:0",
                        "version" : "41542:0"
                      },
                      "setAttributes" : {
                        "comment" : "Lorem ipsum",
                        "project_id" : "1234"
                      },
                      "removeAttributes" : [ ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "TransferRequest" : {
                  "description" : "TransferRequest",
                  "value" : {
                    "request" : {
                      "type" : "TransferRequest",
                      "fromAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "nonce" : 1701977224470,
                      "attributes" : {
                        "comment" : "Some comment"
                      },
                      "outputList" : [ {
                        "from" : {
                          "type" : "ProductAmount",
                          "productId" : "41542:0",
                          "amount" : "10"
                        },
                        "toAccountId" : "0x65d8a412a35e39c36ee5ab5b9e722804"
                      } ]
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "UpdateAccountAccessRequest" : {
                  "description" : "UpdateAccountAccessRequest",
                  "value" : {
                    "request" : {
                      "type" : "UpdateAccountAccessRequest",
                      "forAccountId" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "updates" : [ {
                        "accessKeyId" : "0x028b8c230af8950ea1c1ab2ff66e0461",
                        "type" : "PRIMARY"
                      } ],
                      "nonce" : 233
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "UpdateIdentityProviderRequest" : {
                  "description" : "UpdateIdentityProviderRequest",
                  "value" : {
                    "request" : {
                      "type" : "UpdateIdentityProviderRequest",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "version" : 1,
                      "id" : 12,
                      "tenantId" : "5",
                      "issuerUri" : "http://cognito-idp-eu-central-1/dev/trovio",
                      "displayName" : "Trovio Cognito CorTenX Client",
                      "clientId" : "1111-22222-3333-44444",
                      "applicationId" : "abcd-1111-2222-3333-4444",
                      "responseType" : "code",
                      "scopes" : [ "openid", "offline_access" ],
                      "enabled" : true,
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "identityProviderAttributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                },
                "UpdateIdentityTenantRequest" : {
                  "description" : "UpdateIdentityTenantRequest",
                  "value" : {
                    "request" : {
                      "type" : "UpdateIdentityTenantRequest",
                      "version" : "1",
                      "id" : "3",
                      "account" : "0x9a15455d013392c8b7f18d468eaf45ec",
                      "tenantDisplayName" : "Trovio Cognito User Pool",
                      "attributes" : {
                        "comment" : "some comment"
                      },
                      "tenantAttributes" : {
                        "comment" : "some comment"
                      }
                    },
                    "accessKeyId" : "0x9a15455d013392c8b7f18d468eaf45ec"
                  }
                }
              },
              "schema" : {
                "$ref" : "#/components/schemas/SignTransactionRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SignTransactionResponse"
                }
              }
            },
            "description" : "Response contains the signed transaction request."
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Sign a transaction request.",
        "tags" : [ "Unsigned transaction request" ]
      }
    },
    "/api/auth/tx/user" : {
      "get" : {
        "description" : "Retrieve user account details.\n Retrieve details for the user authenticated by the authentication token. If the user does not have an access key\n yet, a new one is generated and the accessKeyId is returned in the response.",
        "operationId" : "getUserAccountData",
        "responses" : {
          "200" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IdentityUserData"
                }
              }
            },
            "description" : "The presented Authorization token was valid, and the associated user data is returned."
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Retrieve user account details.",
        "tags" : [ "Unsigned transaction request" ]
      }
    },
    "/api/config" : {
      "get" : {
        "description" : "Get system configuration.\n Returns details required for authentication and connection to the APIs.\n\n There is no authentication or endpoint permission required for this endpoint.",
        "operationId" : "getSystemConfiguration",
        "responses" : {
          "200" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreConfigData"
                }
              }
            },
            "description" : "Success"
          }
        },
        "security" : [ ],
        "summary" : "Get system configuration.",
        "tags" : [ "System info" ]
      }
    },
    "/api/issuer/metadata" : {
      "get" : {
        "description" : "Query metadata definitions.\n\n Returns metadata definitions that match the given criteria.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `QueryMetadataDefinitions`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerIds` | Assigned by an issuer permits queries of that issuer's definitions. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "queryMetadataDefinitions",
        "parameters" : [ {
          "description" : "Query metadata definitions belonging to the following issuers (AccountId)",
          "in" : "query",
          "name" : "issuerIds",
          "required" : true,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata with the following metadata tags",
          "in" : "query",
          "name" : "tags",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }, {
          "description" : "Metadata definition name criterion",
          "in" : "query",
          "name" : "name",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Query metadata of the follow reference type.",
          "in" : "query",
          "name" : "entityTypes",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "PRODUCT", "PRODUCT_ITEM", "BAKED_HOLDING", "TRANSACTION", "ATTRIBUTE_DEFINITION", "ACCOUNT", "ACCESS_KEY", "ACCOUNT_GROUP", "SECURITY_GROUP", "ATTRIBUTE_ENUM", "TRANSACTION_ID" ]
            }
          }
        }, {
          "description" : "Query metadata by value type",
          "in" : "query",
          "name" : "valueTypes",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "STRING", "DECIMAL", "INTEGER", "JSON", "FILE", "URI", "TIMESTAMP" ]
            }
          }
        }, {
          "description" : "Query only indexed or non indexed metadata definitions",
          "in" : "query",
          "name" : "indexed",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "in" : "query",
          "name" : "public",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Query only user(`isUser=true`) or issuer metadata(`isUser=false`) definitions",
          "in" : "query",
          "name" : "user",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Query only audited or not audited metadata definitions",
          "in" : "query",
          "name" : "audited",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Query metadata definitions with audited values",
          "in" : "query",
          "name" : "auditValues",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include metadata for referenced entities (issuerIds)",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseMetadataDefinitionData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Query metadata definitions.",
        "tags" : [ "Metadata" ]
      },
      "post" : {
        "description" : "Create metadata definitions.\n\n An issuer defines metadata that can be applied to different entity types.\n The request is atomic, if one of the operations fails none of the definitions are created.\n The request is idempotent, if definitions are recreated with the same parameters, the original result is returned.\n\n The batch size cannot exceed the configured maximum (default: 100).\n If the batch size exceeds the configured maximum a validation failure occurs and the entire request is failed.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `CreateMetadataDefinitions`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerId` | Assigned by an issuer permits metadata definitions to be created on the issuer's behalf. |\n\nThis endpoint also requires the Issuer Admin to have assigned `Issuer` permission for endpoint type `CreateMetadataDefinitions` to the issuer account(s) referenced by the request.",
        "operationId" : "createMetadataDefinitions",
        "parameters" : [ {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateMetadataDefinitionsRequest"
              }
            }
          },
          "description" : "The metadata definition batch create request",
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CreateMetadataDefinitionsResponse"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Create metadata definitions.",
        "tags" : [ "Metadata" ]
      },
      "put" : {
        "description" : "Update metadata definitions.\n\n The request is atomic, if one of the operations fails none of the definitions are updated.\n\n The batch size cannot exceed the configured maximum (default: 100).\n If the batch size exceeds the configured maximum a validation failure occurs and the entire request is failed.\n\n Some properties of metadata definitions can be updated by the issuer.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `UpdateMetadataDefinitions`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `updates[].metadataRef` | Assigned by each ref's issuer permits updates. |\n",
        "operationId" : "updateMetadataDefinitions",
        "parameters" : [ {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UpdateMetadataDefinitionsRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/UpdateMetadataDefinitionsResponse"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Update metadata definitions.",
        "tags" : [ "Metadata" ]
      }
    },
    "/api/issuer/metadata/audit" : {
      "get" : {
        "description" : "Query metadata definitions audit entries.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `QueryMetadataDefinitionsAudit`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerIds` | Assigned by an issuer permits queries of that issuer's definitions audit entries. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "queryMetadataDefinitionAudit",
        "parameters" : [ {
          "description" : "Issuer of entity on which the auditable action is performed by [originatorAccessKeyId]",
          "in" : "query",
          "name" : "issuerId",
          "required" : true,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata with the following metadata tags",
          "in" : "query",
          "name" : "tag",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }, {
          "description" : "Metadata definition name criterion",
          "in" : "query",
          "name" : "name",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Access key used by the originator of the auditable action",
          "in" : "query",
          "name" : "originatorAccessKeyId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "User account ID of the originator of the auditable action",
          "in" : "query",
          "name" : "originatorUserAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Interval in which the action was executed",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "$ref" : "#/components/schemas/RangeValueCriterionInstant"
          }
        }, {
          "description" : "Action to filter by",
          "in" : "query",
          "name" : "action",
          "required" : false,
          "schema" : {
            "type" : "string",
            "enum" : [ "CREATE", "UPDATE" ]
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `id`, the audit id\n * `tag`\n * `name`\n * `issuer`\n * `originatorAccessKeyId`\n * `originatorUserAccountId`\n * `timestamp`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseMetadataDefinitionAuditData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Query metadata definitions audit entries.",
        "tags" : [ "Metadata" ]
      }
    },
    "/api/issuer/metadata/file/{issuerId}/upload" : {
      "post" : {
        "description" : "Upload file.\n\n Upload a file to temporary storage, to later set a metadata value of type [MetadataValueType.FILE] referencing it.\n Any metadata value referencing this file, needs to belong to the same issuer as the file.\n\n Note: The file information returned is required when setting a metadata value of type [MetadataValueType.FILE]\n which will reference back to the file by using fields: [MetadataValueFileData.sizeBytes] & [MetadataValueFileData.sha256Hash]\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `UploadFile`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerId` | Assigned by an issuer permits uploads. |\n\nThis endpoint also requires the Issuer Admin to have assigned `Issuer` permission for endpoint type `UploadFile` to the issuer account(s) referenced by the request.",
        "operationId" : "uploadMetadataFile",
        "parameters" : [ {
          "description" : "the issuer for which this value is uploaded.",
          "in" : "path",
          "name" : "issuerId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "type" : "object",
                "properties" : {
                  "file" : {
                    "type" : "string",
                    "format" : "binary"
                  }
                },
                "required" : [ "file" ]
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MetadataValueFileData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Upload file.",
        "tags" : [ "Metadata" ]
      }
    },
    "/api/issuer/metadata/user/values" : {
      "get" : {
        "description" : "Query all user metadata.\n\n Query user metadata values across multiple users by multiple filters and include user information.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `QueryAllUserMetadata`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerIds` | Assigned by an issuer permits querying all users' metadata values |\n| `metadataRefs` | Assigned by an issuer permits querying all users' metadata values |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "queryAllUserMetadata",
        "parameters" : [ {
          "description" : "Query metadata belonging to these issuers (AccountId)",
          "in" : "query",
          "name" : "issuerIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Metadata definition references",
          "in" : "query",
          "name" : "metadataRefs",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of product references (BlockAndIndex)",
          "in" : "query",
          "name" : "products",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of product item references (BlockAndIndex)",
          "in" : "query",
          "name" : "productItems",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of baked holding references (BlockAndIndex)",
          "in" : "query",
          "name" : "holdings",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of mint transactions referenced by BlockAndIndex",
          "in" : "query",
          "name" : "transactions",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of transactions referenced by TransactionId",
          "in" : "query",
          "name" : "transactionsById",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of account groups (BlockAndIndex)",
          "in" : "query",
          "name" : "accountGroups",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of account groups (BlockAndIndex)",
          "in" : "query",
          "name" : "securityGroups",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of attribute definitions (attribute tags)",
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of accounts (AccountId)",
          "in" : "query",
          "name" : "accounts",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of access keys (AccountId)",
          "in" : "query",
          "name" : "accessKeys",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of enum values (attribute tag and enum ordinal)",
          "in" : "query",
          "name" : "enums",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata by any entity by using the format \"${[MetadataEntityRefType]}:${entity-id}\"",
          "in" : "query",
          "name" : "entityRefs",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Include metadata for referenced entities (issuerIds)",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseMetadataUserEntryData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Query all user metadata.",
        "tags" : [ "Metadata" ]
      }
    },
    "/api/issuer/metadata/user/{userId}/values" : {
      "get" : {
        "description" : "Query user metadata values.\n\n Query **user** metadata (`isUser=true`) values by multiple filters.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `QueryUserMetadata`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `userId` | Assigned by an account permits retrieval of that account's user values. |\n| `issuerIds` | Assigned by an issuer permits retrieval of all users' metadata values. |\n| `metadataRefs` | Assigned by an issuer permits retrieval of all users' metadata values. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "queryUserMetadata",
        "parameters" : [ {
          "in" : "path",
          "name" : "userId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Query metadata belonging to these issuers (AccountId)",
          "in" : "query",
          "name" : "issuerIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Metadata definition references",
          "in" : "query",
          "name" : "metadataRefs",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of product references (BlockAndIndex)",
          "in" : "query",
          "name" : "products",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of product item references (BlockAndIndex)",
          "in" : "query",
          "name" : "productItems",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of baked holding references (BlockAndIndex)",
          "in" : "query",
          "name" : "holdings",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of mint transactions referenced by BlockAndIndex",
          "in" : "query",
          "name" : "transactions",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of transactions referenced by TransactionId",
          "in" : "query",
          "name" : "transactionsById",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of account groups (BlockAndIndex)",
          "in" : "query",
          "name" : "accountGroups",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of account groups (BlockAndIndex)",
          "in" : "query",
          "name" : "securityGroups",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of attribute definitions (attribute tags)",
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of accounts (AccountId)",
          "in" : "query",
          "name" : "accounts",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of access keys (AccountId)",
          "in" : "query",
          "name" : "accessKeys",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of enum values (attribute tag and enum ordinal)",
          "in" : "query",
          "name" : "enums",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata by any entity by using the format \"${[MetadataEntityRefType]}:${entity-id}\"",
          "in" : "query",
          "name" : "entityRefs",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Include metadata for referenced entities (issuerIds)",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseMetadataEntryData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Query user metadata values.",
        "tags" : [ "Metadata" ]
      },
      "post" : {
        "description" : "Set user metadata values.\n\n Batch set metadata values for any existing **user** metadata definitions (`isUser==true`).\n New values will be created, existing ones will be updated.\n\n The batch size cannot exceed the configured maximum (default: 100).\n If the batch size exceeds the configured maximum a validation failure occurs and the entire request is failed.\n\n When setting metadata values of type [MetadataValueType.FILE], ensure that the referenced\n file is uploaded prior to this call, by using the upload file endpoint \"/metadata/file/{issuerId}/upload\".\n Set both the uploaded file id and content hash, in order to properly set metadata for a previously uploaded file.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `SetUserMetadata`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `userId` | Assigned by an account permits updates to that account's user values. |\n| `values[].metadataRef` | Assigned by an issuer permits updates to any user's values for the issuer's metadata definitions. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "setUserMetadata",
        "parameters" : [ {
          "description" : "user id setting the value. If metadata isUser is false, has to be the issuer, if is true, any user\n can set it for themselves.",
          "in" : "path",
          "name" : "userId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetMetadataRequest"
              }
            }
          },
          "description" : "List of metadata value entries to be set",
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SetMetadataResponse"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Set user metadata values.",
        "tags" : [ "Metadata" ]
      }
    },
    "/api/issuer/metadata/values" : {
      "get" : {
        "description" : "Query issuer metadata values.\n\n Query **issuer** metadata (`isUser=false`) values by multiple filters.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `QueryMetadata`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerIds` | Assigned by an issuer permits retrieval of that issuer's metadata values. |\n| `metadataRefs` | Assigned by an issuer permits retrieval of that issuer's metadata values. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "queryMetadata",
        "parameters" : [ {
          "description" : "Query metadata belonging to these issuers (AccountId)",
          "in" : "query",
          "name" : "issuerIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Metadata definition references",
          "in" : "query",
          "name" : "metadataRefs",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of product references (BlockAndIndex)",
          "in" : "query",
          "name" : "products",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of product item references (BlockAndIndex)",
          "in" : "query",
          "name" : "productItems",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of baked holding references (BlockAndIndex)",
          "in" : "query",
          "name" : "holdings",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of mint transactions referenced by BlockAndIndex",
          "in" : "query",
          "name" : "transactions",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of transactions referenced by TransactionId",
          "in" : "query",
          "name" : "transactionsById",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of account groups (BlockAndIndex)",
          "in" : "query",
          "name" : "accountGroups",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of account groups (BlockAndIndex)",
          "in" : "query",
          "name" : "securityGroups",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of attribute definitions (attribute tags)",
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of accounts (AccountId)",
          "in" : "query",
          "name" : "accounts",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of access keys (AccountId)",
          "in" : "query",
          "name" : "accessKeys",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of enum values (attribute tag and enum ordinal)",
          "in" : "query",
          "name" : "enums",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata by any entity by using the format \"${[MetadataEntityRefType]}:${entity-id}\"",
          "in" : "query",
          "name" : "entityRefs",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Include metadata for referenced entities (issuerIds)",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseMetadataEntryData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Query issuer metadata values.",
        "tags" : [ "Metadata" ]
      },
      "post" : {
        "description" : "Set issuer metadata values.\n\n Batch set issuer metadata values for existing **issuer** metadata definitions (`isUser==false`).\n New values will be created, existing ones will be updated.\n\n The batch size cannot exceed the configured maximum (default: 100).\n If the batch size exceeds the configured maximum a validation failure occurs and the entire request is failed.\n\n When setting metadata values of type [MetadataValueType.FILE], ensure that the referenced\n file is uploaded prior to this call, by using the upload file endpoint \"/metadata/file/{issuerId}/upload\".\n Set both the uploaded file id and content hash, in order to properly set metadata for a previously uploaded file.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `SetMetadata`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `values[].metadataRef` | Assigned by an issuer permits updates to the issuer's values. |\n",
        "operationId" : "setMetadata",
        "parameters" : [ {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetMetadataRequest"
              }
            }
          },
          "description" : "List of metadata value entries to be set",
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SetMetadataResponse"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Set issuer metadata values.",
        "tags" : [ "Metadata" ]
      }
    },
    "/api/issuer/metadata/values/audit" : {
      "get" : {
        "description" : "Query metadata values audit entries.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `QueryMetadataValuesAudit`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerIds` | Assigned by an issuer permits queries of that issuer's metadata values audit entries. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "queryMetadataValuesAudit",
        "parameters" : [ {
          "description" : "Issuer of entity on which the auditable action is performed by [originatorAccessKeyId]",
          "in" : "query",
          "name" : "issuerId",
          "required" : true,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata with the following metadata tags",
          "in" : "query",
          "name" : "tag",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }, {
          "description" : "Metadata definition name criterion",
          "in" : "query",
          "name" : "name",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Access key used by the originator of the auditable action",
          "in" : "query",
          "name" : "originatorAccessKeyId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "User account ID of the originator of the auditable action",
          "in" : "query",
          "name" : "originatorUserAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Interval in which the action was executed",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "$ref" : "#/components/schemas/RangeValueCriterionInstant"
          }
        }, {
          "description" : "Action to filter by",
          "in" : "query",
          "name" : "action",
          "required" : false,
          "schema" : {
            "type" : "string",
            "enum" : [ "CREATE", "UPDATE" ]
          }
        }, {
          "in" : "query",
          "name" : "userId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "in" : "query",
          "name" : "entityType",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "PRODUCT", "PRODUCT_ITEM", "BAKED_HOLDING", "TRANSACTION", "ATTRIBUTE_DEFINITION", "ACCOUNT", "ACCESS_KEY", "ACCOUNT_GROUP", "SECURITY_GROUP", "ATTRIBUTE_ENUM", "TRANSACTION_ID" ]
            }
          }
        }, {
          "description" : "Query metadata by any entity by using the format \"${[MetadataEntityRefType]}:${entity-id}\"",
          "in" : "query",
          "name" : "entityRef",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `id`, the audit id\n * `tag`\n * `name`\n * `issuer`\n * `originatorAccessKeyId`\n * `originatorUserAccountId`\n * `timestamp`\n * `isUser`\n * `userId`\n * `entityType`\n * `entityRef`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseMetadataValueAuditData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Query metadata values audit entries.",
        "tags" : [ "Metadata" ]
      }
    },
    "/api/issuer/{issuerId}/upload" : {
      "post" : {
        "description" : "Upload document attribute.\n\n Upload a file to be referenced in an attribute value of type `DOCUMENT`.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `UploadFile`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerId` | Assigned by an issuer account permits uploading documents. |\n\nThis endpoint also requires the Issuer Admin to have assigned `Issuer` permission for endpoint type `UploadFile` to the issuer account(s) referenced by the request.",
        "operationId" : "uploadAttributeDocument",
        "parameters" : [ {
          "in" : "path",
          "name" : "issuerId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "type" : "object",
                "properties" : {
                  "file" : {
                    "type" : "string",
                    "format" : "binary"
                  }
                },
                "required" : [ "file" ]
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DocumentData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Upload document attribute.",
        "tags" : [ "Metadata" ]
      }
    },
    "/api/pub/account-group/{accountGroupId}" : {
      "get" : {
        "description" : "Get Account Group details.\n The details include the Security Groups owned by the same issuer as the owner of the Account Group.\n To retrieve all Security Group assignments for an Account Group, use [listSecurityGroups] with the account group\n criterion.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetAccountGroup`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountGroupId` | Assigned by an account permits any account group owned by the account. |\n",
        "operationId" : "getAccountGroupDetails",
        "parameters" : [ {
          "in" : "path",
          "name" : "accountGroupId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AccountGroupData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get Account Group details.",
        "tags" : [ "Access" ]
      }
    },
    "/api/pub/account-group/{accountGroupId}/members" : {
      "get" : {
        "description" : "List Account Group members.\n Returns accounts that have been assigned to the Account Group and that match the given criteria.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListAccountGroupMembers`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountGroupId` | Assigned by an account permits any account group owned by the account. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listAccountGroupMembers",
        "parameters" : [ {
          "in" : "path",
          "name" : "accountGroupId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter by account ids",
          "in" : "query",
          "name" : "accountIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "List groups that match the given metadata. Supported metadata refs: [MetadataEntityRefType.ACCOUNT]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.ACCOUNT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `accountId`\n\n To sort in descending order, prefix the field name with `-`, e.g. `-ownerId`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAccountData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List Account Group members.",
        "tags" : [ "Access" ]
      }
    },
    "/api/pub/account-groups" : {
      "get" : {
        "description" : "List Account Groups.\n Returns Account Groups that match the given criteria.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListAccountGroups`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `ownerIds` | Assigned by an account permits any account group owned by the account. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listAccountGroups",
        "parameters" : [ {
          "description" : "List groups by id.",
          "in" : "query",
          "name" : "accountGroupIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List groups that have the given owner(s).",
          "in" : "query",
          "name" : "ownerIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List groups that contain any of the given accounts.",
          "in" : "query",
          "name" : "hasAnyOf",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List groups that contain none of the given accounts.",
          "in" : "query",
          "name" : "hasNoneOf",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List groups that match the given attributes.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "List groups that match the given metadata. Supported metadata refs: [MetadataEntityRefType.ACCOUNT_GROUP]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.ACCOUNT_GROUP]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Set to `true` to include deleted account groups in the result.",
          "in" : "query",
          "name" : "includeDeleted",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `id`\n * `ownerId`\n * `accountGroupAttribute.xxx` where `xxx` is an attribute name\n * `metadata.xxx` where `xxx` is a metadata reference\n\n To sort in descending order, prefix the field name with `-`, e.g. `-ownerId`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAccountGroupData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List Account Groups.",
        "tags" : [ "Access" ]
      }
    },
    "/api/pub/account/accessible-accounts" : {
      "get" : {
        "description" : "List accessible request accounts.\n List user accounts and request accounts that match the given criteria.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListAccessibleAccounts`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accessKeyId` | An access key's default user account can assign permission to access its accessible user accounts. |\n| `userAccountId` | A user account can assign permission to access its accessible accounts. |\n",
        "operationId" : "listAccessibleRequestAccounts",
        "parameters" : [ {
          "description" : "When set, list the user accounts and subsequent request accounts that can be accessed with this access key.\n If there are more than 10 user accounts accessible by this access key, the request will fail with `QueryTooBroad`.",
          "in" : "query",
          "name" : "accessKeyId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "When set, query accessible accounts for any of the given user account ids.\n Either `accessKeyId` or `userAccountId` must be set.",
          "in" : "query",
          "name" : "userAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, only include security groups with the given ownerIds.",
          "in" : "query",
          "name" : "ownerIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, only include security group assignments that were assigned by one of the accounts in the list.",
          "in" : "query",
          "name" : "requestAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, only include accessible accounts that have assigned one of these security groups.",
          "in" : "query",
          "name" : "securityGroupId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, only include accessible accounts that are a member of one of the given account groups.",
          "in" : "query",
          "name" : "accountGroupId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, only include accounts that are a member of a visible account group that matches the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If set, only include accounts that are a member of a visible account group that matches the given metadata criteria.<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references: [MetadataEntityRefType.ACCOUNT], [MetadataEntityRefType.ACCOUNT_GROUP]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `requestAccountId`\n * `userAccountId`\n * `overrideDefault`—Boolean field that indicates whether this entry overrides the default security group for the user account ID.\n To sort in descending order, prefix the field name with `-`, e.g. `-userAccountId`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAccessibleRequestAccountData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List accessible request accounts.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/account/balances" : {
      "get" : {
        "description" : "List current balances.\n Retrieve the current balances of accounts, per product and optionally per product item. The results are paged and can be sorted.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListCurrentBalances`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountId` | Assigned by the account(s) grants permission to its balances. |\n| `productId` | Assigned by the issuer(s) of the product(s) grants permission for those product's balances of any accounts. |\n| `issuerId` | Assigned by an issuer grants permission for all their products and any accounts. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listCurrentBalances",
        "parameters" : [ {
          "description" : "Filter holdings for an account.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by productId.",
          "in" : "query",
          "name" : "productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by product item id.",
          "in" : "query",
          "name" : "productItemId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by the account id of the issuer of the product.",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include full product data in response.",
          "in" : "query",
          "name" : "includeProductData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "If true, balances are grouped by product. If false, balances are returned for individual product items.",
          "in" : "query",
          "name" : "sumProductItems",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "If true, results are not returned grouped by account but rather the total across all (matching) accounts is returned.",
          "in" : "query",
          "name" : "sumAccounts",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include full product item data in response.",
          "in" : "query",
          "name" : "includeProductItemData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include issuer data in response.",
          "in" : "query",
          "name" : "includeIssuerData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter by product item attributes.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.PRODUCT], [MetadataEntityRefType.PRODUCT_ITEM], [MetadataEntityRefType.ACCOUNT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `amount`\n * `unassignedAmount`\n * `assignedAmount`\n * `escrowAmount`\n * `issuerAmount`\n * `product`\n * `productItem`\n * `accountId`\n * `productItemAttribute.xxx` where `xxx` is an attribute name\n * `metadata.xxx` where `xxx` is a metadata reference. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "in" : "query",
          "name" : "isUnassigned",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseBalanceData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List current balances.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/account/{accountId}/access" : {
      "get" : {
        "description" : "Get account access details.\n List access keys that can access an account.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetAccountAccess`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountId` | An account can assign permission to access its account details. |\n",
        "operationId" : "getAccountAccessDetails",
        "parameters" : [ {
          "description" : "The account to query access keys for",
          "in" : "path",
          "name" : "accountId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAccountAccessData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get account access details.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/assigned-security-groups" : {
      "get" : {
        "description" : "List Security Group assignments.\n Lists all the security groups that are assigned to an account and/or account group\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListAssignedSecurityGroups`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountIds` | Assigned by an account permits listing assignments for the account. |\n| `ownerIds` | Assigned by an account permits listing assignments for any account group owned by the account. |\n| `assignedBy` | Assigned by an account permits listing assignments made by the account. |\n",
        "operationId" : "listAssignedSecurityGroups",
        "parameters" : [ {
          "description" : "List security group assignments only for the given accounts.",
          "in" : "query",
          "name" : "accountIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, only include security groups with the given ownerIds.",
          "in" : "query",
          "name" : "ownerIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, only include security group assignments that were assigned by one of the accounts in the list.",
          "in" : "query",
          "name" : "assignedBy",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, only include security groups with the given id.",
          "in" : "query",
          "name" : "securityGroupId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, only include security groups with the given account group id.",
          "in" : "query",
          "name" : "accountGroupId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, only security groups with the given permission type are returned.",
          "in" : "query",
          "name" : "permissionType",
          "required" : false,
          "schema" : {
            "type" : "string",
            "enum" : [ "Request", "Product", "Issuer", "Controller" ]
          }
        }, {
          "description" : "If set to `true`, the security group details are returned (excluding any attributes).",
          "in" : "query",
          "name" : "includeSecurityGroup",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "If set to `true`, the account group details are returned (excluding any attributes).",
          "in" : "query",
          "name" : "includeAccountGroup",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "If set to `true`, the security group and account group details will contain current attribute values.",
          "in" : "query",
          "name" : "includeAttributes",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include extra indexed and non-indeed metadata in the response.\n Supported entity references: [MetadataEntityRefType.ACCOUNT], [MetadataEntityRefType.ACCOUNT_GROUP],\n [MetadataEntityRefType.SECURITY_GROUP]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `securityGroupId`\n * `assignedBy`\n * `accountGroupId`\n * `accountId`\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAssignedSecurityGroupData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List Security Group assignments.",
        "tags" : [ "Access" ]
      }
    },
    "/api/pub/attributes" : {
      "get" : {
        "description" : "List attributes.\n Returns attribute definitions. The results are limited and can be paged by attribute tag number.\n#### Endpoint Permission\nAlways permitted. Attribute definitions can always be retrieved. NOTE: This will change to requiring attributes to be filtered by issuer.\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listAttributeDefinitions",
        "parameters" : [ {
          "description" : "Attribute tag criterion",
          "in" : "query",
          "name" : "tag",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Attribute name criterion",
          "in" : "query",
          "name" : "name",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "When set, only return attribute definitions owned by the given issuers.",
          "in" : "query",
          "name" : "createdBy",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Attribute type",
          "in" : "query",
          "name" : "valueType",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "BOOLEAN", "INTEGER", "DECIMAL", "BYTESTRING", "STRING", "MAP", "URI", "TIMESTAMP", "PRODUCT", "DOCUMENT", "LATLON", "TRANSACTION_TYPE", "ENUMERATED", "DATE", "DATETIME", "YEARMONTH" ]
            }
          }
        }, {
          "description" : "If attribute has validation rules",
          "in" : "query",
          "name" : "hasValidationRules",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.ATTRIBUTE_DEFINITION]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.ATTRIBUTE_DEFINITION]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n `id`\n `tag` (equivalent to `id`)\n `name`\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAttributeDefinitionData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List attributes.",
        "tags" : [ "System info" ]
      }
    },
    "/api/pub/attributes/enum" : {
      "get" : {
        "description" : "List enum values.\n#### Endpoint Permission\nAlways permitted. Attribute enums can always be retrieved. NOTE: This will change to requiring attributes to be filtered by issuer.",
        "operationId" : "listAttributeEnums_1",
        "parameters" : [ {
          "in" : "query",
          "name" : "attributeName",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Return only enabled or disabled attributes. If not specified, all attributes are returned.",
          "in" : "query",
          "name" : "enabled",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseEnumValueDefinition"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List enum values.",
        "tags" : [ "System info" ]
      }
    },
    "/api/pub/attributes/enum-values" : {
      "get" : {
        "description" : "List enum values.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListEnumValues`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerId` | Assigned by an issuer permits retrieving all enum values for this issuer's attributes. |\n| `attribute` | Assigned by an issuer permits retrieving all enum values for the referenced attributes. |\n| *issuer admin* | Assigned by the Issuer Admin account permits retrieving all enum values. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listEnumValues",
        "parameters" : [ {
          "description" : "When set, issuers of the attributes with which the enum values are associated.",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "When set, return enum values for attributes (of type `ENUM`) that match the reference.",
          "in" : "query",
          "name" : "attribute",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "When set, filter attributes by matching name. Issuer ID must be set when matching attributes by name.",
          "in" : "query",
          "name" : "attributeName",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "When set, filter enum values by matching name.",
          "in" : "query",
          "name" : "enumValueName",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "When set, filter enum values by matching ordinal.",
          "in" : "query",
          "name" : "enumValueOrdinal",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "When set, only return enum values with a matching status.",
          "in" : "query",
          "name" : "status",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "ENABLED", "DISABLED" ]
            }
          }
        }, {
          "description" : "Include metadata for [MetadataEntityRefType.ATTRIBUTE_DEFINITION] (in the paged response MetadataMap),\n [MetadataEntityRefType.ATTRIBUTE_ENUM] (in each entry's metadata).",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Sort by:\n - ordinal\n - name\n - tag\n - status",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseEnumValueData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List enum values.",
        "tags" : [ "System info" ]
      }
    },
    "/api/pub/attributes/{attributeTag}/enum" : {
      "get" : {
        "description" : "List enum values.\n#### Endpoint Permission\nAlways permitted. Attribute enums can always be retrieved. NOTE: This will change to requiring attributes to be filtered by issuer.",
        "operationId" : "listAttributeEnums",
        "parameters" : [ {
          "in" : "path",
          "name" : "attributeTag",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Return only enabled or disabled attributes. If not specified, all attributes are returned.",
          "in" : "query",
          "name" : "enabled",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseEnumValueDefinition"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List enum values.",
        "tags" : [ "System info" ]
      }
    },
    "/api/pub/block" : {
      "get" : {
        "description" : "Get latest block header.\n Returns the header information for the latest block that is known to the system.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetBlockHeader`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| *issuer admin* | Access to block data has to be assigned by the Issuer Admin account. |\n",
        "operationId" : "getLatestBlockHeader",
        "parameters" : [ {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/BlockHeader"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get latest block header.",
        "tags" : [ "System info" ]
      }
    },
    "/api/pub/blocks" : {
      "get" : {
        "description" : "List blocks.\n Retrieve block data for a given range of block numbers.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListBlocks`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| *issuer admin* | Access to block data has to be assigned by the Issuer Admin account. |\n",
        "operationId" : "listBlocks",
        "parameters" : [ {
          "description" : "If specified, return only transactions restricted to these block numbers. Can be a range (ex: 1..5), a list of values (ex: 2,3,6) or a combination, negation is also possible (ex: !5).",
          "in" : "query",
          "name" : "block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only transactions restricted to these timestamps. Can be a range (ex: 2023-07-01T01:00:00.000Z..2023-09-01T01:00:00.000Z), a list of exact values (ex: 2023-09-01T01:00:00.000Z,2023-09-01T02:00:00.000Z) or a combination, negation is also possible (ex: !2023-09-01T01:00:00.000Z).",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `id`\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseBlockData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List blocks.",
        "tags" : [ "System info" ]
      }
    },
    "/api/pub/escrow" : {
      "get" : {
        "description" : "List escrows.\n Returns escrows that match the given criteria. The escrows for a particular account can be queried,\n as well as the escrows where a particular account is the controller.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListEscrow`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `controllerAccountId` | Assigned by an account permits all escrows controlled by the account. |\n| `holderAccountId` | Assigned by an account permits all escrows held by the account. |\n| `productId` | Assigned by the issuer of a product permits all escrows of that product. |\n",
        "operationId" : "listEscrow",
        "parameters" : [ {
          "description" : "List escrows for a given controller.",
          "in" : "query",
          "name" : "controllerAccountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "List escrows for a given holder.",
          "in" : "query",
          "name" : "holderAccountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "List escrows for a given product.",
          "in" : "query",
          "name" : "productId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "List escrows for a given product item.",
          "in" : "query",
          "name" : "productItemId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "List specific escrow ids",
          "in" : "query",
          "name" : "escrowId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references:\n * [MetadataEntityRefType.PRODUCT]\n * [MetadataEntityRefType.ACCOUNT]\n * [MetadataEntityRefType.PRODUCT_ITEM]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `id`\n * `controllerAccountId`\n * `holderAccountId`\n * `productId`\n * `remainingAmount`\n * `productItemAttribute.xxx` where `xxx` is an attribute name\n\n To sort in descending order, prefix the field name with `-`, e.g. `-remainingAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseEscrowTransactionData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List escrows.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/history" : {
      "get" : {
        "description" : "List historical balance changes.\n Query the net balance changes by product with filtering, grouping, and sorting.\n The result contains one entry for each unique combination of the grouped values, with the balance data of that entry\n representing the net (i.e., positive or negative) holding balance change.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListBalanceHistory`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountId` | Assigned by the account when filtering by account |\n| `signedByUserAccountId` | Assigned by an account permits all transactions initiated or approved by that account. |\n| `productId` | Assigned by the issuer of the product permits all accounts for that product |\n| `issuerId` | Assigned by an issuer permits all accounts for all products of the issuer |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listBalanceHistory",
        "parameters" : [ {
          "description" : "Each entry must be one of:\n- `transaction`: group results by transaction (and return `transaction` data in the response);\n- `productItem`: group results by product item (and return `productItem` data in the response);\n- `accountId`: group results by account ID of the holding;\n- `withIssuer`: group non-issuer results separate from issuer results (where the holding account is the product's issuer);\n- `transactionAttribute.<name>`: group by a transaction attribute. The attribute's value is returned in `transactionAttributes`;\n- `productItemAttribute.<name>`: group by a product item attribute. The attribute's value is returned in `productItemAttributes`;\n- `metadata.<issuerId>:<name>`/`metadata.<tag>`: group by a metadata value. The metadata value is returned in the `metadata` field of the response. Supported metadata entity references to group by: transaction, product item.\n\nThe order in which the entries are specified determines the order of the results.",
          "in" : "query",
          "name" : "groupBy",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only transactions restricted to these block numbers. Can be a range (ex: 1..5), a list of values (ex: 2,3,6) or a combination, negation is also possible (ex: !5).",
          "in" : "query",
          "name" : "block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only transactions restricted to these timestamps. Can be a range (ex: 2023-07-01T01:00:00.000Z..2023-09-01T01:00:00.000Z), a list of exact values (ex: 2023-09-01T01:00:00.000Z,2023-09-01T02:00:00.000Z) or a combination, negation is also possible (ex: !2023-09-01T01:00:00.000Z).",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, only return results for (non-deleted) products of the given issuer.",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, only return results for one of the given products.",
          "in" : "query",
          "name" : "productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, only return result for one of the given product items.",
          "in" : "query",
          "name" : "productItem",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only transactions that spent/issued holdings where the product item matches the given criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "productItemAttribute",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, return only transactions that match the given ids.",
          "in" : "query",
          "name" : "transaction",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only transactions that match the given ids.",
          "in" : "query",
          "name" : "transactionId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only transactions that spent/issued holdings where the transaction request matches the given criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "transactionAttribute",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, return only transactions that match the given transaction type.",
          "in" : "query",
          "name" : "transactionType",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter by one of more account ids.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only transactions that match one of the given request accounts. Note that the requester is not always\n the sender. In case of escrow transfers, the requester will be the controller whereas the main account IDs will be\n the sender or receiver.",
          "in" : "query",
          "name" : "requestAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only transactions that also have an effect on one of the given counterparties.",
          "in" : "query",
          "name" : "counterparty",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only results where the total amount matches the criteria.",
          "in" : "query",
          "name" : "amount",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only results where the assigned amount matches the criteria.",
          "in" : "query",
          "name" : "assignedAmount",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only results where the unassigned amount matches the criteria.",
          "in" : "query",
          "name" : "unassignedAmount",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only results where the escrow amount matches the criteria.",
          "in" : "query",
          "name" : "escrowAmount",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only results where the baked amount matches the criteria.",
          "in" : "query",
          "name" : "bakedAmount",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If true, the query is implicitly also grouped by accountId and productId",
          "in" : "query",
          "name" : "includeBalanceMap",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "If specified, return transactions that were signed by one of the given user account ids.",
          "in" : "query",
          "name" : "signedByUserAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter by indexed metadata.\n If specified, return only transactions that spent/issued holdings where the product item or transaction request metadata matches the given criteria.\n Supported entity references: [MetadataEntityRefType.TRANSACTION], [MetadataEntityRefType.TRANSACTION_ID], [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter counter party by [MetadataEntityRefType.ACCOUNT]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "counterpartyMetadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.TRANSACTION], [MetadataEntityRefType.TRANSACTION_ID], [MetadataEntityRefType.PRODUCT_ITEM], [MetadataEntityRefType.ACCOUNT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Each entry must be one of:\n- `<operation>.transactionAttribute.name`: aggregate a result over a transaction attribute. The value is returned in `transactionAttributes`;\n- `<operation>.productItemAttribute.name`: aggregate a result over a product item attribute. The value is returned in `productItemAttributes`;\n\n`<operation>` can be one of:\n- `SUM`\n- `COUNT`\n- `COUNT_DISTINCT`\n",
          "in" : "query",
          "name" : "aggregateBy",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Include signatory data in response when grouped by transactions.",
          "in" : "query",
          "name" : "includeSignatories",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `amount`\n * `unassignedAmount`\n * `assignedAmount`\n * `escrowAmount`\n * `bakedAmount`\n * `productId`\n * `transaction`\n * `productItem`\n * `accountId`\n * `withIssuer`\n * `productItemAttribute.xxx` where `xxx` is an attribute name when aggregating/grouping by it\n * `transactionAttribute.xxx` where `xxx` is an attribute name when aggregating/grouping by it\n * `metadata.xxx` where `xxx` is a metadata reference. Supported entity references: [MetadataEntityRefType.TRANSACTION], [MetadataEntityRefType.TRANSACTION_ID], [MetadataEntityRefType.PRODUCT_ITEM]\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseBalanceHistoryData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List historical balance changes.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/holding/history" : {
      "get" : {
        "description" : "List history for a holding.\n Query the history of a holding, or range of holdings, showing the transactions and the state of the holding through time.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetHoldingHistory`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `productItemId` | Assigned by the issuer permits access to all product item history. |\n",
        "operationId" : "getHoldingHistory",
        "parameters" : [ {
          "description" : "Product item Id to which a holding pertains.",
          "example" : "200:0",
          "in" : "query",
          "name" : "productItemId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "200:0"
          }
        }, {
          "description" : "Particular assignment inside a holding.",
          "example" : 0,
          "in" : "query",
          "name" : "index",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int64",
            "example" : 0
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `id`\n\n To sort in descending order, prefix the field name with `-`, e.g. `-quantity`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only transactions restricted to these block numbers.\n\n Can be a range (ex: 1..5), a list of values (ex: 2,3,6) or a combination, negation is also possible (ex: !5).",
          "in" : "query",
          "name" : "block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only transactions restricted to these timestamps.\n Can be a range (ex: 2023-07-01T01:00:00.000Z..2023-09-01T01:00:00.000Z),\n a list of exact values (ex: 2023-09-01T01:00:00.000Z,2023-09-01T02:00:00.000Z)\n or a combination, negation is also possible (ex: !2023-09-01T01:00:00.000Z).",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseHoldingTransactionData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List history for a holding.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/holding/{holdingId}" : {
      "get" : {
        "description" : "Get holding detail.\n Returns the detail of the given holding.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetHolding`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `holdingId` | Assigned by the holding account permits access to all holdings of the account. |\n| `holdingId` | Assigned by an issuer permits access to all holdings of that issuer. |\n",
        "operationId" : "getHoldingInfo",
        "parameters" : [ {
          "description" : "The unique identifier of the holding (`block:index`)",
          "in" : "path",
          "name" : "holdingId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references:\n [MetadataEntityRefType.PRODUCT], [MetadataEntityRefType.ACCOUNT], [MetadataEntityRefType.PRODUCT_ITEM], (\n and [MetadataEntityRefType.BAKED_HOLDING] for endpoints that return [HoldingState.Baked] holdings )",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "uniqueItems" : true
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/HoldingData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get holding detail.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/holdings" : {
      "get" : {
        "description" : "List current holdings.\n List the current holdings that match a given criteria. The results will be limited and can be paged using the blockNumber\n in which the holding was issued.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListCurrentHoldings`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountId` | Assigned by the account when filtering by account |\n| `productId` | Assigned by the issuer of the product permits all accounts for that product |\n| `issuerId` | Assigned by an issuer permits all accounts for all products of the issuer |\n| `controllerAccountId` | Assigned by a controller account permits all holdings escrowed to that controller |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listHoldings",
        "parameters" : [ {
          "description" : "Filter holdings by account id.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by controller account id.",
          "in" : "query",
          "name" : "controllerAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by productId.",
          "in" : "query",
          "name" : "productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by product item id.",
          "in" : "query",
          "name" : "productItemId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by specific holding ids.",
          "in" : "query",
          "name" : "holdingId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by escrow id.",
          "in" : "query",
          "name" : "escrowId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "When set, include only holdings that have been baked into the given product item.\n In other words, where the result holdings are the underlying of other product items.\n To select holdings that are baked into a product item that matches certain conditions, use the `underlyingOf` parameter.",
          "in" : "query",
          "name" : "bakedInto",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlyingOf.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlyingOf.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlyingOf.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlyingOf.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlyingOf.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlyingOf.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlyingOf.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "andUnderlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "andUnderlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "andUnderlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "andUnderlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "andUnderlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter holdings by status. If no state filter is given, only non-spent holdings are returned. If the state\n filter includes a spent state (i.e. `Baked`, `Deflated`, or `Spent`), the spent holdings are included.",
          "in" : "query",
          "name" : "state",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "Spent", "Unassigned", "Unspent", "Escrowed", "Baked", "Deflated" ]
            }
          }
        }, {
          "description" : "Include product data in response.",
          "in" : "query",
          "name" : "includeProductData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include product item data in response.",
          "in" : "query",
          "name" : "includeProductItemData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter holdings by the account id of the issuer.",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include issuer data in response.",
          "in" : "query",
          "name" : "includeIssuerData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter by product item attributes if possible.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references: [MetadataEntityRefType.PRODUCT], [MetadataEntityRefType.ACCOUNT],\n [MetadataEntityRefType.PRODUCT_ITEM], ( and [MetadataEntityRefType.BAKED_HOLDING]\n for endpoints that return [HoldingState.Baked] holdings )",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields when they are grouped by them:\n\n * `accountId`\n * `amount`\n * `unassignedAmount`\n * `assignedAmount`\n * `escrowAmount`\n * `issuerAmount`\n * `productId` by product id\n * `productItemId` by product item id\n * `productItemAttribute.xxx` by product item attribute, where xxx is an attribute name.\n * `metadata.xxx` where `xxx` is a metadata reference. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "examples" : {
            "amount" : {
              "description" : "amount",
              "value" : "amount"
            },
            "assigned amount" : {
              "description" : "assigned amount",
              "value" : "assignedAmount"
            },
            "descending" : {
              "description" : "descending",
              "value" : "-amount"
            },
            "escrow amount" : {
              "description" : "escrow amount",
              "value" : "escrowAmount"
            },
            "id" : {
              "description" : "id",
              "value" : "id"
            },
            "product item attribute" : {
              "description" : "product item attribute",
              "value" : "productItemAttribute.$nameOfTheAttribute"
            },
            "product item id" : {
              "description" : "product item id",
              "value" : "productItemId"
            },
            "productId id" : {
              "description" : "productId id",
              "value" : "productId"
            },
            "quantity" : {
              "description" : "quantity",
              "value" : "quantity"
            },
            "unassigned amount" : {
              "description" : "unassigned amount",
              "value" : "unassignedAmount"
            }
          },
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only holdings that were issued (and not spent) in the matching blocks numbers.\n The parameter can be a range (eg 1234..5678) to return all holdings that were issued (and not spent)\n in the block range.\n If the parameter is a single block number, the system will replace it with the range `..=blockNumber` so the holdings\n returned are a snapshot of the holdings that were active holdings upto (and including) the given blockNumber.\n\n Default when not present is to return all active holdings up to the current block.",
          "in" : "query",
          "name" : "block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only holdings that were issued (and not spent) in the matching time range.\n The parameter can be a range (eg 20240101T000000..) to return all holdings that were issued in the timestamp range.\n If the parameter is a single timestamp, the system will replace it with the range `..timestamp` so the holdings\n returned are a snapshot of the active holdings at the timestamp.\n\n Default when not present is to return all active holdings up to the current time.",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter by index using ranges (ex: 3..7) and individual values (ex: 1,5,6). Combinations are also possible (ex: 1..5,8,12). A Not (!) logic is not accepted.",
          "in" : "query",
          "name" : "index",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include information about underlying holdings in the result. The underlying amounts can be grouped by different\n properties:\n\n * `underlyingHolding`: Return individual underlying holdings.\n * `underlyingProduct`: Return total underlying amounts by product.\n * `underlyingProductItem`: Return total underlying amounts per distinct underlying product item.\n * `underlyingAttribute.<name>`: Return total amounts grouped by attribute value of the underlying product item.\n * `underlyingMetadata.<issuer>:<name>`: Return total amounts grouped by (indexed) metadata value of the underlying product item.\n\n If `includeUnderlying` is absent, no results for underlying holdings are returned.\n If `includeUnderlying` is present, the results are always grouped by `underlyingProduct`.",
          "in" : "query",
          "name" : "includeUnderlyingData",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseHoldingData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List current holdings.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/holdings/balances" : {
      "get" : {
        "description" : "List balances of current and historic holdings.\n List the balances of holdings that match the criteria. This method can also return results for current holdings\n depending on the state filter that is set.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListHoldingBalances`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountId` | Assigned by the account when filtering by account |\n| `bakedInto` | Assigned by the issuer of a baked product item's product permits all balances for that item. |\n| `productId` | Assigned by the issuer of the product permits all accounts for that product |\n| `issuerId` | Assigned by an issuer permits all accounts for all products of the issuer |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listHoldingBalances",
        "parameters" : [ {
          "description" : "Filter holdings by account id.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by productId.",
          "in" : "query",
          "name" : "productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by product item id.",
          "in" : "query",
          "name" : "productItemId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by specific holding ids.",
          "in" : "query",
          "name" : "holdingId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by escrow id.",
          "in" : "query",
          "name" : "escrowId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "When set, include only holdings that have been baked into the given product item.\n In other words, where the result holdings are the underlying of other product items.\n To select holdings that are baked into a product item that matches certain conditions, use the `underlyingOf` parameter.",
          "in" : "query",
          "name" : "bakedInto",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlyingOf.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlyingOf.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlyingOf.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlyingOf.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlyingOf.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlyingOf.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlyingOf.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "andUnderlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "andUnderlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "andUnderlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "andUnderlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "andUnderlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter holdings by status. If no state filter is given, only non-spent holdings are returned. If the state\n filter includes a spent state (i.e. `Baked`, `Deflated`, or `Spent`), the spent holdings are included.",
          "in" : "query",
          "name" : "state",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "Spent", "Unassigned", "Unspent", "Escrowed", "Baked", "Deflated" ]
            }
          }
        }, {
          "description" : "Include product data in response.",
          "in" : "query",
          "name" : "includeProductData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include product item data in response.",
          "in" : "query",
          "name" : "includeProductItemData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter holdings by the account id of the issuer.",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include issuer data in response.",
          "in" : "query",
          "name" : "includeIssuerData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter by product item attributes if possible.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references: [MetadataEntityRefType.PRODUCT], [MetadataEntityRefType.ACCOUNT],\n [MetadataEntityRefType.PRODUCT_ITEM], ( and [MetadataEntityRefType.BAKED_HOLDING]\n for endpoints that return [HoldingState.Baked] holdings )",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields when they are grouped by them:\n\n * `accountId`\n * `amount`\n * `unassignedAmount`\n * `assignedAmount`\n * `escrowAmount`\n * `issuerAmount`\n * `productId` by product id\n * `productItemId` by product item id\n * `productItemAttribute.xxx` by product item attribute, where xxx is an attribute name.\n * `metadata.xxx` where `xxx` is a metadata reference. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "examples" : {
            "account id" : {
              "description" : "account id",
              "value" : "accountId"
            },
            "amount" : {
              "description" : "amount",
              "value" : "amount"
            },
            "assigned amount" : {
              "description" : "assigned amount",
              "value" : "assignedAmount"
            },
            "baked amount" : {
              "description" : "baked amount",
              "value" : "bakedAmount"
            },
            "descending" : {
              "description" : "descending",
              "value" : "-amount"
            },
            "escrow amount" : {
              "description" : "escrow amount",
              "value" : "escrowAmount"
            },
            "issuer amount" : {
              "description" : "issuer amount",
              "value" : "issuerAmount"
            },
            "product id" : {
              "description" : "product id",
              "value" : "product"
            },
            "product item attribute" : {
              "description" : "product item attribute",
              "value" : "productItemAttribute.$nameOfTheAttribute"
            },
            "product item id" : {
              "description" : "product item id",
              "value" : "productItem"
            },
            "unassigned amount" : {
              "description" : "unassigned amount",
              "value" : "unassignedAmount"
            }
          },
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only holdings that were issued (and not spent) in the matching blocks numbers.\n The parameter can be a range (eg 1234..5678) to return all holdings that were issued (and not spent)\n in the block range.\n If the parameter is a single block number, the system will replace it with the range `..=blockNumber` so the holdings\n returned are a snapshot of the holdings that were active holdings upto (and including) the given blockNumber.\n\n Default when not present is to return all active holdings up to the current block.",
          "in" : "query",
          "name" : "block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only holdings that were issued (and not spent) in the matching time range.\n The parameter can be a range (eg 20240101T000000..) to return all holdings that were issued in the timestamp range.\n If the parameter is a single timestamp, the system will replace it with the range `..timestamp` so the holdings\n returned are a snapshot of the active holdings at the timestamp.\n\n Default when not present is to return all active holdings up to the current time.",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter by index using ranges (ex: 3..7) and individual values (ex: 1,5,6). Combinations are also possible (ex: 1..5,8,12). A Not (!) logic is not accepted.",
          "in" : "query",
          "name" : "index",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include information about underlying holdings in the result. The underlying amounts can be grouped by different\n properties:\n\n * `underlyingHolding`: Return individual underlying holdings.\n * `underlyingProduct`: Return total underlying amounts by product.\n * `underlyingProductItem`: Return total underlying amounts per distinct underlying product item.\n * `underlyingAttribute.<name>`: Return total amounts grouped by attribute value of the underlying product item.\n * `underlyingMetadata.<issuer>:<name>`: Return total amounts grouped by (indexed) metadata value of the underlying product item.\n\n If `includeUnderlying` is absent, no results for underlying holdings are returned.\n If `includeUnderlying` is present, the results are always grouped by `underlyingProduct`.",
          "in" : "query",
          "name" : "includeUnderlyingData",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "in" : "query",
          "name" : "sumProductItems",
          "required" : false,
          "schema" : {
            "type" : "boolean",
            "default" : true
          }
        }, {
          "in" : "query",
          "name" : "sumAccounts",
          "required" : false,
          "schema" : {
            "type" : "boolean",
            "default" : true
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseBalanceData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List balances of current and historic holdings.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/holdings/spent" : {
      "get" : {
        "description" : "List spent holdings.\n List the spent holdings that match a given criteria. The results will be limited and can be paged using the blockNumber\n in which the holding was issued.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListSpentHoldings`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountId` | Assigned by the account when filtering by account |\n| `productId` | Assigned by the issuer of the product permits all accounts for that product |\n| `issuerId` | Assigned by an issuer permits all accounts for all products of the issuer |\n| `controllerAccountId` | Assigned by the controller when filtering by controller |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listSpentHoldings",
        "parameters" : [ {
          "description" : "Filter holdings by account id.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by controller account id.",
          "in" : "query",
          "name" : "controllerAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by productId.",
          "in" : "query",
          "name" : "productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by product item id.",
          "in" : "query",
          "name" : "productItemId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by specific holding ids.",
          "in" : "query",
          "name" : "holdingId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by escrow id.",
          "in" : "query",
          "name" : "escrowId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "When set, include only holdings that have been baked into the given product item.\n In other words, where the result holdings are the underlying of other product items.\n To select holdings that are baked into a product item that matches certain conditions, use the `underlyingOf` parameter.",
          "in" : "query",
          "name" : "bakedInto",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlyingOf.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlyingOf.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlyingOf.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlyingOf.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlyingOf.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlyingOf.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlyingOf.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "andUnderlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "andUnderlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "andUnderlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "andUnderlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "andUnderlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter holdings by status. If no state filter is given, only non-spent holdings are returned. If the state\n filter includes a spent state (i.e. `Baked`, `Deflated`, or `Spent`), the spent holdings are included.",
          "in" : "query",
          "name" : "state",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "Spent", "Unassigned", "Unspent", "Escrowed", "Baked", "Deflated" ]
            }
          }
        }, {
          "description" : "Include product data in response.",
          "in" : "query",
          "name" : "includeProductData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include product item data in response.",
          "in" : "query",
          "name" : "includeProductItemData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter holdings by the account id of the issuer.",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include issuer data in response.",
          "in" : "query",
          "name" : "includeIssuerData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter by product item attributes if possible.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references: [MetadataEntityRefType.PRODUCT], [MetadataEntityRefType.ACCOUNT],\n [MetadataEntityRefType.PRODUCT_ITEM], ( and [MetadataEntityRefType.BAKED_HOLDING]\n for endpoints that return [HoldingState.Baked] holdings )",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields when they are grouped by them:\n\n * `accountId`\n * `amount`\n * `unassignedAmount`\n * `assignedAmount`\n * `escrowAmount`\n * `issuerAmount`\n * `productId` by product id\n * `productItemId` by product item id\n * `productItemAttribute.xxx` by product item attribute, where xxx is an attribute name.\n * `metadata.xxx` where `xxx` is a metadata reference. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "examples" : {
            "account id" : {
              "description" : "account id",
              "value" : "accountId"
            },
            "amount" : {
              "description" : "amount",
              "value" : "amount"
            },
            "descending" : {
              "description" : "descending",
              "value" : "-amount"
            },
            "id" : {
              "description" : "id",
              "value" : "id"
            },
            "index" : {
              "description" : "index",
              "value" : "index"
            },
            "product id" : {
              "description" : "product id",
              "value" : "productId"
            },
            "product item attribute" : {
              "description" : "product item attribute",
              "value" : "productItemAttribute.$nameOfTheAttribute"
            },
            "product item id" : {
              "description" : "product item id",
              "value" : "productItemId"
            },
            "quantity" : {
              "description" : "quantity",
              "value" : "quantity"
            }
          },
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only holdings that were issued (and not spent) in the matching blocks numbers.\n The parameter can be a range (eg 1234..5678) to return all holdings that were issued (and not spent)\n in the block range.\n If the parameter is a single block number, the system will replace it with the range `..=blockNumber` so the holdings\n returned are a snapshot of the holdings that were active holdings upto (and including) the given blockNumber.\n\n Default when not present is to return all active holdings up to the current block.",
          "in" : "query",
          "name" : "block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only holdings that were issued (and not spent) in the matching time range.\n The parameter can be a range (eg 20240101T000000..) to return all holdings that were issued in the timestamp range.\n If the parameter is a single timestamp, the system will replace it with the range `..timestamp` so the holdings\n returned are a snapshot of the active holdings at the timestamp.\n\n Default when not present is to return all active holdings up to the current time.",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter by index using ranges (ex: 3..7) and individual values (ex: 1,5,6). Combinations are also possible (ex: 1..5,8,12). A Not (!) logic is not accepted.",
          "in" : "query",
          "name" : "index",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include information about underlying holdings in the result. The underlying amounts can be grouped by different\n properties:\n\n * `underlyingHolding`: Return individual underlying holdings.\n * `underlyingProduct`: Return total underlying amounts by product.\n * `underlyingProductItem`: Return total underlying amounts per distinct underlying product item.\n * `underlyingAttribute.<name>`: Return total amounts grouped by attribute value of the underlying product item.\n * `underlyingMetadata.<issuer>:<name>`: Return total amounts grouped by (indexed) metadata value of the underlying product item.\n\n If `includeUnderlying` is absent, no results for underlying holdings are returned.\n If `includeUnderlying` is present, the results are always grouped by `underlyingProduct`.",
          "in" : "query",
          "name" : "includeUnderlyingData",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseHoldingData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List spent holdings.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/holdings/underlying" : {
      "get" : {
        "description" : "List underlying information.\n\n List balances and optionally detail of the underlying (baked) holdings of product items held by an account.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListUnderlyingHoldings`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountId` | Assigned by the account when filtering by account |\n| `productId` | Assigned by the issuer of the product permits all accounts for that product |\n| `issuerId` | Assigned by an issuer permits all accounts for all products of the issuer |\n| `controllerAccountId` | Assigned by the controller when filtering by controller |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listUnderlyingHoldings",
        "parameters" : [ {
          "description" : "Filter holdings by account id.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by controller account id.",
          "in" : "query",
          "name" : "controllerAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by productId.",
          "in" : "query",
          "name" : "productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by product item id.",
          "in" : "query",
          "name" : "productItemId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by specific holding ids.",
          "in" : "query",
          "name" : "holdingId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter holdings by escrow id.",
          "in" : "query",
          "name" : "escrowId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "When set, include only holdings that have been baked into the given product item.\n In other words, where the result holdings are the underlying of other product items.\n To select holdings that are baked into a product item that matches certain conditions, use the `underlyingOf` parameter.",
          "in" : "query",
          "name" : "bakedInto",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlyingOf.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlyingOf.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlyingOf.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlyingOf.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlyingOf.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlyingOf.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlyingOf.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "andUnderlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "andUnderlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "andUnderlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "andUnderlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "andUnderlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter holdings by status. If no state filter is given, only non-spent holdings are returned. If the state\n filter includes a spent state (i.e. `Baked`, `Deflated`, or `Spent`), the spent holdings are included.",
          "in" : "query",
          "name" : "state",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "Spent", "Unassigned", "Unspent", "Escrowed", "Baked", "Deflated" ]
            }
          }
        }, {
          "description" : "Include product data in response.",
          "in" : "query",
          "name" : "includeProductData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include product item data in response.",
          "in" : "query",
          "name" : "includeProductItemData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter holdings by the account id of the issuer.",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include issuer data in response.",
          "in" : "query",
          "name" : "includeIssuerData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter by product item attributes if possible.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references: [MetadataEntityRefType.PRODUCT], [MetadataEntityRefType.ACCOUNT],\n [MetadataEntityRefType.PRODUCT_ITEM], ( and [MetadataEntityRefType.BAKED_HOLDING]\n for endpoints that return [HoldingState.Baked] holdings )",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields when they are grouped by them:\n\n * `accountId`\n * `amount`\n * `unassignedAmount`\n * `assignedAmount`\n * `escrowAmount`\n * `issuerAmount`\n * `productId` by product id\n * `productItemId` by product item id\n * `productItemAttribute.xxx` by product item attribute, where xxx is an attribute name.\n * `metadata.xxx` where `xxx` is a metadata reference. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only holdings that were issued (and not spent) in the matching blocks numbers.\n The parameter can be a range (eg 1234..5678) to return all holdings that were issued (and not spent)\n in the block range.\n If the parameter is a single block number, the system will replace it with the range `..=blockNumber` so the holdings\n returned are a snapshot of the holdings that were active holdings upto (and including) the given blockNumber.\n\n Default when not present is to return all active holdings up to the current block.",
          "in" : "query",
          "name" : "block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only holdings that were issued (and not spent) in the matching time range.\n The parameter can be a range (eg 20240101T000000..) to return all holdings that were issued in the timestamp range.\n If the parameter is a single timestamp, the system will replace it with the range `..timestamp` so the holdings\n returned are a snapshot of the active holdings at the timestamp.\n\n Default when not present is to return all active holdings up to the current time.",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter by index using ranges (ex: 3..7) and individual values (ex: 1,5,6). Combinations are also possible (ex: 1..5,8,12). A Not (!) logic is not accepted.",
          "in" : "query",
          "name" : "index",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include information about underlying holdings in the result. The underlying amounts can be grouped by different\n properties:\n\n * `underlyingHolding`: Return individual underlying holdings.\n * `underlyingProduct`: Return total underlying amounts by product.\n * `underlyingProductItem`: Return total underlying amounts per distinct underlying product item.\n * `underlyingAttribute.<name>`: Return total amounts grouped by attribute value of the underlying product item.\n * `underlyingMetadata.<issuer>:<name>`: Return total amounts grouped by (indexed) metadata value of the underlying product item.\n\n If `includeUnderlying` is absent, no results for underlying holdings are returned.\n If `includeUnderlying` is present, the results are always grouped by `underlyingProduct`.",
          "in" : "query",
          "name" : "includeUnderlyingData",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Each entry must be one of:\n- `productItem`: group results by holding's product item (and return full `productItem` data in the response);\n- `product`: group results by holding product id.;\n- `attribute.<name>`: group by an attribute value of the holding's product item. The attribute's value is returned in `attributes`;\n- `metadata.<issuerId>:<name>`/`metadata.<tag>`: group by a holding's product item metadata value. The metadata value is returned in the `metadata` field of the response.\n- `underlyingHolding`: group results by underlying baked holding (and return full `underlying.holding` data in the response);\n- `underlyingProductItem`: group results by underlying's product item (and return full `underlying.productItem` data in the response);\n- `underlyingProduct`: group results by underlying's product id.;\n- `underlyingAttribute.<name>`: group by an attribute value of the underlying's product item. The attribute's value is returned in `underlying.attributes`;\n- `underlyingMetadata.<issuerId>:<name>`/`metadata.<tag>`: group by a underlying's product item metadata value. The metadata value is returned in the `underlying.metadata` field of the response.\n\nThe order in which the entries are specified determines the order of the results. The endpoint will always group by holding product and underlying product, adding those to the group by parameter will only change the order of results.",
          "in" : "query",
          "name" : "groupBy",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return baked holdings with a matching 'spent-in' block.",
          "in" : "query",
          "name" : "bakedInBlock",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return baked holdings with a matching 'spent-in' timestamp.",
          "in" : "query",
          "name" : "bakedInTimestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Depth of the underlyings. `0` will return underlyings of items held directly by the account, `1` will\n             return underlyings of the items that were underlying of the items held by the account, etc...",
          "in" : "query",
          "name" : "depth",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseUnderlyingHoldingData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List underlying information.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/issuer/{issuerId}" : {
      "get" : {
        "description" : "Get issuer detail.\n Returns detailed information for a given issuer.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetIssuer`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerId` | Assigned by the issuer. |\n",
        "operationId" : "getIssuer",
        "parameters" : [ {
          "description" : "The unique id for the issuer to query.",
          "in" : "path",
          "name" : "issuerId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IssuerData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get issuer detail.",
        "tags" : [ "Product inventory" ]
      }
    },
    "/api/pub/issuers" : {
      "get" : {
        "description" : "List issuers.\n List information about Product issuers on the system.\n#### Endpoint Permission\nAlways permitted. The response contains issuers that permit the `GetIssuer` endpoint type for the authenticated user.",
        "operationId" : "listIssuers",
        "parameters" : [ {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseIssuerData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List issuers.",
        "tags" : [ "Product inventory" ]
      }
    },
    "/api/pub/key/{accessKeyId}" : {
      "get" : {
        "description" : "Get access key details.\n List accessible accounts and permissions for a given access key and user account id combination.\n#### Endpoint Permission\nThis endpoint is implicitly permitted for the authenticated access key\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accessKeyId` | Only the authenticated access key is permitted. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "getAccessKeyDetails",
        "parameters" : [ {
          "description" : "The access key id to query.",
          "in" : "path",
          "name" : "accessKeyId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit details returned to selected user account IDs.",
          "in" : "query",
          "name" : "userAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Limit details returned to selected request account IDs.",
          "in" : "query",
          "name" : "requestAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Include extra indexed and non-indeed metadata in the response. Supported entity references: [MetadataEntityRefType.ACCOUNT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AccessKeyDetails"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get access key details.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/key/{accessKeyId}/accounts" : {
      "get" : {
        "description" : "List accessible user accounts.\n List the user accounts that can be accessed by an access key.\n#### Endpoint Permission\nThis endpoint is implicitly permitted for the authenticated access key\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accessKeyId` | Only the authenticated access key is permitted. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listAccessibleUserAccounts",
        "parameters" : [ {
          "description" : "The access key ID to query for.",
          "in" : "path",
          "name" : "accessKeyId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If set, filter user accounts to a specific set.",
          "in" : "query",
          "name" : "userAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If set, return only entries with the given account access type.",
          "in" : "query",
          "name" : "accessType",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "FULL", "PRIMARY", "SECONDARY", "REVOKED" ]
            }
          }
        }, {
          "description" : "If set, only include accounts that are a member of a visible account group that matches the given metadata criteria.<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references: [MetadataEntityRefType.ACCOUNT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAccessibleUserAccountData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List accessible user accounts.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/listAccounts" : {
      "get" : {
        "description" : "List accounts.\n List accounts matching the given criteria. At least ONE reference to an account group must be provided via\n the `memberOfAllOf` or `memberOfAnyOf` parameter.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListAccounts`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `memberOfAllOf` | Assigned by an account permits listing members of account groups owned by the account. |\n| `memberOfAnyOf` | Assigned by an account permits listing members of account groups owned by the account. |\n| `memberOfNoneOf` | Assigned by an account permits listing members of account groups owned by the account. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listAccounts",
        "parameters" : [ {
          "description" : "Filter by account ids",
          "in" : "query",
          "name" : "accountIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter accounts that are members of all these account groups",
          "in" : "query",
          "name" : "memberOfAllOf",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter accounts that are members of at least one of these account groups",
          "in" : "query",
          "name" : "memberOfAnyOf",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter accounts that are not members of any of these account groups",
          "in" : "query",
          "name" : "memberOfNoneOf",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.ACCOUNT]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indeed metadata in the response. Supported entity references: [MetadataEntityRefType.ACCOUNT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted on any of these fields:\n * `id`\n * `metadata.xxx` where `xxx` is a metadata reference. Supported entity references: [MetadataEntityRefType.ACCOUNT]\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAccountData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List accounts.",
        "tags" : [ "Access" ]
      }
    },
    "/api/pub/notifications" : {
      "get" : {
        "description" : "List notifications.\n\n Retrieve the transaction notifications that were sent. Notifications are always returned in an ascending block order.\n\n NOTE: this endpoint will only return transaction notifications for successful transaction requests. Notifications\n for pending transactions, tenant administration and transaction failures can not be retrieved with this endpoint.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `Info`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accessKeyId` | Only the authenticated access key is permitted. |\n",
        "operationId" : "listNotifications",
        "parameters" : [ {
          "description" : "The access key to query notifications for. This must be the authenticated access key.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "accessKeyId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "If specified, return only notifications for the given block numbers.\n Can be a range (ex: 1..5), a list of values (ex: 2,3,6) or a combination, negation is also possible (ex: !5).",
          "in" : "query",
          "name" : "block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only notifications for the given timestamp range.\n Can be a range (ex: 2023-07-01T01:00:00.000Z..2023-09-01T01:00:00.000Z),\n a list of exact values (ex: 2023-09-01T01:00:00.000Z,2023-09-01T02:00:00.000Z),\n or a combination, negation is also possible (ex: !2023-09-01T01:00:00.000Z).",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseCoreNotification"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List notifications.",
        "tags" : [ "System info" ]
      }
    },
    "/api/pub/product/{productId}" : {
      "get" : {
        "description" : "Get product detail.\n Get detailed information for a given product.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetProduct`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `productId` | Assigned by the issuer of the product. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "getProduct",
        "parameters" : [ {
          "description" : "The unique identifier of the product (`block:index`)",
          "in" : "path",
          "name" : "productId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.PRODUCT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "uniqueItems" : true
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ProductData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get product detail.",
        "tags" : [ "Product inventory" ]
      }
    },
    "/api/pub/product/{productId}/attributes" : {
      "get" : {
        "deprecated" : true,
        "description" : "This endpoint should no longer be used: instead use /queryBalances\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListProductItems`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `productId` | Assigned by the issuer of the product. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listProductItemAttributeValues",
        "parameters" : [ {
          "in" : "path",
          "name" : "productId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "List by the specified products. (Required if issuer is not set).",
          "in" : "query",
          "name" : "productIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List by the products issued by this account. (Required if productIds is not set).",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "List of attribute names to return values for. If multiple attributes are specified, the function will return\n values for each unique combination of values for the given attributes.\n Doesn't support attributes of type [LATLON], [DOCUMENT], [BYTESTRING], [MAP], [PRODUCT], [TRANSACTION_TYPE].",
          "in" : "query",
          "name" : "axes",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter results (and balances) by current holdings for the account.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter results (and balances) by current holdings controller account id.",
          "in" : "query",
          "name" : "controllerAccountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include balances for each combination of attributes.",
          "in" : "query",
          "name" : "includeBalances",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter product items by attributes.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "andUnderlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "andUnderlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "andUnderlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "andUnderlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "andUnderlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Allows sorting by any of the attributes in the axes parameter (and only those).\n The default sort order is ascending for all the axes.\n To sort in descending order, prefix the axis name with `-`, e.g. `-myAttribute`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "in" : "query",
          "name" : "isUnassigned",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAttributeValuesBalanceData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "This endpoint should no longer be used: instead use /queryBalances",
        "tags" : [ "Product inventory" ]
      }
    },
    "/api/pub/productitem/{productItemId}" : {
      "get" : {
        "description" : "Get product item detail.\n Retrieve detailed information for a particular product item.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetProductItem`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `productItemId` | Assigned by the issuer of the product item's product. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "getProductItem",
        "parameters" : [ {
          "description" : "The unique identifier of the product item (`block:index`)",
          "in" : "path",
          "name" : "productItemId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "uniqueItems" : true
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ProductItemResponse"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get product item detail.",
        "tags" : [ "Product inventory" ]
      }
    },
    "/api/pub/productitem/{productItemId}/holdings" : {
      "get" : {
        "description" : "Get product item holdings.\n Provide a break-down of the current and baked holdings of a product item.\n The list returned is sorted by index if the product item is non-inflatable.\n This query does not populate the top level response fields issuer, product, productItem or bakedIntoProductItem.\n The escrowId and controllerAccountId fields are only populated for escrowed holdings.\n This query does not support metadata.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListProductItemHoldings`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `productItemId` | Assigned by the issuer of the product item's product. |\n",
        "operationId" : "listProductItemHoldings",
        "parameters" : [ {
          "description" : "The unique identifier of the product item (`block:index`)",
          "in" : "path",
          "name" : "productItemId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Sort criteria for this request.",
          "examples" : {
            "amount" : {
              "description" : "amount",
              "value" : "amount"
            },
            "descending" : {
              "description" : "descending",
              "value" : "-amount"
            },
            "id" : {
              "description" : "id",
              "value" : "id"
            },
            "product item attribute" : {
              "description" : "product item attribute",
              "value" : "productItemAttribute.$nameOfTheAttribute"
            },
            "product item id" : {
              "description" : "product item id",
              "value" : "productItemId"
            },
            "productId id" : {
              "description" : "productId id",
              "value" : "productId"
            },
            "quantity" : {
              "description" : "quantity",
              "value" : "quantity"
            }
          },
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseHoldingData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get product item holdings.",
        "tags" : [ "Product inventory" ]
      }
    },
    "/api/pub/productitem/{productItemId}/underlying" : {
      "get" : {
        "description" : "Get underlying holdings.\n If a product item has been created by 'baking' other holdings, this method will list the underlying holdings\n of a product item. Each holding will refer to a product item in the underlying product.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListProductItemUnderlyingHoldings`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `productItemId` | Assigned by the issuer of the product item's product. |\n",
        "operationId" : "listProductItemUnderlyingHoldings",
        "parameters" : [ {
          "description" : "The unique identifier of the product item (`block:index`)",
          "in" : "path",
          "name" : "productItemId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Sort criteria for this request.",
          "examples" : {
            "amount" : {
              "description" : "amount",
              "value" : "amount"
            },
            "descending" : {
              "description" : "descending",
              "value" : "-amount"
            },
            "id" : {
              "description" : "id",
              "value" : "id"
            },
            "product item attribute" : {
              "description" : "product item attribute",
              "value" : "productItemAttribute.$nameOfTheAttribute"
            },
            "product item id" : {
              "description" : "product item id",
              "value" : "productItemId"
            },
            "productId id" : {
              "description" : "productId id",
              "value" : "productId"
            },
            "quantity" : {
              "description" : "quantity",
              "value" : "quantity"
            }
          },
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseHoldingData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get underlying holdings.",
        "tags" : [ "Product inventory" ]
      }
    },
    "/api/pub/productitems" : {
      "get" : {
        "description" : "List product items.\n Returns product items that match the given criteria. The number of results are limited and paged by block number.\n This query does not populate the top level response fields accountId, issuer, productId, product or bakedAmount.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListProductItems`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `productId` | Assigned by the issuer of the product. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listProductItems",
        "parameters" : [ {
          "description" : "Product to list items for.",
          "in" : "query",
          "name" : "productId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "200:0"
          }
        }, {
          "description" : "`true` to find only inflatable items, `false` to find only uninflatable items.",
          "in" : "query",
          "name" : "canInflate",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "`true` to find only fractionalizable items, `false` to find only non-fractionalizable items.",
          "in" : "query",
          "name" : "canFractionalize",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter by attributes if possible.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "andUnderlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "andUnderlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "andUnderlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "andUnderlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "andUnderlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM], [MetadataEntityRefType.ACCOUNT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Include information about underlying holdings in the result. The underlying amounts can be grouped by different\n properties:\n\n * `underlyingHolding`: Return individual underlying holdings.\n * `underlyingProduct`: Return total underlying amounts by product.\n * `underlyingProductItem`: Return total underlying amounts per distinct underlying product item.\n * `underlyingAttribute.<name>`: Return total amounts grouped by attribute value of the underlying product item.\n * `underlyingMetadata.<issuer>:<name>`: Return total amounts grouped by (indexed) metadata value of the underlying product item.\n\n If `includeUnderlying` is absent, no results for underlying holdings are returned.\n If `includeUnderlying` is present, the results are always grouped by `underlyingProduct`.",
          "in" : "query",
          "name" : "includeUnderlyingData",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `id`, the product item Id\n * `unassignedAmount`\n * `assignedAmount`\n * `issuerAmount`\n * `escrowAmount`\n * `productItemAttribute.xxx`, where `xxx` is an attribute name\n * `metadata.xxx`, where `xxx` is a metadata reference. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "in" : "query",
          "name" : "isUnassigned",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseBalanceData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List product items.",
        "tags" : [ "Product inventory" ]
      }
    },
    "/api/pub/queryBalances" : {
      "get" : {
        "description" : "List product item attribute values.\n For each of the product items that match the given criteria, all existing combinations of values of the given attribute references\n are returned. If includeBalances is set to `true`, the sum of the balances for each matching product item are returned.\n axes or includeBalances=true are required.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `QueryBalances`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountId` | Assigned by the account when filtering by account |\n| `productIds` | Assigned by the issuer of the product permits all accounts for that product |\n| `issuerId` | Assigned by an issuer permits all accounts for all products of the issuer |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listBalanceByAttributes",
        "parameters" : [ {
          "description" : "List by the specified products. (Required if issuer is not set).",
          "in" : "query",
          "name" : "productIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List by the products issued by this account. (Required if productIds is not set).",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "List of attribute names to return values for. If multiple attributes are specified, the function will return\n values for each unique combination of values for the given attributes.\n Doesn't support attributes of type [LATLON], [DOCUMENT], [BYTESTRING], [MAP], [PRODUCT], [TRANSACTION_TYPE].",
          "in" : "query",
          "name" : "axes",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter results (and balances) by current holdings for the account.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter results (and balances) by current holdings controller account id.",
          "in" : "query",
          "name" : "controllerAccountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include balances for each combination of attributes.",
          "in" : "query",
          "name" : "includeBalances",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter product items by attributes.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "underlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "underlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "underlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "underlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "underlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "underlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match if no underlying holdings match the criteria.",
          "in" : "query",
          "name" : "andUnderlying.not",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Match product items that have underlying from any of the products of the given issuer(s).",
          "in" : "query",
          "name" : "andUnderlying.issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that have at least one of the given products.",
          "in" : "query",
          "name" : "andUnderlying.productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Match (underlying) product items that match the given attribute criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Match (underlying) product items where that match the given metadata criteria. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "andUnderlying.metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching block number.",
          "in" : "query",
          "name" : "andUnderlying.block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, match product items that have at least one bake transaction with a matching timestamp.",
          "in" : "query",
          "name" : "andUnderlying.timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Allows sorting by any of the attributes in the axes parameter (and only those).\n The default sort order is ascending for all the axes.\n To sort in descending order, prefix the axis name with `-`, e.g. `-myAttribute`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "in" : "query",
          "name" : "isUnassigned",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAttributeValuesBalanceData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List product item attribute values.",
        "tags" : [ "Product inventory" ]
      }
    },
    "/api/pub/queryProducts" : {
      "get" : {
        "description" : "List products.\n Returns basic information for products that match the given criteria.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListProducts`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `issuerId` | Assigned by the issuer allows listing the issuer's products. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listProducts",
        "parameters" : [ {
          "description" : "Set to `true` to include deleted products in the result.",
          "in" : "query",
          "name" : "includeDeleted",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "in" : "query",
          "name" : "productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter products by the account id of the issuer.",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Filter products by code.",
          "in" : "query",
          "name" : "code",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Match products with given attributes.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.PRODUCT]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.PRODUCT], [MetadataEntityRefType.ACCOUNT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `id`\n * `issuerId`\n * `code`\n * `name`\n * `metadata.xxx` where `xxx` is a metadata reference. Supported entity references: [MetadataEntityRefType.PRODUCT]\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseProductData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List products.",
        "tags" : [ "Product inventory" ]
      }
    },
    "/api/pub/security-group/{securityGroupId}" : {
      "get" : {
        "description" : "Get Security Group details.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetSecurityGroup`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `securityGroupId` | Assigned by an account permits any security group owned by the account. |\n",
        "operationId" : "getSecurityGroupDetails",
        "parameters" : [ {
          "in" : "path",
          "name" : "securityGroupId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SecurityGroupData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get Security Group details.",
        "tags" : [ "Access" ]
      }
    },
    "/api/pub/security-groups" : {
      "get" : {
        "description" : "List Security Groups.\n Returns Security Groups that match the given criteria.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListSecurityGroups`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `ownerIds` | Assigned by an account permits any security group owned by the account. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listSecurityGroups",
        "parameters" : [ {
          "description" : "List groups that have the given owner(s).",
          "in" : "query",
          "name" : "ownerIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List groups that match the given attributes.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Set to `true` to include deleted account groups in the result.",
          "in" : "query",
          "name" : "includeDeleted",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter 'assignedTo...' criteria to only assignments made by these accounts.",
          "in" : "query",
          "name" : "assignedBy",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List Security Groups that have been assigned to any of the given Account Groups.",
          "in" : "query",
          "name" : "assignedToAnyOfAccountGroups",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List Security Groups that have been assigned to none of the given Account Groups.",
          "in" : "query",
          "name" : "assignedToNoneOfAccountGroups",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List Security Groups that have been assigned to any of the given accounts.\n Note that this only queries for accounts that have been directly assigned to the group, not accounts that\n inherit the group from account groups that they are a member of. To query all the security groups that apply to\n an account, use the [io.trovio.core.api.CoreAccessApi.listAssignedSecurityGroups] method.",
          "in" : "query",
          "name" : "assignedToAnyOfAccounts",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List Security Groups that have not been assigned to any of the given accounts.\n Note that this only queries for accounts that have been directly assigned to the group, not accounts that\n inherit the group from account groups that they are a member of. To query all the security groups that apply to\n an account, use the [io.trovio.core.api.CoreAccessApi.listAssignedSecurityGroups] method.",
          "in" : "query",
          "name" : "assignedToNoneOfAccounts",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List groups that match the given metadata. Supported metadata refs: [MetadataEntityRefType.SECURITY_GROUP]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.SECURITY_GROUP]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `id`\n * `ownerId`\n * `securityGroupAttribute.xxx` where `xxx` is an attribute name\n\n To sort in descending order, prefix the field name with `-`, e.g. `-ownerId`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseSecurityGroupData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List Security Groups.",
        "tags" : [ "Access" ]
      }
    },
    "/api/pub/tenant/" : {
      "get" : {
        "description" : "Get all configured tenants that match the query criteria\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `IdentityTenantData`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `ownerId` | Assigned by an account permits retrieving all tenants owned by the account. |\n| *issuer admin* | Assigned by the Issuer Admin account to retrieve any tenant's details. |\n",
        "operationId" : "listTenants",
        "parameters" : [ {
          "description" : "Tenant owner account.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "ownerId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "Internal ID of an identity tenant",
          "in" : "query",
          "name" : "tenantId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include deleted tenants in response",
          "in" : "query",
          "name" : "includeDeleted",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseIdentityTenantData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get all configured tenants that match the query criteria",
        "tags" : [ "Tenant info functions" ]
      }
    },
    "/api/pub/tenant/accessKey/{tenantId}" : {
      "get" : {
        "description" : "Get access key for the specified tenant.\n Retrieve user account data for the specified tenant and account ID or subject ID.\n An account ID and/or subject ID must be provided in the request query parameters.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `IdentityUserData`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `ownerId` | Assigned by the tenant's owner permits retrieving the tenant's users. |\n",
        "operationId" : "getAccessKey",
        "parameters" : [ {
          "description" : "Tenant for which to search for the access key.",
          "in" : "path",
          "name" : "tenantId",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Tenant owner account.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "ownerId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "Account ID to search for. An accountId or a subjectId must be specified.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Subject ID to search for. An accountId or a subjectId must be specified.",
          "in" : "query",
          "name" : "subjectId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IdentityUserData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get access key for the specified tenant.",
        "tags" : [ "Tenant info functions" ]
      }
    },
    "/api/pub/tenant/accessKeys" : {
      "get" : {
        "description" : "Lists access keys for the specified tenant.\n Retrieve all users' account data for the specified tenant. Response is paginated.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `IdentityUserData`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `ownerId` | Assigned by the tenant's owner permits listing the tenant's users. |\n",
        "operationId" : "listAccessKeys",
        "parameters" : [ {
          "description" : "Tenant owner account.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "ownerId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "Internal ID of an identity tenant.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "tenantId",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseIdentityUserData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Lists access keys for the specified tenant.",
        "tags" : [ "Tenant info functions" ]
      }
    },
    "/api/pub/tenant/system-state-updates" : {
      "get" : {
        "description" : "List historical or planned system state updates.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListSystemStateUpdates`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| *issuer admin* | Assigned by the Issuer Admin account to list system state updates. |\n",
        "operationId" : "listSystemStateUpdates",
        "parameters" : [ {
          "description" : "Filter for specific state IDs.",
          "in" : "query",
          "name" : "id",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter for state update start times.",
          "in" : "query",
          "name" : "startTime",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter for states.",
          "in" : "query",
          "name" : "state",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "Public", "Transparent", "Private", "Suspended", "Administration", "Maintenance", "Reconciliation" ]
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n\n * `id`\n * `startTime`\n * `state`\n * `endTime`\n\n To sort in descending order, prefix the field name with `-`, e.g. `-startTime`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseSystemStateUpdateData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List historical or planned system state updates.",
        "tags" : [ "Tenant info functions" ]
      }
    },
    "/api/pub/tenant/{tenantId}" : {
      "get" : {
        "description" : "Get tenant details for a specific tenant ID\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `IdentityTenantData`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `ownerId` | Assigned by an account permits retrieving all tenants owned by the account. |\n| *issuer admin* | Assigned by the Issuer Admin account to retrieve any tenant's details. |\n",
        "operationId" : "getTenant",
        "parameters" : [ {
          "description" : "ID of the tenant",
          "in" : "path",
          "name" : "tenantId",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Tenant owner account.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "ownerId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include deleted tenants in response",
          "in" : "query",
          "name" : "includeDeleted",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IdentityTenantData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get tenant details for a specific tenant ID",
        "tags" : [ "Tenant info functions" ]
      }
    },
    "/api/pub/tenant/{tenantId}/history" : {
      "get" : {
        "description" : "Get request history for a specific tenant.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `IdentityTenantHistory`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `ownerId` | Assigned by an account permits retrieving all history of tenants owned by the account. |\n",
        "operationId" : "listTenantHistory",
        "parameters" : [ {
          "description" : "Tenant ID",
          "in" : "path",
          "name" : "tenantId",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Tenant owner account.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "ownerId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Request type",
          "in" : "query",
          "name" : "requestType",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `timestamp`\n\n To sort in descending order, prefix the field name with `-`, e.g. `-timestamp`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseWalletTransactionData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get request history for a specific tenant.",
        "tags" : [ "Tenant info functions" ]
      }
    },
    "/api/pub/tenant/{tenantId}/idp" : {
      "get" : {
        "description" : "Get identity providers filtered by criteria\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `IdentityProviderData`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `ownerId` | Assigned by an account permits retrieving all identity providers owned by the account. |\n",
        "operationId" : "listIdentityProviders",
        "parameters" : [ {
          "description" : "ID of the tenant where the identity providers are listed",
          "in" : "path",
          "name" : "tenantId",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Owner of the tenant.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "ownerId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "Identity provider id",
          "in" : "query",
          "name" : "providerId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Identity provider issuer URI",
          "in" : "query",
          "name" : "issuerUri",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Client id of the identity provider",
          "in" : "query",
          "name" : "clientId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Application id(s) of the identity provider. In many setups this value is the same as the client id.",
          "in" : "query",
          "name" : "applicationId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseIdentityProviderData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get identity providers filtered by criteria",
        "tags" : [ "Tenant info functions" ]
      }
    },
    "/api/pub/tenant/{tenantId}/idp/{providerId}" : {
      "get" : {
        "description" : "Get identity provider by its ID.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `IdentityProviderData`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `ownerId` | Assigned by an account permits retrieving all identity providers owned by the account. |\n",
        "operationId" : "getIdentityProvider",
        "parameters" : [ {
          "in" : "path",
          "name" : "tenantId",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Identity provider ID.",
          "in" : "path",
          "name" : "providerId",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Owner of the tenant.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "ownerId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "Identity provider issuer URI",
          "in" : "query",
          "name" : "issuerUri",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Client id of the identity provider",
          "in" : "query",
          "name" : "clientId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Application id(s) of the identity provider. In many setups this value is the same as the client id.",
          "in" : "query",
          "name" : "applicationId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IdentityProviderData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get identity provider by its ID.",
        "tags" : [ "Tenant info functions" ]
      }
    },
    "/api/pub/transaction/{blockAndIndex}" : {
      "get" : {
        "description" : "Get transaction detail.\n Retrieve detail of a transaction given its block number and index.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetTransaction`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| *issuer admin* | Assigned by the Issuer Admin account permits all transactions. |\n| *account* | Assigned by an account permits all transactions that involve that account. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "getTransactionDetail",
        "parameters" : [ {
          "description" : "Block and index for the transaction.",
          "in" : "path",
          "name" : "blockAndIndex",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter transaction holding operations by accountId if specified.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include holding data in response. Defaults to `true`.",
          "in" : "query",
          "name" : "includeHoldings",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include product data in response.",
          "in" : "query",
          "name" : "includeProductData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include product item data in response.",
          "in" : "query",
          "name" : "includeProductItemData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include issuer data in response.",
          "in" : "query",
          "name" : "includeIssuerData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter by product item attributes.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "productItemAttributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references:\n - [MetadataEntityRefType.TRANSACTION]\n - [MetadataEntityRefType.PRODUCT_ITEM]\n - [MetadataEntityRefType.ACCESS_KEY]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TransactionData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get transaction detail.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/transaction/{blockAndIndex}/proof" : {
      "get" : {
        "description" : "Create a proof-of-transaction for a particular transaction.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetTransactionProof`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| *issuer admin* | Assigned by the Issuer Admin account permits all transactions. |\n| *account* | Assigned by an account permits all transactions that involve that account. |\n",
        "operationId" : "getTransactionProof",
        "parameters" : [ {
          "in" : "path",
          "name" : "blockAndIndex",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include details of issued holdings? This would constitute a proof of payment.",
          "in" : "query",
          "name" : "includeIssuedHoldings",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include details of baked holdings? This would constitute a proof of baking.",
          "in" : "query",
          "name" : "includeBakedHoldings",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include request signature details and public keys?",
          "in" : "query",
          "name" : "includeRequestSignatures",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include request details?",
          "in" : "query",
          "name" : "includeRequest",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include product and product item information in the response?",
          "in" : "query",
          "name" : "includeInfo",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TransactionProofContent"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Create a proof-of-transaction for a particular transaction.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/transactionById/{transactionId}" : {
      "get" : {
        "description" : "Get transaction detail.\n Retrieve detail of a transaction given its Transaction ID (i.e., hash).\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `GetTransaction`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| *issuer admin* | Assigned by the Issuer Admin account permits all transactions. |\n| *account* | Assigned by an account permits all transactions that involve that account. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "getTransactionDetailById",
        "parameters" : [ {
          "description" : "transaction hash.",
          "in" : "path",
          "name" : "transactionId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Filter transaction holding operations by accountId if specified.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include holding data in response. Defaults to `true`.",
          "in" : "query",
          "name" : "includeHoldings",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include product data in response.",
          "in" : "query",
          "name" : "includeProductData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include product item data in response.",
          "in" : "query",
          "name" : "includeProductItemData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include issuer data in response.",
          "in" : "query",
          "name" : "includeIssuerData",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Filter by product item attributes.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "productItemAttributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references:\n - [MetadataEntityRefType.TRANSACTION]\n - [MetadataEntityRefType.PRODUCT_ITEM]\n - [MetadataEntityRefType.ACCESS_KEY]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TransactionData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get transaction detail.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/transactions" : {
      "get" : {
        "description" : "List transactions.\n Returns transactions that match the given criteria. Results are limited and can be paged using the blockNumber.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListTransactions`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountId` | Assigned by an account permits all transactions that involve the account (as request, sender or recipient). |\n| `requestAccountId` | Assigned by an account permits all transaction requested on behalf of the account. |\n| `signedByUserAccountId` | Assigned by an account permits all transactions initiated or approved by that account. |\n| `productId` | Assigned by the issuer of a product permits all transactions that involve that product. |\n| `issuerId` | Assigned by an issuer permits all transactions that involve that issuer's products. |\n| *issuer admin* | Assigned by the Issuer Admin account permits all transactions. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listTransactions",
        "parameters" : [ {
          "description" : "Return only transactions for the given account. This account may be the requestor of the transaction, the sender or the recipient.",
          "in" : "query",
          "name" : "accountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Request account of the transaction.",
          "in" : "query",
          "name" : "requestAccountId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Account that is affected by the transaction.",
          "in" : "query",
          "name" : "counterparty",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Type of transaction request. The value can be a range (of the tag number of the request type), a list of exact values,\n and/or possibly a negation.",
          "in" : "query",
          "name" : "transactionType",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only transactions that match the given ids.",
          "in" : "query",
          "name" : "transaction",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only transactions for the given product.",
          "in" : "query",
          "name" : "productId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, return only transactions for the given product issuer.",
          "in" : "query",
          "name" : "issuerId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only transactions for the given product item.",
          "in" : "query",
          "name" : "productItemId",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only transactions that spent/issued holdings where the product item matches the given criteria.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "productItemAttributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "If specified, return only transactions restricted to these block numbers.\n Can be a range (ex: 1..5), a list of values (ex: 2,3,6) or a combination, negation is also possible (ex: !5).",
          "in" : "query",
          "name" : "block",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only transactions restricted to these timestamps.\n Can be a range (ex: 2023-07-01T01:00:00.000Z..2023-09-01T01:00:00.000Z), a list of exact values\n (ex: 2023-09-01T01:00:00.000Z,2023-09-01T02:00:00.000Z) or a combination, negation is also possible (ex: !2023-09-01T01:00:00.000Z).",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only transactions where the transaction attributes match these criteria.\n The attribute criteria can only match attributes that have been configured as indexed attributes.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter by indexed metadata. Supported entity references: [MetadataEntityRefType.TRANSACTION], [MetadataEntityRefType.TRANSACTION_ID], [MetadataEntityRefType.PRODUCT_ITEM]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Filter counter party by [MetadataEntityRefType.ACCOUNT]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "counterpartyMetadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.TRANSACTION], [MetadataEntityRefType.TRANSACTION_ID], [MetadataEntityRefType.PRODUCT_ITEM], [MetadataEntityRefType.ACCOUNT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Include signatory data in response.",
          "in" : "query",
          "name" : "includeSignatories",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "If specified, return transactions that were signed by one of the given user account ids.",
          "in" : "query",
          "name" : "signedByUserAccountId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If specified, and `signedByUserAccountId` is specified, transactions are returned where one of the matching\n user accounts has a matching role.",
          "in" : "query",
          "name" : "signedByAccountRole",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "SINGLE", "INITIATOR", "APPROVER" ]
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results are always sorted by transaction block and index in ascending order.\n To return transactions in descending time order, set the sort parameter to `-id`.",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseTransactionData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List transactions.",
        "tags" : [ "Account" ]
      }
    },
    "/api/pub/visible-account-groups" : {
      "get" : {
        "description" : "List Visible Account Groups.\n Returns account groups where the request account is a member (and the Account Group has been marked as `visibleToMembers`\n by the owner) or where the request account is a member of a separate Account Group that is referenced in the\n `visibleToMembersOf` property of the result account group.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListVisibleAccountGroups`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accountId` | Assigned by an account permits retrieving the visible account groups for that account. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listVisibleAccountGroups",
        "parameters" : [ {
          "in" : "query",
          "name" : "accountId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "List groups by id.",
          "in" : "query",
          "name" : "accountGroupIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List groups that have the given owner(s).",
          "in" : "query",
          "name" : "ownerIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List groups that contain any of the given accounts.",
          "in" : "query",
          "name" : "hasAnyOf",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List groups that contain none of the given accounts.",
          "in" : "query",
          "name" : "hasNoneOf",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "List groups that match the given attributes.<br/>This parameter is a map where each key is the attribute name and each value is the filter expression for that attribute. The map syntax is _parameter_[_attributeName_]=_filter_ or after URL encoding: _parameter_%5B_attributeName_%5D=_filter_. Can filter by multiple attributes using the same schema for example: attributes[color]=Blue,attributes[age]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "attributeName" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "attributeName" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "attributeName" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "attributeName" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "attributeName" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "attributeName" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "attributeName" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "attributeName" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "attributeName" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "List groups that match the given metadata. Supported metadata refs: [MetadataEntityRefType.ACCOUNT_GROUP]<br/>This parameter is a map where each key is the metadata reference (_tag_ or _issuerId_:_metadataName_) and each value is the filter expression for that metadata value. The map syntax is _parameter_[_metadataRef_]=_filter_ or after URL encoding: _parameter_%5B_metadataId_%5D=_filter_. Can filter by multiple metadata using the same schema for example: metadata[0x1234567890123456:color]=Blue,metadata[110]=15..30",
          "examples" : {
            "--" : { },
            "Between" : {
              "description" : "Equals or greater than 10 and smaller than 100",
              "value" : {
                "metadataKey" : "10..100"
              }
            },
            "Contains" : {
              "value" : {
                "metadataKey" : "*Blue*"
              }
            },
            "Different to" : {
              "value" : {
                "metadataKey" : "!Blue"
              }
            },
            "Ends with" : {
              "value" : {
                "metadataKey" : "*ue"
              }
            },
            "Equals to" : {
              "value" : {
                "metadataKey" : "Blue"
              }
            },
            "Equals to any of" : {
              "value" : {
                "metadataKey" : "Blue,Yellow"
              }
            },
            "Greater or equals than" : {
              "description" : "Equals or greater than 10",
              "value" : {
                "metadataKey" : "10.."
              }
            },
            "Smaller than" : {
              "description" : "Smaller than 10",
              "value" : {
                "metadataKey" : "..10"
              }
            },
            "Starts with" : {
              "value" : {
                "metadataKey" : "Bl*"
              }
            }
          },
          "explode" : true,
          "in" : "query",
          "name" : "metadata",
          "required" : false,
          "schema" : {
            "type" : "object",
            "additionalProperties" : true,
            "minProperties" : 1
          },
          "style" : "deepObject"
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response. Supported entity references: [MetadataEntityRefType.ACCOUNT_GROUP]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Set to `true` to include deleted account groups in the result.",
          "in" : "query",
          "name" : "includeDeleted",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields:\n * `id`\n * `ownerId`\n * `accountGroupAttribute.xxx` where `xxx` is an attribute name\n * `metadata.xxx` where `xxx` is a metadata reference\n\n To sort in descending order, prefix the field name with `-`, e.g. `-ownerId`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseAccountGroupData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List Visible Account Groups.",
        "tags" : [ "Access" ]
      }
    },
    "/api/status" : {
      "get" : {
        "description" : "Get server status.\n Returns status details for a node in the system. This endpoint is used by load balancers to determine a node's\n status before allowing it to accept connections. Downstream integrations may use this endpoint to monitor\n reachability of the environment.\n\n There is no authentication or endpoint permission required for this endpoint.",
        "operationId" : "getStatus",
        "responses" : {
          "200" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/WalletHostStatusData"
                }
              }
            },
            "description" : "Success"
          },
          "500" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/WalletHostStatusData"
                }
              }
            },
            "description" : "Internal server error. The system is not ready for use, detailed status codes are in the response."
          }
        },
        "security" : [ ],
        "summary" : "Get server status.",
        "tags" : [ "System info" ]
      }
    },
    "/api/tenant/accessKeys" : {
      "post" : {
        "description" : "Ensure access keys exist for OpenID subject IDs of a specific tenant.\n Accepts a CreateAccessKeysRequest request type.\n Queries access keys for all the provided subject IDs, generating new ones for subjects that do not have one yet.\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectTransactionId] | Referenced transaction does not match the hash of the encoded transaction data. |\n | [IncompleteTransactionRequest] | Additional signatures are required. |\n | [IncorrectSignatureType] | The signature type is not supported for the key type. |\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type. |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed). |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key. |\n | [IncorrectRequestMessage] | The request message type is invalid for this endpoint. |\n | [IncorrectSignatureOrder] | Duplicate signature. |",
        "operationId" : "ensureAccessKeys",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MintTransactionRequest"
              }
            }
          },
          "description" : "Encoded and signed [CreateAccessKeysRequest]",
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/IdentityUserData"
                  }
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Ensure access keys exist for OpenID subject IDs of a specific tenant.",
        "tags" : [ "Tenant admin functions" ]
      }
    },
    "/api/tenant/idp" : {
      "post" : {
        "description" : "Create, update or delete an identity provider.\n Accepts CreateIdentityProviderRequest, UpdateIdentityProviderRequest, DeleteIdentityProviderRequest request types.\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectTransactionId] | Referenced transaction does not match the hash of the encoded transaction data. |\n | [IncompleteTransactionRequest] | Additional signatures are required. |\n | [IncorrectSignatureType] | The signature type is not supported for the key type. |\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type. |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed). |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key. |\n | [IncorrectRequestMessage] | The request message type is invalid for this endpoint. |\n | [IncorrectSignatureOrder] | Duplicate signature. |",
        "operationId" : "identityProviderConfigRequest",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MintTransactionRequest"
              }
            }
          },
          "description" : "Encoded and signed [CreateIdentityProviderRequest], [UpdateIdentityProviderRequest], or [DeleteIdentityProviderRequest],",
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IdentityProviderData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Create, update or delete an identity provider.",
        "tags" : [ "Tenant admin functions" ]
      }
    },
    "/api/tenant/system-state" : {
      "post" : {
        "description" : "Update the system state.\n Accepts [UpdateSystemStateRequest] signed requests.\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectTransactionId] | Referenced transaction does not match the hash of the encoded transaction data. |\n | [IncompleteTransactionRequest] | Additional signatures are required. |\n | [IncorrectSignatureType] | The signature type is not supported for the key type. |\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type. |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed). |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key. |\n | [IncorrectRequestMessage] | The request message type is invalid for this endpoint. |\n | [IncorrectSignatureOrder] | Duplicate signature. |",
        "operationId" : "updateSystemStateRequest",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MintTransactionRequest"
              }
            }
          },
          "description" : "Encoded and signed [UpdateSystemStateRequest]",
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SystemStateData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Update the system state.",
        "tags" : [ "Tenant admin functions" ]
      }
    },
    "/api/tenant/tenant" : {
      "post" : {
        "description" : "Create, update or delete an identity tenant.\n\n Accepts CreateIdentityTenantRequest, UpdateIdentityTenantRequest, DeleteIdentityTenantRequest request types.\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectTransactionId] | Referenced transaction does not match the hash of the encoded transaction data. |\n | [IncompleteTransactionRequest] | Additional signatures are required. |\n | [IncorrectSignatureType] | The signature type is not supported for the key type. |\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type. |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed). |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key. |\n | [IncorrectRequestMessage] | The request message type is invalid for this endpoint. |\n | [IncorrectSignatureOrder] | Duplicate signature. |",
        "operationId" : "identityTenantConfigRequest",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MintTransactionRequest"
              }
            }
          },
          "description" : "Encoded and signed [CreateIdentityTenantRequest], [UpdateIdentityTenantRequest], or [DeleteIdentityTenantRequest],",
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IdentityTenantData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Create, update or delete an identity tenant.",
        "tags" : [ "Tenant admin functions" ]
      }
    },
    "/api/tx/async" : {
      "post" : {
        "description" : "Send a transaction request.\n The transaction request is validated and queued for processing. Validation errors will produce an immediate\n error response from this endpoint. Transaction responses (error or success) are returned as an asynchronous\n notification to the access keys that can operate on the account.\n\n #### Errors specific to the endpoint\n | Error | Cause |\n |:----|:----|\n | [NoPossibleApprovers] | No possible approvers can be found for the initiated transaction request |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed)|\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type |\n | [IncorrectSignatureType] | The signature type is not supported for the key type |\n | [IncompleteTransactionRequest] | The transaction request requires additional signatures |",
        "operationId" : "submitTransaction",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MintTransactionRequest"
              }
            }
          },
          "description" : "Valid transaction request with signature(s). To create this data, the transaction request details\n must be encoded using the Yabor binary encoding and subsequently signed.",
          "required" : true
        },
        "responses" : {
          "201" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PendingTransactionData"
                }
              }
            },
            "description" : "The transaction request requires more approval signatures and has been stored as a 'pending transaction' and possible approvers have been notified."
          },
          "202" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SubmitTransactionResponse"
                }
              }
            },
            "description" : "The transaction request was valid and has been queued for processing."
          },
          "208" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MintTransactionResponse"
                }
              }
            },
            "description" : "The transaction request was already processed. The result returned is the result of the previous processing."
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Send a transaction request.",
        "tags" : [ "Transaction request" ]
      }
    },
    "/api/tx/request" : {
      "post" : {
        "description" : "Send a transaction request and wait for response.\n This request is executed synchronously, the response is returned after the transaction has executed.\n\n #### Errors specific to the endpoint\n | Error | Cause |\n |:----|:----|\n | [NoPossibleApprovers] | No possible approvers can be found for the initiated transaction request |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed)|\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type |\n | [IncorrectSignatureType] | The signature type is not supported for the key type |\n | [IncompleteTransactionRequest] | The transaction request requires additional signatures |",
        "operationId" : "submitTransactionAndWait",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MintTransactionRequest"
              }
            }
          },
          "description" : "Valid transaction request with signature(s). To create this data, the transaction request details\n must be encoded using the Yabor binary encoding and subsequently signed.",
          "required" : true
        },
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MintTransactionResponse"
                }
              }
            },
            "description" : "Success"
          },
          "201" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PendingTransactionData"
                }
              }
            },
            "description" : "The transaction request requires more approval signatures and has been stored as a 'pending transaction' and possible approvers have been notified."
          },
          "208" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MintTransactionResponse"
                }
              }
            },
            "description" : "The transaction request was already processed. The result returned is the result of the previous processing."
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "403" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "Access denied. The request was authenticated but the requesting account(s) do not have the required access permission."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          },
          "504" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The transaction request was submitted but no response was received."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Send a transaction request and wait for response.",
        "tags" : [ "Transaction request" ]
      }
    },
    "/api/wallet/current-system-state" : {
      "get" : {
        "description" : "Get current system state.\n#### Endpoint Permission\nAlways permitted if the user has read access to the system.",
        "operationId" : "getSystemState",
        "parameters" : [ {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SystemStateData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get current system state.",
        "tags" : [ "System info" ]
      }
    },
    "/api/wallet/metadata/values" : {
      "get" : {
        "description" : "Query public issuer metadata.\n\n Query public issuer metadata values by multiple filters.\n#### Endpoint Permission\nAlways permitted. Once declared 'isPublic' by the Issuer of the Metadata definition, any account can retrieve the metadata.\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "queryPublicMetadata",
        "parameters" : [ {
          "description" : "Query metadata belonging to these issuers (AccountId)",
          "in" : "query",
          "name" : "issuerIds",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Metadata definition references",
          "in" : "query",
          "name" : "metadataRefs",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of product references (BlockAndIndex)",
          "in" : "query",
          "name" : "products",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of product item references (BlockAndIndex)",
          "in" : "query",
          "name" : "productItems",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of baked holding references (BlockAndIndex)",
          "in" : "query",
          "name" : "holdings",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of mint transactions referenced by BlockAndIndex",
          "in" : "query",
          "name" : "transactions",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of transactions referenced by TransactionId",
          "in" : "query",
          "name" : "transactionsById",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of account groups (BlockAndIndex)",
          "in" : "query",
          "name" : "accountGroups",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of account groups (BlockAndIndex)",
          "in" : "query",
          "name" : "securityGroups",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of attribute definitions (attribute tags)",
          "in" : "query",
          "name" : "attributes",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of accounts (AccountId)",
          "in" : "query",
          "name" : "accounts",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of access keys (AccountId)",
          "in" : "query",
          "name" : "accessKeys",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata for a list of enum values (attribute tag and enum ordinal)",
          "in" : "query",
          "name" : "enums",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Query metadata by any entity by using the format \"${[MetadataEntityRefType]}:${entity-id}\"",
          "in" : "query",
          "name" : "entityRefs",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Include metadata for referenced entities (issuerIds)",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponseMetadataEntryData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Query public issuer metadata.",
        "tags" : [ "Metadata" ]
      }
    },
    "/api/wallet/pending/cancel" : {
      "post" : {
        "description" : "Cancel a pending transaction.\n\n The transaction can be cancelled by any of the signatories.\n#### Endpoint Permission\nRequest is permitted for any of the (possible) signatories of the pending transaction.",
        "operationId" : "cancelSignature",
        "parameters" : [ {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MintTransactionRequest"
              }
            }
          },
          "description" : "Encoded and signed [CancelPendingTransactionRequest] structure.\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectTransactionId] | Referenced transaction does not match the hash of the encoded transaction data. |\n | [IncompleteTransactionRequest] | Additional signatures are required. |\n | [IncorrectSignatureType] | The signature type is not supported for the key type. |\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type. |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed). |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key. |\n | [IncorrectRequestMessage] | The request message type is invalid for this endpoint. |\n | [IncorrectSignatureOrder] | Duplicate signature. |",
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Cancel a pending transaction.",
        "tags" : [ "Wallet functions" ]
      }
    },
    "/api/wallet/pending/count" : {
      "get" : {
        "description" : "Get pending signature counts.\n Count the pending signature requests for one or more access keys.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListPendingSignatures`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `accessKeyId` | Assigned by an access key to another key permits all pending counts for the key. |\n| *issuer admin* | Assigned by the Issuer Admin account allows pending counts for all keys. |\n",
        "operationId" : "getPendingCounts",
        "parameters" : [ {
          "in" : "query",
          "name" : "accessKeyId",
          "required" : true,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/PendingSignatureCount"
                  }
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Get pending signature counts.",
        "tags" : [ "Wallet functions" ]
      }
    },
    "/api/wallet/pending/delete" : {
      "post" : {
        "description" : "Delete a pending transaction.\n\n The transaction can be deleted by any of the signatories after one of them cancelled it.\n#### Endpoint Permission\nRequest is permitted for any of the (possible) signatories of the cancelled transaction.",
        "operationId" : "deletePendingTx",
        "parameters" : [ {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MintTransactionRequest"
              }
            }
          },
          "description" : "Encoded and signed [DeletePendingTransactionRequest] structure.\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectTransactionId] | Referenced transaction does not match the hash of the encoded transaction data. |\n | [IncompleteTransactionRequest] | Additional signatures are required. |\n | [IncorrectSignatureType] | The signature type is not supported for the key type. |\n | [InvalidSignature] | The signature data supplied was not a valid signature for the key type. |\n | [IncorrectSignature] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed). |\n | [IncorrectAccountId] | The `accountId` or `accessKeyId` provided does not match the public key. |\n | [IncorrectRequestMessage] | The request message type is invalid for this endpoint. |\n | [IncorrectSignatureOrder] | Duplicate signature. |",
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Delete a pending transaction.",
        "tags" : [ "Wallet functions" ]
      }
    },
    "/api/wallet/pending/signature" : {
      "get" : {
        "description" : "List signature details for a pending transaction requests.\n\n Lists pending transactions that a signer has access to because they either already signed or cancelled the\n pending transaction or because they are a possibly signatory.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListPendingSignatures`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `signerKeyId` | Assigned by an access key to another signer permits all pending signatures for the key. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listPendingSignatures",
        "parameters" : [ {
          "description" : "Signer access key ID.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "signerKeyId",
          "required" : true,
          "schema" : {
            "type" : "string",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "Request transaction ID.",
          "in" : "query",
          "name" : "txId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Pending transaction signature status.",
          "in" : "query",
          "name" : "status",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "SIGNED", "PENDING", "REJECTED" ]
            }
          }
        }, {
          "description" : "Pending transaction status.",
          "in" : "query",
          "name" : "transactionStatus",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "PENDING", "REJECTED" ]
            }
          }
        }, {
          "description" : "Type of transaction request. The value can be a range (of the tag number of the request type), a list of exact values,\n and/or possibly a negation.",
          "in" : "query",
          "name" : "transactionType",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references:\n - [MetadataEntityRefType.TRANSACTION_ID]\n - [MetadataEntityRefType.ACCOUNT]\n - [MetadataEntityRefType.ACCESS_KEY]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields when they are grouped by them:\n\n * `created`\n * `processedTime`\n * `status` ( order is SIGNED < PENDING < REJECTED )\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponsePendingSignatureData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List signature details for a pending transaction requests.",
        "tags" : [ "Wallet functions" ]
      }
    },
    "/api/wallet/pending/transaction" : {
      "get" : {
        "description" : "List pending transaction requests.\n\n Lists pending transaction requests (including cancelled pending transaction requests) for a request account.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `ListPendingTransactions`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| `account` | Assigned by an account permits all pending transactions requested on behalf of the account. |\n| *issuer admin* | Assigned by the Issuer Admin account permits all transactions. |\n\nAny metadata references contained in the request require `Product` permission from the issuer of the metadata.",
        "operationId" : "listPendingTransactions",
        "parameters" : [ {
          "description" : "Request account ID.",
          "example" : "0x65d8a412a35e39c36ee5ab5b9e722804",
          "in" : "query",
          "name" : "account",
          "required" : false,
          "schema" : {
            "type" : "string",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          }
        }, {
          "description" : "If present, return only results for the given Transaction Request ID.",
          "in" : "query",
          "name" : "txId",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "If present, return only results with one of the specified statuses.",
          "in" : "query",
          "name" : "status",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "PENDING", "REJECTED" ]
            }
          }
        }, {
          "description" : "Type of transaction request. The value can be a range (of the tag number of the request type), a list of exact values,\n and/or possibly a negation.",
          "in" : "query",
          "name" : "transactionType",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "If specified, return only pending transactions that were created/initiated in the matching time range.\n The parameter can be a range (eg 20240101T000000..) to return all holdings that were issued in the timestamp range.\n If the parameter is a single timestamp, the system will replace it with the range `..timestamp`.",
          "in" : "query",
          "name" : "timestamp",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include extra indexed and non-indexed metadata in the response.\n Supported entity references:\n - [MetadataEntityRefType.TRANSACTION_ID]\n - [MetadataEntityRefType.ACCOUNT]",
          "in" : "query",
          "name" : "includeMetadata",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "'From' value start the next query from (inclusive).\n This value is returned in the `nextPage` field of the previous response.\n If not specified, the first result page is returned.\n There are two possible formats for the continuation token:\n - `block:index` in case the results are ordered by default block order\n - `maxBlock-index` in case results have a different order. The maxBlock part indicates the maximum block for\n possible results to ensure the next query is stable.\n - `index` the integer value of the first index of the requested page. Works with calls that\n aren't paged using block and index.",
          "in" : "query",
          "name" : "page.from",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Limit for number of results returned. If no limit is specified, the system will apply a default depending\n on the query. If a limit of zero is given, the query will not return any results. The query is not guaranteed\n to return up to the limit number of result entries if more are available. Whether more results are available\n is indicated by the presence of the `nextPage` field in the response.",
          "in" : "query",
          "name" : "page.limit",
          "required" : false,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Set to `true` to include a total count of results that match the criteria in the response.",
          "in" : "query",
          "name" : "page.withCount",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Results can be sorted by any of these fields when they are grouped by them:\n\n * `created`\n * `status` ( order is PENDING < REJECTED )\n\n To sort in descending order, prefix the field name with `-`, e.g. `-assignedAmount`",
          "in" : "query",
          "name" : "sort",
          "required" : false,
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PagedListResponsePendingTransactionData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "List pending transaction requests.",
        "tags" : [ "Wallet functions" ]
      }
    },
    "/api/wallet/save-proof/transaction/{blockAndIndex}" : {
      "get" : {
        "description" : "Save transaction proof.\n Store the proof-of-transaction for a particular transaction in the public-content and return the URL.\n The requesting user account needs to be assigned `Issuer` permission by the Issuer Admin in order to create\n files in the public content storage.\n#### Endpoint Permission\nThis endpoint requires `Request` permission for endpoint type `SaveTransactionProof`, assigned by the accounts \nin one of the following fields (in order of precedence).\n\n| Request parameter   | Description   |\n| ------------------- | ------------- |\n| *issuer admin* | Assigned by the Issuer Admin account permits access to all transactions. |\n| *account* | Assigned by an account permits all transactions that involve that account. |\n\nThis endpoint also requires the Issuer Admin to have assigned `Issuer` permission for endpoint type `SaveTransactionProof` to the issuer account(s) referenced by the request.",
        "operationId" : "saveTransactionProof",
        "parameters" : [ {
          "in" : "path",
          "name" : "blockAndIndex",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Include details of issued holdings? This would constitute a proof of payment.",
          "in" : "query",
          "name" : "includeIssuedHoldings",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include details of baked holdings? This would constitute a proof of baking.",
          "in" : "query",
          "name" : "includeBakedHoldings",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include request signature details and public keys?",
          "in" : "query",
          "name" : "includeRequestSignatures",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include request details?",
          "in" : "query",
          "name" : "includeRequest",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "Include product and product item information in the response?",
          "in" : "query",
          "name" : "includeInfo",
          "required" : false,
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "in" : "query",
          "name" : "theme",
          "required" : false,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional header containing the selected user account ID when using IDP JWT tokens in the `Authorization` header. The authenticated key needs to have access to this account (type can be FULL, PRIMARY or SECONDARY). If this header is absent, the user account ID defaults to the access key ID. Requests that use CorTenX access tokens (instead of JWT) should not provide this header as the selected user account ID is already encoded in the token.",
          "in" : "header",
          "name" : "X-Trovio-UserAccountId",
          "schema" : {
            "type" : "string",
            "format" : "AccountId"
          }
        } ],
        "responses" : {
          "200" : {
            "content" : {
              "*/*" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PublicContentLinkData"
                }
              }
            },
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Save transaction proof.",
        "tags" : [ "Wallet functions" ]
      }
    },
    "/doc/{documentId}" : {
      "get" : {
        "description" : "Retrieve document attribute.\n\n Retrieve a document referenced in an attribute value of type `DOCUMENT`.\n No authentication or permission is required. Documents in attribute values are meant to be publicly accessible.\n\n [documentId] - document identifier with allowed format: [IssuerDocumentIdentifierValidator.PATTERN] `UUID(v4).extension(3-5 chars)` (Example: `4bb597d5-fc37-42ff-b06c-02dd23bc266d.txt`)",
        "operationId" : "getAttributeDocument",
        "parameters" : [ {
          "in" : "path",
          "name" : "documentId",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Success"
          },
          "400" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request is invalid."
          },
          "409" : {
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CoreErrorResponse"
                }
              }
            },
            "description" : "The request could not be processed."
          }
        },
        "security" : [ {
          "accessToken" : [ ]
        } ],
        "summary" : "Retrieve document attribute.",
        "tags" : [ "Metadata" ]
      }
    }
  },
  "components" : {
    "schemas" : {
      "AccessCondition" : {
        "type" : "object",
        "description" : "Access condition that can be matched against one of the contexts. The `type` field specifies the condition type and determines the fields of the permission.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AccountRoleCondition" : "#/components/schemas/AccountRoleCondition",
            "AllCondition" : "#/components/schemas/AllCondition",
            "BakeHoldingCondition" : "#/components/schemas/BakeHoldingCondition",
            "EndpointTypeCondition" : "#/components/schemas/EndpointTypeCondition",
            "EntityRefCondition" : "#/components/schemas/EntityRefCondition",
            "ProductCondition" : "#/components/schemas/ProductCondition",
            "ProductTransferCondition" : "#/components/schemas/ProductTransferCondition",
            "RequiredRefCondition" : "#/components/schemas/RequiredRefCondition",
            "SetAttributeCondition" : "#/components/schemas/SetAttributeCondition",
            "TransactionAttributeCondition" : "#/components/schemas/TransactionAttributeCondition",
            "TransactionTypeCondition" : "#/components/schemas/TransactionTypeCondition"
          }
        },
        "properties" : {
          "type" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      },
      "AccessKeyDetails" : {
        "type" : "object",
        "description" : "Access permissions of a particular access key.\n The access key can have access to multiple accounts. For each account, the role of this access key for that account\n is returned.",
        "properties" : {
          "accessKeyId" : {
            "type" : "string",
            "description" : "Access key id for which this object contains information."
          },
          "accountPermissions" : {
            "type" : "array",
            "description" : "Permissions of this access key for different account.",
            "items" : {
              "$ref" : "#/components/schemas/AccountPermissionData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap",
            "description" : "If metadata was requested, Metadata of accessible accounts."
          },
          "truncated" : {
            "type" : "boolean",
            "description" : "When `true`, the result has been truncated because there are too many results.\n Use a combination of [CoreMintInfoApi.getAccountAccessDetails] and [CoreMintInfoApi.listAssignedSecurityGroups]\n to retrieve all accessible accounts."
          }
        },
        "required" : [ "accessKeyId", "accountPermissions", "truncated" ]
      },
      "AccessKeySignature" : {
        "type" : "object",
        "properties" : {
          "accessKeyId" : {
            "type" : "string",
            "description" : "Informational, the key id is a hash of the public key.",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          },
          "keyType" : {
            "type" : "string",
            "description" : "\n    The key type of the signing key. This type determines the format of the `publicKeyBytes` field.\n",
            "enum" : [ "RSA_2048", "RSA_4096", "EC_P_256", "EC_P_384", "EC_P_521" ],
            "example" : "EC_P_521"
          },
          "publicKeyData" : {
            "type" : "string",
            "format" : "byte",
            "description" : "Public key of the signing key.",
            "example" : "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBMnwSOBJBbM/9ZmLfQaMG/hGK89ySPnR0lDCSNbKB8sLyTFd9XFie+RfuP/J1P+dJbA4Wo/xT1eUL8WFvAFx0No8ApYgLzagQWmu/7HHuNOSyi8/8IfrSRWafrKg+sL7GO2d6U7dkaqdRjVAHgjAaPRjl6jOfR8oMzh5vixQ79f9nGh4="
          },
          "signatureData" : {
            "type" : "string",
            "format" : "byte",
            "description" : "Signature data.\n This data is the actual signature that can be verified using the public key.",
            "example" : "MIGHAkEb4U5pQAofigoM9IiLlDDFV8ZsJMDGVtRa+Xviut5RdPZSBfDcr1mjwbGA9JSiWkzgXLoACsrPdLMDA4tGF9dR1wJCAb9uemaMYet41Gc00HM28/SYME3PEuKSjmMyfaREMBP+vCNl/7qdkO3IQDi9mgP2cLsXyJ/+nozHyxdtBfl16iRU"
          },
          "signatureTimestamp" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Time the signature was created."
          },
          "signatureType" : {
            "type" : "string",
            "description" : "Signature type.",
            "enum" : [ "PS256", "ES256", "ES384", "ES521", "ES384_SHA384", "ES521_SHA512" ],
            "example" : "ES521"
          },
          "userAccountId" : {
            "type" : "string",
            "description" : "The account that the access key has signed for (this account needs access to the requesting account). If absent, the account id defaults to the access key id.",
            "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
          },
          "version" : {
            "type" : "integer",
            "format" : "int32"
          }
        },
        "required" : [ "accessKeyId", "keyType", "publicKeyData", "signatureData", "signatureType" ]
      },
      "AccessKeysCreatedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "accounts" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/IdentityUserData"
              }
            }
          }
        } ],
        "description" : "Notifies account that a CreateAccessKeysRequest was completed.",
        "required" : [ "accounts" ]
      },
      "AccessibleAccountData" : {
        "type" : "object",
        "description" : "Access that may be allowed per account.",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "Request account that can be selected as a current account."
          },
          "accountRoles" : {
            "type" : "array",
            "description" : "Roles that the user account can have in the scope of this account.",
            "items" : {
              "type" : "string",
              "enum" : [ "SINGLE", "INITIATOR", "APPROVER" ]
            }
          },
          "endpointTypes" : {
            "type" : "array",
            "description" : "Endpoint types that may be permitted.",
            "items" : {
              "type" : "string",
              "enum" : [ "Unsupported", "Info", "GetAccountAccess", "ListEscrow", "GetIssuer", "ListProducts", "GetProduct", "ListProductItems", "GetProductItem", "QueryBalances", "ListProductItemUnderlyingHoldings", "ListProductItemHoldings", "ListCurrentHoldings", "ListSpentHoldings", "ListHoldingBalances", "GetHolding", "ListBalanceHistory", "ListCurrentBalances", "ListTransactions", "GetTransaction", "GetTransactionProof", "GetBlockHeader", "ListBlocks", "GetAccountGroup", "ListAccountGroups", "ListAccountGroupMembers", "GetSecurityGroup", "ListSecurityGroups", "ListAssignedSecurityGroups", "ListAccounts", "IdentityUserData", "IdentityTenantData", "IdentityProviderData", "IdentityTenantHistory", "CreateMetadataDefinitions", "UpdateMetadataDefinitions", "QueryMetadataDefinitions", "SetMetadata", "QueryMetadata", "SetUserMetadata", "QueryUserMetadata", "QueryAllUserMetadata", "UploadFile", "SaveTransactionProof", "ListPendingTransactions", "ListPendingSignatures", "CancelPendingTransaction", "DeletePendingTransaction", "GetHoldingHistory", "ListVisibleAccountGroups", "Notifications", "ListUnderlyingHoldings", "ListAccessibleAccounts", "ListEnumValues", "ListAttributeDefinitions", "ListSystemStateUpdates", "QueryMetadataDefinitionsAudit", "QueryMetadataValuesAudit" ]
            }
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata that was queried for the account (entity references: [MetadataEntityRefType.ACCOUNT])."
          },
          "requestTypes" : {
            "type" : "array",
            "description" : "Request types that may be permitted.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "accountId", "accountRoles", "endpointTypes", "requestTypes" ]
      },
      "AccessibleRequestAccountData" : {
        "type" : "object",
        "description" : "Response entry for each accessible request account.\n Each entry describes a request account that has assigned request permission to the user account.",
        "properties" : {
          "requestAccountId" : {
            "type" : "string",
            "description" : "The request account ID that has assigned the permission to the user account (i.e. the 'assignedBy' account ID of a security group assignment)."
          },
          "userAccountId" : {
            "type" : "string",
            "description" : "The user account ID to which the permission has been assigned (i.e. the 'assignedTo' account ID of a security group assignment)."
          },
          "visibleAccountGroups" : {
            "type" : "array",
            "description" : "The visible account groups of the request account.",
            "items" : {
              "$ref" : "#/components/schemas/AccountGroupEntry"
            }
          }
        },
        "required" : [ "requestAccountId", "userAccountId", "visibleAccountGroups" ]
      },
      "AccessibleUserAccountData" : {
        "type" : "object",
        "description" : "Account access type for an Access Key ID and a User Account ID.",
        "properties" : {
          "accessKeyId" : {
            "type" : "string",
            "description" : "Access key ID that has access to the user account."
          },
          "type" : {
            "type" : "string",
            "description" : "New access permissions to assign to this access key in the scope of the given account.",
            "enum" : [ "FULL", "PRIMARY", "SECONDARY", "REVOKED" ]
          },
          "userAccountId" : {
            "type" : "string",
            "description" : "User account ID that can be accessed."
          }
        },
        "required" : [ "accessKeyId", "type", "userAccountId" ]
      },
      "AccountAccessData" : {
        "type" : "object",
        "properties" : {
          "accessKeyId" : {
            "type" : "string",
            "description" : "Access key id for which the permissions on this account are updated."
          },
          "type" : {
            "type" : "string",
            "description" : "New access permissions to assign to this access key in the scope of the given account.",
            "enum" : [ "FULL", "PRIMARY", "SECONDARY", "REVOKED" ]
          }
        },
        "required" : [ "accessKeyId", "type" ]
      },
      "AccountData" : {
        "type" : "object",
        "description" : "Entry for a member account of an account group.",
        "properties" : {
          "accountGroups" : {
            "type" : "array",
            "description" : "Account groups for which the AccountCriteria's memberOfAnyOf or memberOfAllOf was filtering.",
            "items" : {
              "type" : "string"
            }
          },
          "accountId" : {
            "type" : "string"
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata that was queried for the account (entity references: [MetadataEntityRefType.ACCOUNT])."
          }
        },
        "required" : [ "accountId" ]
      },
      "AccountGroupAssignedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/UpdateAccountGroupEntry",
              "description" : "Details for the update that relate to the notified account."
            }
          }
        } ],
        "description" : "Notifies the account group owner when accounts are added/removed to/from an account group.",
        "required" : [ "tx" ]
      },
      "AccountGroupData" : {
        "type" : "object",
        "description" : "Details of an Account Group.",
        "properties" : {
          "accessType" : {
            "type" : "string",
            "description" : "Optionally, an account group can be used to control the user type of user accounts that are members.\n When set, each member account will get the user type of the account group.\n When not set (or [UserAccessType.NoAccessType] is set), this account group does not control which users\n can access the system.",
            "enum" : [ "NoAccessType", "AuditAccess", "UserAccess", "AdminAccess", "OperatorAccess" ]
          },
          "accountGroupId" : {
            "type" : "string",
            "description" : "Account group id. This is the block and index of the Create Account Group transaction."
          },
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Custom attributes assigned to this account group."
          },
          "isDeleted" : {
            "type" : "boolean",
            "description" : "When true, the account group has been deleted."
          },
          "isVisibleToMembers" : {
            "type" : "boolean",
            "description" : "Indicates whether this account group is included in `ListVisibleAccountGroups` result."
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata that was queried for the account group (entity references: [MetadataEntityRefType.ACCOUNT_GROUP])."
          },
          "ownerId" : {
            "type" : "string",
            "description" : "Owner account of this account group. Only the owner account can add/remove member accounts."
          },
          "securityGroups" : {
            "type" : "array",
            "description" : "Ids of the security groups that have been assigned to this account group by the owner of the account group.",
            "items" : {
              "type" : "string"
            }
          },
          "versionId" : {
            "type" : "string",
            "description" : "Transaction that last updated the account group."
          },
          "visibleToMembersOf" : {
            "type" : "string",
            "description" : "Optionally, visibility can be controlled by another account group.\n Setting this field to ALL_ACCOUNTS makes the account group visible to all accounts."
          }
        },
        "required" : [ "accountGroupId", "isVisibleToMembers", "ownerId", "versionId" ]
      },
      "AccountGroupEntry" : {
        "type" : "object",
        "description" : "For each visible account group, a short entry that contains the ID, attributes and possibly metadata for the account group.",
        "properties" : {
          "accountGroupId" : {
            "type" : "string",
            "description" : "Account group ID."
          },
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Account group attributes."
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Account group metadata requested with `includeMetadata`."
          },
          "ownerId" : {
            "type" : "string",
            "description" : "Owner account of this account group."
          }
        },
        "required" : [ "accountGroupId", "ownerId" ]
      },
      "AccountPermissionData" : {
        "type" : "object",
        "description" : "The set of permissions for a particular access key on particular request accounts.",
        "properties" : {
          "accessibleAccounts" : {
            "type" : "array",
            "description" : "List of other accounts that this account has request permission for.",
            "items" : {
              "$ref" : "#/components/schemas/AccessibleAccountData"
            }
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata that was queried for the account (entity references: [MetadataEntityRefType.ACCOUNT])."
          },
          "type" : {
            "type" : "string",
            "description" : "Type of access key for this account.",
            "enum" : [ "FULL", "PRIMARY", "SECONDARY", "REVOKED" ]
          },
          "userAccountId" : {
            "type" : "string",
            "description" : "Account that the access key can sign for. In some systems this is the 'user account'."
          }
        },
        "required" : [ "accessibleAccounts", "type", "userAccountId" ]
      },
      "AccountRoleCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "oneOf" : {
              "type" : "array",
              "items" : {
                "type" : "string",
                "enum" : [ "SINGLE", "INITIATOR", "APPROVER" ]
              },
              "maxItems" : 2147483647,
              "minItems" : 1
            }
          }
        } ],
        "description" : "Access condition that matches on the role type of the requesting account.",
        "required" : [ "oneOf", "type" ]
      },
      "AdjustHoldingRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "holdingIds" : {
              "type" : "array",
              "description" : "Holdings to reclaim.",
              "items" : {
                "type" : "string"
              }
            },
            "issuerId" : {
              "type" : "string"
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            }
          }
        } ],
        "description" : "An issuer can reclaim holdings and transfer them back to the issuer.\n This invasive operation should occur rarely and therefore warrants a separate transaction type.\n\n The holdings being reclaimed can not be with the issuer already.\n\n The holdings being reclaimed must be of the issuer's products.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `AdjustHoldingRequest`, assigned by the\n request account in the `issuerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | The list of holding IDs is empty. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [HoldingAccessDenied] | The issuer is not the holding issuer. |\n | [HoldingIsAlreadyWithIssuer] | Holding is already with the issuer, therefore not needed. |\n | [HoldingIsSpent] | A holding ID does not reference an unspent holding, it may be spent or invalid. |",
        "required" : [ "holdingIds", "issuerId", "type" ]
      },
      "AllCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "contextType" : {
              "type" : "string",
              "enum" : [ "Base", "Request", "Transaction", "Transfer", "EndpointRequest", "Endpoint", "EndpointRefs", "Product" ]
            }
          }
        } ],
        "description" : "Condition that always matches at the given context type.",
        "required" : [ "contextType", "type" ]
      },
      "AssignHoldingRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "deflationMode" : {
              "type" : "string",
              "description" : "Determines how the given holdings are re-assigned.",
              "enum" : [ "DontDeflate", "Deflate", "DeflateAndDelete" ]
            },
            "holdingIds" : {
              "type" : "array",
              "description" : "Holdings to (re-assign).",
              "items" : {
                "type" : "string"
              }
            },
            "inflationMode" : {
              "type" : "string",
              "description" : "Determines how new holdings are selected.",
              "enum" : [ "DontInflate", "Inflate" ]
            },
            "issuerId" : {
              "type" : "string",
              "description" : "Request account ID is the issuer of the holdings and product items."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "productItems" : {
              "type" : "array",
              "description" : "Product items to assign to.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Assign unassigned / unspent holdings to the given product items.\n\n Multiple holdings can be assigned to a list of product items. Holdings can be unassigned or assigned (i.e. unspent)\n holdings and can be assigned to unassigned or assigned product items.\n All holdings request are (re-)assigned to the product items in the order in which they are specified, creating\n new holdings in the specified product items.\n\n The `deflationMode` determines the way that the old holdings are spent. With `DontDeflate`, the holdings are re-assigned\n to the issuer. With `Deflate`, the product item is deflated. With `DeflateAndDelete`\n the product item is deflated and deleted if there are no more holdings. The default mode (if no mode is specified) is\n to `Deflate` if the product item is inflatable, and `DontDeflate` if the product item is not inflatable.\n\n The `inflationMode` determines the way that the new holdings are allocated. With `Inflate`, the product item is inflated.\n With `DontInflate` the new holding is selected from available issuer holdings. The default inflation mode (if no mode is specified)\n is to `DontInflate`.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `AssignHoldingRequest`, assigned by the\n request account in the `issuerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | The list of holding IDs is empty. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InsufficientAvailableToAssign] | The list of product items is empty, or there is not enough available amount in the listed non-inflatable product items.  |\n | [IncorrectIssuer] | The requesting account is not the holding issuer. |\n | [ProductItemsMustBeSameProduct] | Referenced product items must be from the same product. |\n | [HoldingsMustBeSameProduct] | Referenced holdings must be from the same product. |\n | [ProductItemIsDeleted] | Referenced product item is deleted. |\n | [ProductItemNotFound] | Referenced product item does not exist. |\n | [DeflationModeNotAllowedForProductItem] | The deflation mode is not allowed for a product item. Ensure that [Deflate] is not selected for non-inflatable items. |\n | [InflationModeNotAllowedForProductItem] | The inflation mode is not allowed for a product item. Ensure that [Inflate] is not selected for non-inflatable items. |\n | [HoldingIsSpent] | A holding ID does not reference an unspent holding, it may be spent or invalid. |",
        "required" : [ "holdingIds", "issuerId", "productItems", "type" ]
      },
      "AssignHoldingSelectorRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "deflationMode" : {
              "type" : "string",
              "description" : "Determines how the given holdings are re-assigned.",
              "enum" : [ "DontDeflate", "Deflate", "DeflateAndDelete" ]
            },
            "from" : {
              "$ref" : "#/components/schemas/HoldingSelector",
              "description" : "Selector for holdings to (re-)assign."
            },
            "fromAccount" : {
              "type" : "string",
              "description" : "Account from which holdings are selected."
            },
            "inflationMode" : {
              "type" : "string",
              "description" : "Determines how new holdings are selected.",
              "enum" : [ "DontInflate", "Inflate" ]
            },
            "issuerId" : {
              "type" : "string",
              "description" : "Request account ID is the issuer of the holdings and product items."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "productItems" : {
              "type" : "array",
              "description" : "Product items to assign to.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Assign unassigned / unspent holdings to the given product items.\n\n Multiple holdings can be assigned to a list of product items. Holdings can be unassigned or assigned (i.e. unspent)\n holdings and can be assigned to unassigned or assigned product items.\n All holdings request are (re-)assigned to the product items in the order in which they are specified, creating\n new holdings in the specified product items.\n\n The `deflationMode` determines the way that the old holdings are spent. With `DontDeflate`, the holdings are re-assigned\n to the issuer. With `Deflate`, the product item is deflated. With `DeflateAndDelete`\n the product item is deflated and deleted if there are no more holdings. The default mode (if no mode is specified) is\n to `Deflate` if the product item is inflatable, and `DontDeflate` if the product item is not inflatable.\n\n The `inflationMode` determines the way that the new holdings are allocated. With `Inflate`, the product item is inflated.\n With `DontInflate` the new holding is selected from available issuer holdings. The default inflation mode (if no mode is specified)\n is to `DontInflate`.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `AssignHoldingSelectorRequest`, assigned by the\n request account in the `issuerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ValueHasTooManyDigits] | An amount in the holding selector exceeds maximum precision. |\n | [NonPositiveTransferAmount] | An amount in the holding selector is negative or zero. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidRequest] | The holding selector yields no holdings. |\n | [InsufficientAvailableToAssign] | The list of product items is empty, or there is not enough available amount in the listed non-inflatable product items.  |\n | [IncorrectIssuer] | The requesting account is not the holding issuer. |\n | [ProductItemsMustBeSameProduct] | Referenced product items must be from the same product. |\n | [HoldingsMustBeSameProduct] | Referenced holdings must be from the same product. |\n | [ProductItemIsDeleted] | Referenced product item is deleted. |\n | [ProductItemNotFound] | Referenced product item does not exist. |\n | [DeflationModeNotAllowedForProductItem] | The deflation mode is not allowed for a product item. Ensure that [Deflate] is not selected for non-inflatable items. |\n | [InflationModeNotAllowedForProductItem] | The inflation mode is not allowed for a product item. Ensure that [Inflate] is not selected for non-inflatable items. |\n | [HoldingIsSpent] | A holding ID does not reference an unspent holding, it may be spent or invalid. |",
        "required" : [ "from", "fromAccount", "issuerId", "productItems", "type" ]
      },
      "AssignSecurityGroupEntry" : {
        "type" : "object",
        "properties" : {
          "accountGroupIds" : {
            "type" : "array",
            "description" : "Account group ids to update the security groups for.",
            "items" : {
              "type" : "string"
            }
          },
          "accountIds" : {
            "type" : "array",
            "description" : "Individual account ids to update the security groups for.",
            "items" : {
              "type" : "string"
            }
          },
          "addSecurityGroupIds" : {
            "type" : "array",
            "description" : "Security groups to add to the target accounts/groups.",
            "items" : {
              "type" : "string"
            }
          },
          "removeSecurityGroupIds" : {
            "type" : "array",
            "description" : "Security groups to remove from the target accounts/groups.",
            "items" : {
              "type" : "string"
            }
          },
          "setSecurityGroupIds" : {
            "type" : "array",
            "description" : "Replace all security groups set by the same assigner with the given list.",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "AssignSecurityGroupsRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "assignedBy" : {
              "type" : "string",
              "description" : "The request account that is making the security group assignments. This account is the one that access will be granted to."
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "updates" : {
              "type" : "array",
              "description" : "List of security group assignments to make.",
              "items" : {
                "$ref" : "#/components/schemas/AssignSecurityGroupEntry"
              }
            }
          }
        } ],
        "description" : "Assign Security Groups to Accounts and Account Groups.\n An account assigns security groups to individual accounts and/or account groups, giving them access to the\n assigning account.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `AssignSecurityGroupsRequest`, assigned by the\n request account in the `assignedBy` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyOptionalList] | Optional lists in the request should be absent or `null` instead of `[]`. |\n | [EmptyRequest] | Empty list of updates, or the request contains an empty update. |\n | [MixingAddRemoveWithSet] | The request mixes the `add`/`remove` pattern with the 'set' pattern. |\n | [BothAddAndRemove] | The request removes an entity that it just added. |\n | [DuplicateAccountId] | A list of account IDs contains a duplicate entry. |\n | [DuplicateAccountGroupId] | A list of account group IDs contains a duplicate entry. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [AccountGroupIsDeleted] | Referenced account group is deleted. |\n | [AccountGroupNotFound] | Referenced account group does not exist. |\n | [SecurityGroupIsDeleted] | Referenced security group is deleted. |\n | [SecurityGroupNotFound] | Referenced security group does not exist. |\n\n #### TODO: Permission requirements",
        "required" : [ "assignedBy", "type", "updates" ]
      },
      "AssignedSecurityGroupData" : {
        "type" : "object",
        "description" : "Data of a security group assignment directly to an account or to an account group.",
        "properties" : {
          "accountGroup" : {
            "$ref" : "#/components/schemas/AccountGroupData",
            "description" : "If `includeDetail` was set in the criteria, the account group details."
          },
          "accountGroupId" : {
            "type" : "string",
            "description" : "If the assignment was made through an account group membership, this field contains the account group id."
          },
          "accountId" : {
            "type" : "string",
            "description" : "The account id that the security group is assigned to. If security assignments are requested without supplying\n specific account criteria, this field may be `null` and `accountGroupId` will be set."
          },
          "assignedBy" : {
            "type" : "string",
            "description" : "The account that created the assignment."
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap",
            "description" : "Account metadata if metadata was requested."
          },
          "permissionType" : {
            "type" : "string",
            "description" : "Type of permission that is assigned by the security group.",
            "enum" : [ "Request", "Product", "Issuer", "Controller" ]
          },
          "securityGroup" : {
            "$ref" : "#/components/schemas/SecurityGroupData",
            "description" : "If `includeDetail` was set in the criteria, the security group details."
          },
          "securityGroupId" : {
            "type" : "string",
            "description" : "The security group that is assigned."
          }
        },
        "required" : [ "assignedBy", "permissionType", "securityGroupId" ]
      },
      "AttributeDefinitionData" : {
        "type" : "object",
        "properties" : {
          "createdBy" : {
            "type" : "string",
            "description" : "Account that created the attribute."
          },
          "isIndexed" : {
            "type" : "boolean",
            "description" : "When true, the attribute's values are indexed and can be used in filter and sort criteria."
          },
          "maxCount" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "For lists, a maximum count can be specified."
          },
          "minCount" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "For lists, a minimal count can be specified."
          },
          "name" : {
            "type" : "string",
            "description" : "Unique attribute name used in JSON representations."
          },
          "tag" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Unique tag number for this attribute in binary representations."
          },
          "validationRules" : {
            "type" : "array",
            "description" : "Validation rules.",
            "items" : {
              "$ref" : "#/components/schemas/AttributeRule"
            }
          },
          "valueType" : {
            "type" : "string",
            "description" : "Attribute type.",
            "enum" : [ "BOOLEAN", "INTEGER", "DECIMAL", "BYTESTRING", "STRING", "MAP", "URI", "TIMESTAMP", "PRODUCT", "DOCUMENT", "LATLON", "TRANSACTION_TYPE", "ENUMERATED", "DATE", "DATETIME", "YEARMONTH" ]
          },
          "version" : {
            "type" : "string",
            "description" : "Version is the block and index of the previous attribute modification transaction."
          }
        },
        "required" : [ "createdBy", "name", "tag", "validationRules", "valueType" ]
      },
      "AttributeRule" : {
        "description" : "Validation rule that can be applied to attribute values.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DecimalPosRule" : "#/components/schemas/DecimalPosRule",
            "IntegerMinMaxRule" : "#/components/schemas/IntegerMinMaxRule",
            "StringLengthRule" : "#/components/schemas/StringLengthRule",
            "StringRegexRule" : "#/components/schemas/StringRegexRule"
          }
        },
        "properties" : {
          "type" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      },
      "AttributeUseData" : {
        "type" : "object",
        "properties" : {
          "ref" : {
            "type" : "string",
            "description" : "Attribute reference, unique within the system."
          },
          "required" : {
            "type" : "boolean",
            "description" : "Is this attribute required by this requester?"
          },
          "validationRules" : {
            "type" : "array",
            "description" : "When present, validate extra validation rules.",
            "items" : {
              "$ref" : "#/components/schemas/AttributeRule"
            }
          }
        },
        "required" : [ "ref", "required", "validationRules" ]
      },
      "AttributeValuesBalanceData" : {
        "type" : "object",
        "description" : "Response entry that contains a combination of attribute values with optional balances.",
        "properties" : {
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            }
          },
          "balances" : {
            "$ref" : "#/components/schemas/ProductBalanceData"
          }
        },
        "required" : [ "attributes" ]
      },
      "AuthConfig" : {
        "type" : "object",
        "properties" : {
          "authority" : {
            "type" : "string"
          },
          "automaticSilentRenew" : {
            "type" : "boolean"
          },
          "clientId" : {
            "type" : "string"
          },
          "configDisplayName" : {
            "type" : "string"
          },
          "endSessionEndpoint" : {
            "type" : "string"
          },
          "responseType" : {
            "type" : "string"
          },
          "scope" : {
            "type" : "string"
          }
        },
        "required" : [ "authority", "automaticSilentRenew", "clientId", "configDisplayName", "endSessionEndpoint", "responseType", "scope" ]
      },
      "BakeHoldingCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "productIds" : {
              "type" : "array",
              "description" : "Products allowed to bake into",
              "items" : {
                "type" : "string"
              }
            },
            "requiresBakeInto" : {
              "type" : "boolean",
              "description" : "Forces [BakeHoldingRequest] to have a bakeInto value"
            }
          }
        } ],
        "description" : "Matches a baking of a specific product.\n\n An issuer can require a [BakeHoldingRequest] to bake into (instead of just baking). The issuer of the product being baked can restrict the products it can be baked into (in addition to the underlying products defined by that product definition).",
        "required" : [ "type" ]
      },
      "BakeHoldingRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the baked holding."
            },
            "bakeInto" : {
              "type" : "string",
              "description" : "Optionally, the product item into which the holdings are baked.\n If specified, the request account must have a holding in this product item."
            },
            "from" : {
              "$ref" : "#/components/schemas/HoldingSelector",
              "description" : "Expression for holdings to select."
            },
            "fromAccountId" : {
              "type" : "string",
              "description" : "The request account that owns the holdings to be baked."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            }
          }
        } ],
        "description" : "Bake an amount of holdings with attributes.\n\n Baked holdings are spent without being exchanged for another value.\n After baking, holdings can be imported into other systems with a trust relationship using the transaction proof.\n To create product items with underlying baked holdings, use [CreateProductItemRequest] with the `underlying` field.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `BakeHoldingRequest`, assigned by the\n request account in the `fromAccountId` field.\n\n If a product item is specified for baking into, the request account additionally requires Product permission from\n the issuer of the product item.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The from account did not grant permission for the request. |\n | [ProductAccessDenied] | The issuer of the product did not grant permission for the transfer. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ValueHasTooManyDigits] | An amount in the holding selector exceeds maximum precision. |\n | [NonPositiveTransferAmount] | An amount in the holding selector is negative or zero. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InsufficientHoldings] | The holding selector yields insufficient unspent holdings. |\n | [InvalidRequest] | No amount referenced. |\n | [HoldingAccessDenied] | A selected holding is not held by the requester's account. |\n | [HoldingsMustBeSameProduct] | Referenced holdings must be from the same product. |\n | [HoldingIsEscrowed] | An attempt was made to select an 'input' holding that was already locked. |\n | [HoldingIsUnassigned] | An attempt was made to select an 'input' holding that was not assigned yet. |\n | [HoldingIsNotUnassigned] | An attempt was made to assign a holding that was already assigned. |\n | [NotMultipleOfUnitAmount] | The amount specified needs to be an integer multiple of the `unitAmount` of the product item. |\n | [QuantityOverflow] | The exact quantity computed overflows its type. |\n | [ProductItemNotFound] | The \"bake into\" product item is not found. |",
        "required" : [ "from", "fromAccountId", "type" ]
      },
      "BalanceData" : {
        "type" : "object",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "When the accountId is not implicit, the accountId is returned."
          },
          "assignedAmount" : {
            "type" : "number",
            "description" : "Total (assigned) amount in matching holdings."
          },
          "bakedAmount" : {
            "type" : "number",
            "description" : "Baked amount."
          },
          "escrowAmount" : {
            "type" : "number",
            "description" : "Amount held in escrow by other controllers."
          },
          "issuer" : {
            "$ref" : "#/components/schemas/IssuerData",
            "description" : "Issuer data (present if issuer data is requested)."
          },
          "issuerAmount" : {
            "type" : "number",
            "description" : "Available amount held by the issuer. This amount represent the current holdings held by the issuer of the product,\n that have not been locked. Whether the amount represents an unassigned or assigned amount depends on the\n 'unassigned' status of the product item."
          },
          "issuerId" : {
            "type" : "string",
            "description" : "Issuer id for this product (present if issuer data is not included)"
          },
          "product" : {
            "$ref" : "#/components/schemas/ProductData",
            "description" : "Product data (present if product data is requested)."
          },
          "productId" : {
            "type" : "string",
            "description" : "Product id."
          },
          "productItem" : {
            "$ref" : "#/components/schemas/ProductItemData",
            "description" : "Product item data (present if product item data is requested)."
          },
          "productItemId" : {
            "type" : "string",
            "description" : "Product item id (not present if full-data is included or summing product items)."
          },
          "unassignedAmount" : {
            "type" : "number",
            "description" : "Total (unassigned) amount in matching holdings."
          },
          "underlying" : {
            "type" : "array",
            "description" : "When requested with `includeUnderlyingData`, data about the underlying baked holdings of these amounts.",
            "items" : {
              "$ref" : "#/components/schemas/UnderlyingHoldingBalance"
            }
          }
        },
        "required" : [ "assignedAmount", "issuerAmount", "unassignedAmount" ]
      },
      "BalanceHistoryData" : {
        "type" : "object",
        "description" : "Response entry that contains a combination of attribute values with optional balances.",
        "properties" : {
          "account" : {
            "type" : "string",
            "description" : "Grouped by account if requested."
          },
          "balanceMap" : {
            "type" : "object",
            "additionalProperties" : { },
            "description" : "Balance movement per account and then per product"
          },
          "balances" : {
            "$ref" : "#/components/schemas/ProductBalanceData",
            "description" : "Balance movement for this subset of holding changes"
          },
          "productItem" : {
            "$ref" : "#/components/schemas/ProductItemData",
            "description" : "If request was grouped on 'whole' product items, the product item data for this result."
          },
          "productItemAttributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Product item attribute data that was grouped on."
          },
          "transaction" : {
            "$ref" : "#/components/schemas/TransactionData",
            "description" : "If request was grouping for transactions, the transaction data for this result."
          },
          "transactionAttributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Transaction attribute data that was grouped on."
          },
          "withIssuer" : {
            "type" : "boolean",
            "description" : "If grouped by 'withIssuer', `true` if the balances are for the issuer and `false` if the balances are for non-issuer accounts."
          }
        }
      },
      "BlockAccountIssuedHoldings" : {
        "type" : "object",
        "description" : "Issued holdings by account id.",
        "properties" : {
          "accountId" : {
            "type" : "string"
          },
          "holdings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/BlockIssuedHolding"
            }
          }
        },
        "required" : [ "accountId", "holdings" ]
      },
      "BlockBody" : {
        "type" : "object",
        "properties" : {
          "transactionList" : {
            "type" : "array",
            "description" : "Transactions in this block.",
            "items" : {
              "$ref" : "#/components/schemas/BlockTransaction"
            }
          }
        },
        "required" : [ "transactionList" ]
      },
      "BlockBodyProofData" : {
        "type" : "object",
        "description" : "Data to prove that a transaction hash is part of a signed block.",
        "properties" : {
          "blockHeader" : {
            "$ref" : "#/components/schemas/BlockHeader",
            "description" : "Header with block number and body hash. The signatures are on the block header hash."
          },
          "blockSignatures" : {
            "type" : "array",
            "description" : "Signatures for processors / validators that signed this block.",
            "items" : {
              "$ref" : "#/components/schemas/CertifiedBlockSignature"
            }
          },
          "nodeHashes" : {
            "type" : "array",
            "description" : "Other Merkle nodes up the path to the body hash. The hashes are listed from the transaction hash level down\n to the root body hash.",
            "items" : {
              "type" : "string",
              "format" : "byte"
            }
          },
          "transactionIndex" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Index in the block of the transaction being verified."
          }
        },
        "required" : [ "blockHeader", "blockSignatures", "nodeHashes", "transactionIndex" ]
      },
      "BlockData" : {
        "type" : "object",
        "description" : "DTO for decoded block data.",
        "properties" : {
          "body" : {
            "$ref" : "#/components/schemas/BlockBody"
          },
          "footer" : {
            "$ref" : "#/components/schemas/BlockFooter"
          },
          "header" : {
            "$ref" : "#/components/schemas/BlockHeader"
          },
          "headerHash" : {
            "type" : "string",
            "format" : "byte"
          }
        },
        "required" : [ "body", "footer", "header", "headerHash" ]
      },
      "BlockFooter" : {
        "type" : "object",
        "description" : "The block footer contains additional data that is needed to verify blocks, but that is not part of the\n body hash itself.",
        "properties" : {
          "accessKeys" : {
            "type" : "array",
            "description" : "Public key information for each access key used in this block.",
            "items" : {
              "$ref" : "#/components/schemas/BlockPublicKeyData"
            }
          },
          "blockSignatures" : {
            "type" : "array",
            "description" : "Signatures for processors / validators that signed this block.",
            "items" : {
              "$ref" : "#/components/schemas/BlockSignatureData"
            }
          },
          "transactionHashes" : {
            "type" : "array",
            "description" : "Transaction hashes for each transaction (in order).",
            "items" : {
              "type" : "string",
              "format" : "byte"
            }
          }
        },
        "required" : [ "accessKeys", "blockSignatures", "transactionHashes" ]
      },
      "BlockHeader" : {
        "type" : "object",
        "description" : "Block header information.\n Each block of transactions has a header that uniquely identifies the block and its contents.\n Each block has a unique number and blocks are consecutively numbered.",
        "properties" : {
          "blockNumber" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Unique number of this block is part of the block as a means of self-describing."
          },
          "bodyHash" : {
            "type" : "string",
            "format" : "byte",
            "description" : "SHA-256 hash of block body.",
            "maxLength" : 32,
            "minLength" : 32
          },
          "endTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Time processing ended."
          },
          "prevBlockHash" : {
            "type" : "string",
            "format" : "byte",
            "description" : "SHA-256 hash of previous block header.",
            "maxLength" : 32,
            "minLength" : 32
          },
          "startTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Time processing started."
          },
          "version" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Block encoding and hashing version."
          }
        },
        "required" : [ "blockNumber", "bodyHash", "endTime", "prevBlockHash", "startTime", "version" ]
      },
      "BlockIssuedHolding" : {
        "type" : "object",
        "description" : "Data structure of a issued holding, issued by a transaction.",
        "properties" : {
          "controllerAccountId" : {
            "type" : "string",
            "description" : "If Escrowed, the controller of the escrow."
          },
          "escrowId" : {
            "type" : "string",
            "description" : "If Escrowed, the escrow hash."
          },
          "holdingId" : {
            "type" : "string",
            "description" : "Holding id (within the current block)"
          },
          "index" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Index in the product item for this holding (if product item is non-inflatable)."
          },
          "productItem" : {
            "type" : "string",
            "description" : "Product item that this holding is allocated to"
          },
          "quantity" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Unit quantity of this holding. The amount of holding is quantity*productItem.unitAmount"
          },
          "state" : {
            "type" : "string",
            "description" : "Status of this holding.",
            "enum" : [ "Spent", "Unassigned", "Unspent", "Escrowed", "Baked", "Deflated" ]
          }
        },
        "required" : [ "holdingId", "productItem", "quantity", "state" ]
      },
      "BlockPublicKeyData" : {
        "type" : "object",
        "description" : "Access key information as it is stored in the block footer.",
        "properties" : {
          "keyId" : {
            "type" : "string",
            "description" : "Informational, the key id is a hash of the public key."
          },
          "keyType" : {
            "type" : "string",
            "description" : "\n    The key type of the signing key. This type determines the format of the `publicKeyBytes` field.\n",
            "enum" : [ "RSA_2048", "RSA_4096", "EC_P_256", "EC_P_384", "EC_P_521" ]
          },
          "publicKeyData" : {
            "type" : "string",
            "format" : "byte",
            "description" : "PKCS#8 encoding of the access key's public key."
          }
        },
        "required" : [ "keyId", "keyType", "publicKeyData" ]
      },
      "BlockSignatureData" : {
        "type" : "object",
        "description" : "Access key signature on a transaction request.",
        "properties" : {
          "accountAccessType" : {
            "type" : "string",
            "description" : "Account access type for the user account. Default is [AccountAccessType.FULL].",
            "enum" : [ "FULL", "PRIMARY", "SECONDARY", "REVOKED" ]
          },
          "accountRoleType" : {
            "type" : "string",
            "description" : "Account role for this user account at the time the signature was verified. Default is [AccountRoleType.SINGLE]",
            "enum" : [ "SINGLE", "INITIATOR", "APPROVER" ]
          },
          "keyId" : {
            "type" : "string",
            "description" : "Id of the key used to sign this data."
          },
          "signatureData" : {
            "type" : "string",
            "format" : "byte",
            "description" : "Signature data according to the key's signature type."
          },
          "signatureTimestamp" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Time the signature was created."
          },
          "signatureType" : {
            "type" : "string",
            "enum" : [ "PS256", "ES256", "ES384", "ES521", "ES384_SHA384", "ES521_SHA512" ]
          },
          "userAccessType" : {
            "type" : "string",
            "description" : "Time the signature was created.",
            "enum" : [ "NoAccessType", "AuditAccess", "UserAccess", "AdminAccess", "OperatorAccess" ]
          },
          "userAccountId" : {
            "type" : "string",
            "description" : "User account id if different from the keyId."
          }
        },
        "required" : [ "keyId", "signatureData", "signatureType" ]
      },
      "BlockSpentHolding" : {
        "type" : "object",
        "description" : "For each spent we repeat the quantity/index and product item to make the signature verifiable.",
        "properties" : {
          "bakedInto" : {
            "type" : "string",
            "description" : "Product item that this holding was baked into (for Baked holdings)."
          },
          "id" : {
            "type" : "string"
          },
          "index" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Index in the product item for this holding (if product item is non-inflatable)."
          },
          "productItem" : {
            "type" : "string",
            "description" : "Product item that this holding was allocated to"
          },
          "quantity" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Unit quantity of this holding. The amount of holding is quantity*productItem.unitAmount"
          },
          "state" : {
            "type" : "string",
            "description" : "Status of this holding.",
            "enum" : [ "Spent", "Unassigned", "Unspent", "Escrowed", "Baked", "Deflated" ]
          }
        },
        "required" : [ "id", "productItem", "quantity", "state" ]
      },
      "BlockTransaction" : {
        "type" : "object",
        "description" : "Data for a transaction as it is captured in a block.",
        "properties" : {
          "attributeTag" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "New attribute tags."
          },
          "bakedHoldings" : {
            "type" : "array",
            "description" : "Baked spent holdings.",
            "items" : {
              "$ref" : "#/components/schemas/BlockSpentHolding"
            }
          },
          "otherIssuedHoldings" : {
            "type" : "array",
            "description" : "Holdings issued to other accounts.",
            "items" : {
              "$ref" : "#/components/schemas/BlockAccountIssuedHoldings"
            }
          },
          "request" : {
            "$ref" : "#/components/schemas/TransactionRequest",
            "description" : "Original request data."
          },
          "requestSignatures" : {
            "type" : "array",
            "description" : "Signatures for access keys that signed the request.",
            "items" : {
              "$ref" : "#/components/schemas/BlockSignatureData"
            }
          },
          "selfIssuedHoldings" : {
            "type" : "array",
            "description" : "Holdings issued to 'self' account (i.e. change).",
            "items" : {
              "$ref" : "#/components/schemas/BlockIssuedHolding"
            }
          },
          "spentHoldings" : {
            "type" : "array",
            "description" : "Spent (but not baked) holdings.",
            "items" : {
              "$ref" : "#/components/schemas/BlockSpentHolding"
            }
          },
          "txId" : {
            "type" : "string",
            "description" : "Transaction ID is the hash of the request data."
          }
        },
        "required" : [ "request", "requestSignatures", "txId" ]
      },
      "CancelEscrowRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Attributes for cancellation."
            },
            "controllerAccountId" : {
              "type" : "string",
              "description" : "Controller that was assigned to the escrow."
            },
            "escrowId" : {
              "type" : "string",
              "description" : "Escrow to cancel"
            },
            "fromAccountId" : {
              "type" : "string",
              "description" : "Holding account for the escrowed holdings."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "requesterIsController" : {
              "type" : "boolean",
              "description" : "Is the requester the controller (as opposed to the holder)?"
            }
          }
        } ],
        "description" : "Cancel an escrowed holding and return control to the holder.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `CancelEscrowRequest`, assigned by either:\n - the request account in the `fromAccountId` field, if `requesterIsController` is set to `false`, or\n - the request account in the `controllerAccountId` field, if the `requesterIsController` is set to `true`.\n\n In addition, if `Controller` security groups are assigned by the controller account to the holding account, they need\n to grant the `Controller` permission for the request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The request account did not grant permission for the request. |\n | [ControllerAccessDenied] | The controller of an escrow did not grant permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EscrowNotFound] | Referenced escrow does not exist. |",
        "required" : [ "controllerAccountId", "escrowId", "fromAccountId", "requesterIsController", "type" ]
      },
      "CancelEscrowedHoldingsRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Attributes for cancellation."
            },
            "controllerAccountId" : {
              "type" : "string",
              "description" : "Controller that can unlock the escrow."
            },
            "from" : {
              "$ref" : "#/components/schemas/HoldingSelector",
              "description" : "Expression for holdings to select."
            },
            "fromAccountId" : {
              "type" : "string",
              "description" : "The account to select holdings from."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "requesterIsController" : {
              "type" : "boolean",
              "description" : "Is the requester the controller (as opposed to the holder)?"
            }
          }
        } ],
        "description" : "Cancel selected escrowed holdings.\n The `from` holding selector allows multiple escrowed holdings to be selected given the same controller\n and holder account id. The selected holdings will be 'unlocked' and control returned to the holder.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `CancelEscrowedHoldingsRequest`, assigned by either:\n - the request account in the `fromAccountId` field, if `requesterIsController` is set to `false`, or\n - the request account in the `controllerAccountId` field, if the `requesterIsController` is set to `true`.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ValueHasTooManyDigits] | An amount in the holding selector exceeds maximum precision. |\n | [NonPositiveTransferAmount] | An amount in the holding selector is negative or zero. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InsufficientHoldings] | The holding selector did not yield any escrowed holdings. |\n | [EscrowNotFound] | An escrow ID referenced in an [EscrowAmount] does not exist. |\n | [HoldingAccessDenied] | The specified holding is not owned by the requester's account. |\n | [HoldingsMustBeSameProduct] | Referenced holdings must be from the same product. |\n | [HoldingIsEscrowed] | An attempt was made to select an 'input' holding that was already locked. |\n | [HoldingIsUnassigned] | An attempt was made to select an 'input' holding that was not assigned yet. |\n | [HoldingIsNotUnassigned] | An attempt was made to assign a holding that was already assigned. |\n | [QuantityOverflow] | The exact quantity computed overflows its type. |\n | [NotMultipleOfUnitAmount] | The amount specified needs to be an integer multiple of the `unitAmount` of the product item. |",
        "required" : [ "controllerAccountId", "from", "fromAccountId", "requesterIsController", "type" ]
      },
      "CancelPendingTransactionRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Cancellation attributes"
            },
            "byAccountId" : {
              "type" : "string",
              "description" : "Request account id for the transaction request. (i.e. account that 'owns' the pending transaction)"
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "txId" : {
              "type" : "string",
              "description" : "Unique transaction id of the pending transaction"
            }
          }
        } ],
        "description" : "Cancel a pending transaction request.\n\n This transaction request is processed by the Wallet API itself and not forwarded to the mint-service. Therefore, it\n must be submitted to the [CoreWalletApi.cancelSignature] endpoint instead of the normal transaction endpoints.\n\n The attributes set on on the cancel request are persisted and visible to the request account and other signatories\n using the [CoreWalletApi.listPendingTransactions] and [CoreWalletApi.listPendingSignatures] endpoints.\n\n #### Transaction permission\n\n This transaction request can be submitted by any access key that has signed the pending transaction, or any possible\n signatory of the pending transaction. Even an access key with SECONDARY access can still submit this request with only\n its signature.\n\n Alternatively, the transaction request requires `Request` permission for transaction type `CancelPendingTransactionRequest`, assigned by the\n request account in the `byAccountId` field.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The access key is not a signatory of the pending transaction and the `byAccountId` request account did not grant permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction or provider attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [TransactionNotFound] | Referenced transaction does not exist. |",
        "required" : [ "byAccountId", "txId", "type" ]
      },
      "CertifiedBlockSignature" : {
        "type" : "object",
        "properties" : {
          "certificates" : {
            "type" : "array",
            "description" : "Conductor certificates that authorizes this processor (signature on public key data).",
            "items" : {
              "$ref" : "#/components/schemas/BlockSignatureData"
            }
          },
          "signature" : {
            "$ref" : "#/components/schemas/BlockSignatureData",
            "description" : "Signature by processor that signed the block."
          },
          "signer" : {
            "$ref" : "#/components/schemas/BlockPublicKeyData",
            "description" : "Public key information for the signer."
          },
          "trustAnchors" : {
            "type" : "array",
            "description" : "Trust anchor for processor certificates, verify using out-of-band resources.",
            "items" : {
              "$ref" : "#/components/schemas/BlockPublicKeyData"
            }
          }
        },
        "required" : [ "certificates", "signature", "signer", "trustAnchors" ]
      },
      "CoreConfigData" : {
        "type" : "object",
        "description" : "The config response contains the configured authentication providers as well as the configuration for public content\n and websocket connections.",
        "properties" : {
          "accessTokenMaxValidityMillis" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The maximum validity of access-key-signed tokens."
          },
          "authConfig" : {
            "type" : "array",
            "description" : "Configurations for enabled identity providers.",
            "items" : {
              "$ref" : "#/components/schemas/AuthConfig"
            }
          },
          "marketUrl" : {
            "type" : "string",
            "description" : "Location of the default market configured for this CorTenX instance."
          },
          "publicContentConfig" : {
            "$ref" : "#/components/schemas/PublicContentConfig",
            "description" : "Configuration of the public content repository."
          },
          "systemId" : {
            "type" : "string",
            "description" : "Unique identifier for this Core instance."
          },
          "wsUrl" : {
            "type" : "string",
            "description" : "Websocket URL to connect to for asynchronous updates."
          }
        },
        "required" : [ "accessTokenMaxValidityMillis", "publicContentConfig", "systemId" ]
      },
      "CoreErrorResponse" : {
        "type" : "object",
        "description" : "Body for HTTP error responses.",
        "properties" : {
          "error" : {
            "type" : "string",
            "description" : "HTTP error reason."
          },
          "errorCode" : {
            "type" : "string",
            "description" : "\nFor sub-system `MINT`:\n\n- `AccessTypeNotAllowed`: The access type is only allowed for account groups owned by the Issuer Admin account.\n- `AccessUpdateCausingPermanentAccessLossNotAllowed`: The access update request causes permanent access loss to the target account.\n- `AccessUpdateContainsDuplicateAccountKey`: The access update request contains duplicate account ids.\n- `AccountGroupIsDeleted`: The selected account group has been deleted.\n- `AccountGroupNotFound`: The requested account group does not exist.\n- `AccountIsAlreadyMember`: The added account is already a member of the group.\n- `AccountIsNotMember`: The removed account is not a member of the group.\n- `AttributeNameExists`: An attempt was made to define an attribute with a name that is already defined.\n- `AttributeTagExists`: An attempt was made to define an attribute with a tag that is already defined.\n- `AttributeTagNotAllowed`: The attribute tag must be 0.\n- `BakeIntoItemNotHeld`: The bake request account has no holdings of the destination product item.\n- `BakedHoldingIsUsed`: The selected holding is already 'baked'.\n- `BakedHoldingNotUnderlying`: Holding being baked is not an underlying of the destination product item.\n- `ControllerAccessDenied`: The controller of an escrow did not grant permission for the escrow request.\n- `DeflationModeNotAllowedForProductItem`: The requested deflation mode is not allowed for a product item. Ensure that `Deflate` is not selected for non-inflatable items.\n- `EntityAlreadyUpdated`: This transaction already updated this entity.\n- `EntityNotFound`: The entity/product/item was not found.\n- `EnumAlreadyExists`: The enumerated value already exists.\n- `EnumValueNotFound`: The enumerated value does not exist.\n- `EscrowNotFound`: The combination of `escrowId`, `holderAccountId`, and `controllerAccountId` could not (any longer) be found.\n- `HasProductItems`: The product cannot be deleted because it still has product items.\n- `HoldingAccessDenied`: The specified holding is not owned by the requestor's account.\n- `HoldingIsAlreadyWithIssuer`: An attempt was made to reassign a holding that was already with the issuer of the product.\n- `HoldingIsEscrowed`: An attempt was made to select an 'input' holding that was already locked.\n- `HoldingIsNotUnassigned`: An attempt was made to assign a holding that was already assigned.\n- `HoldingIsNotWithIssuer`: The product item still has holdings with non-issuer accounts.\n- `HoldingIsSpent`: A holding was referenced that has already been spent.\n- `HoldingIsUnassigned`: An attempt was made to select an 'input' holding that was not assigned yet.\n- `HoldingsMustBeSameProduct`: The `HoldingSelector` selected holdings that are not for the same product. When specifying existing holding ids in a holding selector, ensure that they are holdings of product items of the same product.\n- `IncorrectIssuer`: The requesting account is not an issuer of the product or item.\n- `IncorrectVersion`: An attempt was made to update an entity's attributes with an incorrect current version. Ensure that the attribute update request is based on the most recent entity version.\n- `InflationModeNotAllowedForProductItem`: The requested inflation mode is not allowed for a product item. Ensure that `Inflate` is not selected for non-inflatable items.\n- `InitialIndexNotAllowed`: An inflatable product item may not contain an initial index.\n- `InitialIndexNotUnique`: The supplied index is invalid/not unique.\n- `InsufficientAvailableToAssign`: Insufficient product items were provided to re-assign the requested holdings.\n- `InsufficientHoldings`: The account has insufficient holdings to complete the transaction.\n- `InternalError`: An (unexpected) internal error occurred while processing the transaction. Try again when things have stabilized.\n- `InvalidAmount`: Product item requires an specific amount.\n- `InvalidRequest`: The request failed validation and/or configured rules. This transaction error is an indication that upstream components failed to properly validate the request and may be penalized with velocity checks.\n- `InvalidUnitAmount`: The `unitAmount` specified cannot be represented with the product's `maxDecimalPos`.\n- `IssuerAccessDenied`: The system administrator did not grant 'issuer' permission for the request.\n- `NotInitialized`: The system has not caught up with the block storage yet. Resend the request at a later time.\n- `NotMultipleOfUnitAmount`: The amount specified needs to be an integer multiple of the configured `unitAmount`\n- `PrecisionExceedsMaxDecimalPos`: The quantity specified exceeds the `maxDecimalPos` of the product.\n- `ProductAccessDenied`: The issuer of the product did not grant permission for a transfer or issuance.\n- `ProductCantFractionalize`: This product doesn't allow fractionalizable product items.\n- `ProductCantInflate`: This product doesn't allow inflatable product items.\n- `ProductCantSpendUnassigned`: Spending `Unassigned` holdings is not allowed for this product.\n- `ProductIsDeleted`: This product doesn't allow any interaction as it is deleted.\n- `ProductItemCantInflate`: An inflate transaction was attempted on a product item that does not allow inflation.\n- `ProductItemIsDeleted`: The referenced product item is deleted.\n- `ProductItemNotFound`: The referenced product item does not exist.\n- `ProductItemRequiresUnderlying`: Creating a product item for this product requires a baked holding for each of the required products.\n- `ProductItemsMustBeSameProduct`: When re-assigning holdings to a different Product Item, the product item must be of the same product.\n- `ProductNotFound`: The referenced product does not exist.\n- `QuantityOverflow`: The exact quantity computed overflows its type.\n- `RequestAccessDenied`: The request was not signed by parties with sufficient access.\n- `RequiresInitialAmount`: Non-inflatable product items require an initial amount.\n- `SecurityGroupIsDeleted`: The selected security group has been deleted.\n- `SecurityGroupNotFound`: The requested security group does not exist.\n- `TransactionHasBeenProcessed`: Duplicate transaction id. A transaction with this id has already been processed.\n- `UnderlyingNotAllowedForUnassigned`: Unassigned product items cannot have underlying baked holdings.\n- `UnsupportedTransactionRequest`: The type of transaction request was not supported by this system.\n\nFor sub-system `API`:\n\n- `AccessConditionFailed`: An access condition does not match.\n- `AccessTokenExpired`: The access token has expired.\n- `AccessTokenNotValidYet`: The access token is not valid yet.\n- `AccountGroupNotFound`: The requested account group does not exist.\n- `AttributeIsNotEnum`: The attribute trying to update is not an enum\n- `AttributeNotAllowed`: The request contains attributes that are not allowed.\n- `AttributeNotFoundByName`: An attribute was referenced, but no definition could be found.\n- `AttributeNotFoundByTag`: An attribute was referenced, but no definition could be found.\n- `BlockNotFound`: Request block does not exist.\n- `BothAddAndRemove`: The request removes an entity that it just added (minimal encoding).\n- `ControllerAccessDenied`: The controller of an escrow did not grant permission for the escrow request.\n- `CriteriaNotSupported`: The criteria is not supported for a specific attribute type.\n- `DisabledEnum`: The enum is disabled and cannot be used\n- `DuplicateAccountGroupId`: The set of account group ids contains duplicates.\n- `DuplicateAccountId`: The set of account ids contains duplicates.\n- `DuplicateAttributeRule`: A [io.trovio.core.data.meta.AttributeUseData] contained more than one entry for the same attribute. Attributes can only be defined once. If multiple attribute values are required, use a list-attribute.\n- `DuplicateEntry`: The request contains a duplicate set entry.\n- `DuplicateEnumValueDef`: The list of enum value definitions contains a duplicate name or ordinal.\n- `DuplicateGroupBy`: The list of groupings contains a duplicate field.\n- `DuplicateMetadataDefinitionName`: A metadata definition with the given name, but different configuration already exists for this issuer.\n- `DuplicateMetadataValue`: Duplicate value for metadata that requires unique values.\n- `DuplicateRequester`: The signature list contains more than one signature (pair) for the same requester.\n- `DuplicateSecurityGroupId`: The set of security group ids contains duplicates.\n- `DuplicateUnderlyingProduct`: An [io.trovio.core.api.tx.CreateProductRequest] contained more than one entry for the same underlying product.\n- `EmptyOptionalList`: List property should be absent instead of empty (minimal encoding).\n- `EmptyRequest`: The request does not have any effect.\n- `HoldingNotFound`: The requested holding id does not exist.\n- `IncompleteTransactionRequest`: The transaction request requires additional signatures.\n- `IncorrectAccountId`: The `accountId` or `accessKeyId` provided does not match the public key.\n- `IncorrectRequestMessage`: The request message type is invalid for this endpoint.\n- `IncorrectSignature`: A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed).\n- `IncorrectSignatureOrder`: A signature was out of order (e.g. a SECONDARY before a PRIMARY).\n- `IncorrectSignatureType`: The signature type is not supported for the key type.\n- `IncorrectSystemId`: The signatures provided are not valid for this system.\n- `IncorrectTransactionId`: The transaction id in the request does not match the hash of the encoded transaction data.\n- `InitiatorHasHigherAccess`: The pending request was initiated by a user with higher access.\n- `InvalidAccessToken`: The access token was not constructed correctly.\n- `InvalidAccessTokenValidity`: The validity of the access token exceeds the configured limit.\n- `InvalidAttributeRule`: A validation rule's definition (in an attribute definition) is not valid. For example, if the minimum value of an attribute is higher than the maximum value.\n- `InvalidAttributeValue`: An attribute's value does not match the requirements of its definition.\n- `InvalidCriteria`: The criteria are mutually exclusive and will produce no results.\n- `InvalidCurrentState`: A query for current state is filtering by a state that is not a current state.\n- `InvalidDecimalPrecision`: Number of digits is negative or higher than 18.\n- `InvalidEnum`: The ordinal or name referenced as an enum value is not valid.\n- `InvalidGroupBy`: The list of groupings contains invalid field names or groupings.\n- `InvalidNameFormat`: The provided name field does not meet naming requirements.\n- `InvalidNegativeIndex`: Index if specified cannot be negative.\n- `InvalidParameter`: The parameter is invalid for some reason.\n- `InvalidParameterValue`: A parameter value provided (e.g. in a criterion) cannot be parsed to the required type.\n- `InvalidSetAttributeRequest`: Set attributes has no attributes to set or remove.\n- `InvalidSignature`: The signature data supplied was not a valid signature for the key type.\n- `InvalidSortCriterion`: The sort criterion could not be parsed. Sort criteria have to be formatted as `name` or `+name` (ascending) or `-name` (descending)\n- `InvalidSpentState`: A query for historic state is filtering by a state that is not a historic state.\n- `InvalidSumField`: The chosen field cannot be used in sum queries\n- `InvalidTagNumber`: A create or update request was made for an invalid tag number.\n- `InvalidValue`: Field value is invalid.\n- `InvalidValueCriterion`: The value criterion expression could not be parsed.\n- `InvalidYaborEncoding`: Invalid Yabor encoding encountered.\n- `IssuerAccessDenied`: The system administrator did not grant 'issuer' permission for the request.\n- `IssuerMetadataCannotBeSet`: Issuer specific metadata values cannot be set in user-metadata context.\n- `LimitTooLow`: The result limit for the given query is too low to be able to respond to this request.\n- `ListExceedsLimit`: The number of items in a list exceeds the configured limit.\n- `MetadataDefinitionIssuerIdDoesNotMatchProvided`: Existing metadata issuer does not match provided issuer ID.\n- `MetadataDefinitionNotFound`: Metadata with the given identifier does not exist, or cannot be accessed by the current user.\n- `MetadataEmptyValue`: The metadata value is empty.\n- `MetadataEntityReferenceDoesNotMatchDefinition`: Metadata entity reference provided does not match metadata definition entity reference type.\n- `MetadataEntryNotFound`: Metadata value entry could not be found.\n- `MetadataFileDownloadFailed`: Metadata file download has failed.\n- `MetadataFileProvidedHashDoesNotMatchComputed`: Provided hash does not match computed value.\n- `MetadataFileSizeExceedsLimit`: The metadata file size exceeds the limit.\n- `MetadataFileUploadFailed`: Metadata file upload has failed.\n- `MetadataInvalidFileName`: The metadata file name is invalid.\n- `MetadataJsonValueNotValid`: The JSON provided is invalid.\n- `MetadataJsonValueTooLong`: The metadata JSON value provided is too long.\n- `MetadataMissingUploadedFileIdentifier`: Metadata uploaded file identifier missing.\n- `MetadataReferenceIsInvalid`: Metadata reference is invalid.\n- `MetadataReferenceListExceedsLimit`: Number of provided metadata references exceeds limit.\n- `MetadataReferencedEntityNotFound`: The referenced entity was not found.\n- `MetadataTypeIndexingNotSupported`: Indexing is not available for this metadata value type.\n- `MetadataValueTypeDoesNotMatchDefinition`: Metadata value is of different type than the metadata definition it references.\n- `MinCountLargerThanMaxCountValue`: The minCount value cannot be larger than the maxCount value.\n- `MissingAttributeRequired`: The request is missing a required attribute.\n- `MixingAddRemoveWithSet`: The request mixes the add/remove pattern with the 'set' pattern.\n- `NegativeInitialAmount`: The initial amount cannot be negative.\n- `NoAccountAccess`: The access key has no access to the requested account.\n- `NoPossibleApprovers`: No possible approvers can be found for the initiated transaction request.\n- `NonPositiveTransferAmount`: The transfer amount cannot be negative or zero.\n- `NonPositiveUnitAmount`: The unit amount cannot be negative or zero.\n- `NotAListAttribute`: The referenced attribute is not a list.\n- `NotFound`: An entity was not found.\n- `NotInitialized`: The system has not been initialized yet.\n- `NotSameHierarchy`: The conditions in the permission statement are for different context hierarchies, the statement can never match.\n- `NotificationAccessDenied`: No permission to access this notification topic.\n- `PendingRequestSuperseded`: There is already a pending request for this transaction that has progressed further.\n- `ProductAccessDenied`: The issuer of the product did not grant permission for a transfer or issuance.\n- `ProductItemNotFound`: No product item matches the requested product item id.\n- `ProductNotFound`: No product matches the requested product id.\n- `QueryTooBroad`: Additional criteria need to be applied to this query, as the result set would be too large.\n- `RequestAccessDenied`: The request was not signed by parties with sufficient access.\n- `RequestAccountDoesNotMatch`: The referenced request account is not the actual request account.\n- `ResponseTimeout`: The endpoint did not receive a transaction response within the configured time.\n- `SecurityGroupNotFound`: The requested security group does not exist.\n- `SortingByListAttributeUnsupported`: Sorting by a list type attribute is not supported\n- `StringContainsInvalidCharacter`: The provided input contains non-printable Unicode characters or non-Unicode characters.\n- `StringLengthExceedsMaximum`: The provided input exceeds the maximum allowed string length.\n- `SystemAccessDenied`: No access allowed for this user account.\n- `SystemAccessSuspended`: The system state does not allow this access at the moment.\n- `TooManyEntriesPerRequest`: Number of allowed entries for a batched operation has been exceeded.\n- `TooManyRequests`: Too many concurrent requests. Back off and try again later.\n- `TransactionNotFound`: The request transaction `block:index` was not found.\n- `TransactionTypeNotAllowed`: The request type is not allowed.\n- `UnexpectedMessageType`: The message received was not the expected type.\n- `UnsupportedAttributeType`: The specified attribute type is not supported by this request.\n- `UnsupportedDeflationMode`: The specified deflation mode is not supported by this request type.\n- `UnsupportedField`: Sort was requested for a field that does not support sorting or was not grouped by.\n- `UnsupportedMetadataEntityReferenceType`: Provided metadata entity reference type is not allowed.\n- `UnsupportedSignatureVersion`: A signature was presented that has a version that is not supported by this implementation.\n- `UpdateEnumNotAllowed`: The account id is not allowed to update the enum\n- `UserMetadataCannotBeIndexed`: User specific metadata cannot be indexed.\n- `UserMetadataCannotBePublic`: User specific metadata cannot be public.\n- `UserMetadataCannotBeSet`: User specific metadata values cannot be set in issuer-metadata context.\n- `UserNotFound`: The user identified by the authorization token was not found. First invoke the `getUserAccountData` endpoint to ensure user data is available.\n- `ValueHasTooManyDigits`: Provided value has too many digits to be successfully persisted.\n\nFor sub-system `WALLET`:\n\n- `AccessKeyIdIncorrectForSignatureRequest`: The provided access key id does not match the authenticated user's account id.\n- `AccountNotFound`: Request specified unknown account.\n- `CancelRequestAccessDenied`: Account does not have the authority to cancel pending request.\n- `IdentityProviderUnknown`: Identity provider does not exist.\n- `IdentityProviderVersionInvalid`: Identity provider request version does not match repository version.\n- `IdentityProviderWithMatchingIssuerUriExists`: An identity provider with this issuer URI already exists.\n- `IdentitySubjectIdInvalid`: The provided identity subject ID was invalid.\n- `IdentityTenantAlreadyDeleted`: The identity tenant is already deleted.\n- `IdentityTenantVersionInvalid`: Identity tenant request version does not match repository version.\n- `IncorrectEndpoint`: The signed request was sent to the incorrect endpoint.\n- `InternalError`: An internal error occurred during execution.\n- `InvalidStartTime`: Start time was before the current time.\n- `PendingTransactionNotFound`: The pending transaction being cancelled or deleted does not exist.\n- `PendingTransactionRequestRejected`: Transaction was rejected by a signatory while in the pending transaction queue.\n- `SaveTransactionProofDisabled`: The save transaction proof to public content functionality is disabled.\n- `TenantIdUnknown`: Request specified unknown tenant ID.\n- `TenantOwnerIncorrect`: The provided tenant owner is incorrect.\n- `TenantUsersOrProvidersNotEmpty`: The tenant cannot be deleted because users and/or identity providers are associated with it.\n- `TokenIssuerUnknown`: The provided token was issued by an unknown identity provider.\n- `TransactionAlreadyProcessed`: The wallet transaction request was already processed.\n\nFor sub-system `BLOCK`:\n\n- `AccessKeyNotFound`: An access key was referenced that was not found.\n- `BlockAlreadyInStorage`: The block persist operation was called for a block number that is already in block storage.\n- `BlockNotFound`: Required block does not exist.\n- `CertificateCanNotBeVerified`: The conductor certificate could not be verified.\n- `CertificateNotFound`: A key was referenced for which the certificate could not be found.\n- `IncorrectBlockHash`: The previous block hash does not match the next block's header.\n- `IncorrectBodyHash`: The proof's computed body hash does not match the block header.\n- `IncorrectKeyId`: The `keyId` does not match the public key\n- `IncorrectPublicKeyId`: When verifying a signature, the id of the public key supplied did not match the id supplied with the signature data.\n- `IncorrectRequestSignatureHash`: The hash of the request signatures does not match the provided request signature hash bytes.\n- `IncorrectSignature`: A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed)\n- `IncorrectSignatureType`: The signature type is not supported for the key type.\n- `IncorrectTransactionHash`: The proof details do not match the provided transaction hash.\n- `IncorrectTransactionId`: The request details do not match the transaction id.\n- `InvalidCertificate`: The certificate could not be parsed.\n- `InvalidSignature`: The signature data supplied was not a valid signature for the key type.\n- `InvalidTransactionHashes`: The transaction hashes in the block footer do not match the actual transaction hashes.\n- `TransactionIndexOutOfRange`: The proof does not contain sufficient merkle nodes for the given transaction index.\n- `TrustAnchorNotFound`: The proof did not contain a public key for a referenced trust anchor.\n\nFor sub-system `METADATA`:\n\n- `MetadataFileDownloadFailed`: Metadata of type file download failed\n- `OperationFailed`: Generic operation failed, used when reason of failure is unknown\n        "
          },
          "message" : {
            "type" : "string",
            "description" : "Optionally, an additional error message. The message property will not be populated in production systems\n if the status is `400` (Bad Request) or `403` (Forbidden)."
          },
          "path" : {
            "type" : "string",
            "description" : "HTTP path for error."
          },
          "status" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "HTTP error status."
          },
          "subSystem" : {
            "type" : "string",
            "description" : "The subsystem indicates the error code enum used for the `errorCode` field.\n - `API`: API invocation error\n - `MINT`: Transaction processing error\n - `WALLET`: Wallet function error\n - `BLOCK`: Block consistency error\n - `METADATA`: Metadata processing error"
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Timestamp of error (if available)"
          },
          "transactionId" : {
            "type" : "string",
            "description" : "Transaction id if known."
          }
        },
        "required" : [ "errorCode", "status", "subSystem" ]
      },
      "CoreNotification" : {
        "description" : "Notification body. Each notification type has a corresponding notification data class.\nThe `type` field specifies the notification type and determines the fields of the notification.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AccessKeysCreatedNotification" : "#/components/schemas/AccessKeysCreatedNotification",
            "AccountGroupAssignedNotification" : "#/components/schemas/AccountGroupAssignedNotification",
            "EscrowCancelledNotification" : "#/components/schemas/EscrowCancelledNotification",
            "EscrowReceivedNotification" : "#/components/schemas/EscrowReceivedNotification",
            "HoldingAdjustedNotification" : "#/components/schemas/HoldingAdjustedNotification",
            "HoldingAssignedNotification" : "#/components/schemas/HoldingAssignedNotification",
            "IdentityProviderDeletedNotification" : "#/components/schemas/IdentityProviderDeletedNotification",
            "IdentityProviderSetNotification" : "#/components/schemas/IdentityProviderSetNotification",
            "IdentityTenantDeletedNotification" : "#/components/schemas/IdentityTenantDeletedNotification",
            "IdentityTenantSetNotification" : "#/components/schemas/IdentityTenantSetNotification",
            "SecurityGroupAssignedNotification" : "#/components/schemas/SecurityGroupAssignedNotification",
            "SecurityGroupUpdatedNotification" : "#/components/schemas/SecurityGroupUpdatedNotification",
            "SignatureRequestedNotification" : "#/components/schemas/SignatureRequestedNotification",
            "TransactionCancelledNotification" : "#/components/schemas/TransactionCancelledNotification",
            "TransactionDeletedNotification" : "#/components/schemas/TransactionDeletedNotification",
            "TransactionFailedNotification" : "#/components/schemas/TransactionFailedNotification",
            "TransactionPendingNotification" : "#/components/schemas/TransactionPendingNotification",
            "TransactionSuccessNotification" : "#/components/schemas/TransactionSuccessNotification",
            "TransferReceivedNotification" : "#/components/schemas/TransferReceivedNotification"
          }
        },
        "properties" : {
          "type" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      },
      "CreateAccessKeysRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the request."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "owner" : {
              "type" : "string",
              "description" : "The owner of the tenant where the access keys are created.",
              "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
            },
            "subClaims" : {
              "type" : "array",
              "description" : "The list of subjects for which to create access keys.",
              "example" : "[subject_id_1, subject_id_2, subject_id_3]",
              "items" : {
                "type" : "string"
              }
            },
            "tenantId" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "The tenant ID for the access keys.",
              "example" : 1
            }
          }
        } ],
        "description" : "Request object for creating access keys.\n A request can set up access keys for up to 100 subjects within a single tenant.\n\n This transaction request is processed by the Tenant API itself and not forwarded to the mint-service. Therefore, it\n must be submitted to the [CoreTenantApi.identityProviderConfigRequest] endpoint instead of the normal transaction endpoints.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `CreateAccessKeysRequest`, assigned by the\n request account in the `owner` field.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `owner` account did not grant permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction or provider attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [TooManyEntriesPerRequest] | A maximum of 100 subject claims (subClaims) can be processed in one transaction. |\n | [TenantIdUnknown] | Tenant does not exist. |\n | [TenantOwnerIncorrect] | The referenced owner is not the owner of the referenced tenant. |",
        "required" : [ "owner", "subClaims", "tenantId", "type" ]
      },
      "CreateAccountGroupRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "accessType" : {
              "type" : "string",
              "description" : "When set, the access type for the new account group. The owner can set any access type,\n except [UserAccessType.OperatorAccess] which can only be set if the owner of the group\n is the Issuer Admin account.",
              "enum" : [ "NoAccessType", "AuditAccess", "UserAccess", "AdminAccess", "OperatorAccess" ]
            },
            "accountIds" : {
              "type" : "array",
              "description" : "Initial list of accounts to add to this group.",
              "items" : {
                "type" : "string"
              }
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Transaction attributes."
            },
            "isVisibleToMembers" : {
              "type" : "boolean",
              "description" : "If true, this account group can be returned in a `ListVisibleAccountGroups` request."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "ownerId" : {
              "type" : "string",
              "description" : "Issuer that becomes the owner of the account group."
            },
            "visibleToMembersOf" : {
              "type" : "array",
              "description" : "Update the 'visible to members of' account group.\n There is only one 'visible to members of' account group, so the list can only contain 0 or 1 entries.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Create a new account group.\n The account group will receive a block:index identifier in the response.\n An initial list of accounts can be added upon creation.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `CreateAccountGroupRequest`, assigned by the\n request account in the `ownerId` field.\n\n In addition, the Issuer Admin account must have assigned `Issuer` permission to the `ownerId` account for the request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `ownerId` account did not grant permission for the request. |\n | [IssuerAccessDenied] | The Issuer administrator did not grant `Issuer` permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [DuplicateAccountId] | The list of `accountIds` contains duplicates. |\n | [ListExceedsLimit] | The `visibleToMembersOf` list is limited to a single account group ID. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [AccountGroupIsDeleted] | The account group referenced in `visibleToMembersOf` has been deleted. |",
        "required" : [ "accountIds", "ownerId", "type" ]
      },
      "CreateAccountRequest" : {
        "type" : "object",
        "properties" : {
          "initialAccess" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/AccountAccessData"
            }
          }
        },
        "required" : [ "initialAccess" ]
      },
      "CreateAccountResponse" : {
        "type" : "object",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "Account id created"
          },
          "txId" : {
            "type" : "string",
            "description" : "Informational transaction id, the transaction id is actually the hash of the request."
          }
        },
        "required" : [ "accountId", "txId" ]
      },
      "CreateEscrowRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Extra attributes for the order."
            },
            "controllerAccountId" : {
              "type" : "string",
              "description" : "Controller that can unlock the escrow."
            },
            "from" : {
              "$ref" : "#/components/schemas/HoldingSelector",
              "description" : "Expression for holdings to select."
            },
            "fromAccountId" : {
              "type" : "string",
              "description" : "Account requesting the offering of its holders."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            }
          }
        } ],
        "description" : "We can probably come up with a more generic name for this request, but essentially it locks holdings to an\n escrow controller. The (remainder of) these holdings can be cancelled by both the from account and/or the controller.\n The controller can 'trade' these holdings against other holdings in an atomic transaction.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `CreateEscrowRequest`, assigned by the\n request account in the `fromAccountId` field.\n\n In addition, if `Controller` security groups are assigned by the controller account to the request account, they need\n to grant the `Controller` permission for the request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The request account did not grant permission for the request. |\n | [ControllerAccessDenied] | The prospective controller did not grant permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ValueHasTooManyDigits] | An amount in the holding selector exceeds maximum precision. |\n | [NonPositiveTransferAmount] | An amount in the holding selector is negative or zero. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InsufficientHoldings] | The holding selector did not select any holdings. |\n | [QuantityOverflow] | The exact quantity computed overflows its type. |\n | [HoldingAccessDenied] | The specified holding is not owned by the requestor's account |\n | [HoldingsMustBeSameProduct] | Referenced holdings must be from the same product |\n | [HoldingIsEscrowed] | An attempt was made to select an 'input' holding that was already locked |\n | [HoldingIsUnassigned] | An attempt was made to select an 'input' holding that was not assigned yet |\n | [HoldingIsNotUnassigned] | An attempt was made to assign a holding that was already assigned |\n | [NotMultipleOfUnitAmount] | The amount must be an integer multiple of the `unitAmount` of the product item. |",
        "required" : [ "controllerAccountId", "from", "fromAccountId", "type" ]
      },
      "CreateIdentityProviderRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "account" : {
              "type" : "string",
              "description" : "Tenant owner account. The account field here has to be the owner of the tenant referenced in this same request.\n It is also the account that has to be the requesting account, as only the tenant owner can effect changes within the tenant.",
              "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
            },
            "additionalApplicationIds" : {
              "type" : "array",
              "description" : "Additional application IDs (used to set more than one applicationId)",
              "example" : "XYZ,ABC",
              "items" : {
                "type" : "string"
              }
            },
            "applicationId" : {
              "type" : "string",
              "description" : "Application ID (the aud claim of the access token will be validated against this value, an empty value will disable this validation).",
              "example" : "XYZ"
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the request."
            },
            "clientId" : {
              "type" : "string",
              "description" : "Client ID (used for frontend login).",
              "example" : "XYZ"
            },
            "displayName" : {
              "type" : "string",
              "description" : "Display name for UI.",
              "example" : "XYZ"
            },
            "enabled" : {
              "type" : "boolean",
              "description" : "Enable or not this identity provider (not effective if the issuerUri is used in other identity providers and aud claim validation is disabled).",
              "example" : true
            },
            "identityProviderAttributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the identity provider."
            },
            "issuerUri" : {
              "type" : "string",
              "description" : "Issuer URI (must provide an openid discovery endpoint).",
              "example" : "https://my-identity-provider-domain.dev.io/v2.0"
            },
            "migrateFromSubjectIdClaim" : {
              "type" : "string",
              "description" : "Name of the claim the Identity Provider is migrating from when updating the [subjectIdClaim].\n When updating the [subjectIdClaim], a migration from the previous or default [subjectIdClaim] might be needed\n if there are already users authenticating with this Identity Provider.",
              "example" : "sub"
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "responseType" : {
              "type" : "string",
              "description" : "Authentication flow response type. One of or combination of: id_token, none, code, token (except none, values can be combined). See https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#OAuthResponseTypesReg",
              "example" : "code"
            },
            "scopes" : {
              "type" : "array",
              "description" : "Scopes used in openid authentication/authorization.",
              "example" : "openid,email",
              "items" : {
                "type" : "string"
              }
            },
            "subjectIdClaim" : {
              "type" : "string",
              "description" : "Name of the claim used by the identity provider token to identity a user. If none is set, the default will be \"sub\".",
              "example" : "oid"
            },
            "tenantId" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "Internal tenant id (used as the main key in grouping users under a tenant).",
              "example" : 1
            },
            "visible" : {
              "type" : "boolean",
              "description" : "Control the visibility of this identity provider via the configuration endpoint. Setting an identity provider to visible=false does not disable it. Defaults to \"true\".",
              "example" : true
            }
          }
        } ],
        "description" : "Tenant owner creates a new identity provider.\n\n This transaction request is processed by the Tenant API itself and not forwarded to the mint-service. Therefore, it\n must be submitted to the [CoreTenantApi.identityProviderConfigRequest] endpoint instead of the normal transaction endpoints.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `CreateIdentityProviderRequest`, assigned by the\n request account in the `account` field.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `account` account did not grant permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction or provider attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction or provider attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction or provider attribute was not defined. |\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [TenantOwnerIncorrect] | The referenced tenant owner is not the owner of the referenced tenant  |\n | [TenantIdUnknown] | Referenced tenant does not exist  |\n | [IdentityProviderWithMatchingIssuerUriExists] | An identity provider with this issuer URI already exists. |",
        "required" : [ "account", "clientId", "displayName", "enabled", "issuerUri", "responseType", "scopes", "tenantId", "type" ]
      },
      "CreateIdentityTenantRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "account" : {
              "type" : "string",
              "description" : "Account who will own this tenant. This account will be the only one who can effect changes within this tenant.",
              "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the request."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "tenantAttributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the tenant."
            },
            "tenantDisplayName" : {
              "type" : "string",
              "description" : "A display name for this tenant.",
              "example" : "My identity tenant"
            }
          }
        } ],
        "description" : "Create a new identity tenant.\n\n This transaction request is processed by the Tenant API itself and not forwarded to the mint-service. Therefore, it\n must be submitted to the [CoreTenantApi.identityTenantConfigRequest] endpoint instead of the normal transaction endpoints.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `CreateIdentityTenantRequest`, assigned by the\n request account in the `account` field.\n\n In addition, the Issuer Administrator account must have assigned `Issuer` permission to the `account` account for the request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `account` account did not grant permission for the request. |\n | [IssuerAccessDenied] | The Issuer administrator did not grant `Issuer` permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction or tenant attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction or tenant attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction or tenant attribute was not defined. |\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|",
        "required" : [ "account", "tenantDisplayName", "type" ]
      },
      "CreateMetadataDefinitionsRequest" : {
        "type" : "object",
        "properties" : {
          "defs" : {
            "type" : "array",
            "description" : "List of metadata definitions to be created",
            "items" : {
              "$ref" : "#/components/schemas/MetadataDefCreateData"
            },
            "maxItems" : 2147483647,
            "minItems" : 1
          },
          "issuerId" : {
            "type" : "string",
            "description" : "Owner of metadata definitions to be created"
          }
        },
        "required" : [ "defs", "issuerId" ]
      },
      "CreateMetadataDefinitionsResponse" : {
        "type" : "object",
        "properties" : {
          "defs" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MetadataDefinitionData"
            }
          }
        },
        "required" : [ "defs" ]
      },
      "CreateProductItemRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Initial attributes (the issuer may change attributes using the SetAttributeRequest)."
            },
            "canFractionalize" : {
              "type" : "boolean",
              "description" : "Can this item be fractionalized?"
            },
            "canInflate" : {
              "type" : "boolean",
              "description" : "Can this item inflate/deflate on issue/burn?"
            },
            "initialAmount" : {
              "type" : "number",
              "description" : "Initial quantity (in product units) of this item. If the product item cannot inflate, this quantity cannot\n be changed."
            },
            "initialIndex" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "When presented, the product item will start indices at the given initial index, in quantity units.",
              "minimum" : 0
            },
            "isUnassigned" : {
              "type" : "boolean",
              "description" : "Is the an 'unassigned' product item that still needs to be assigned to a backed item."
            },
            "issuerId" : {
              "type" : "string"
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "productId" : {
              "type" : "string",
              "description" : "Unique id of the product to create the item for.",
              "example" : "44:11"
            },
            "toAccountId" : {
              "type" : "string",
              "description" : "Set an accountId to assign the new productItem initialAmount to."
            },
            "underlying" : {
              "type" : "array",
              "description" : "Baked underlying holdings linked to this product item. If the holdings or amounts are not baked yet, they will\n be baked in the request.",
              "items" : {
                "$ref" : "#/components/schemas/HoldingSelector"
              }
            },
            "unitAmount" : {
              "type" : "number",
              "description" : "Amount of product in each quantity unit."
            }
          }
        } ],
        "description" : "Create a new Product Item with initial holdings.\n\n The product item is created for the product owned by the issuer.\n The attributes in this request are the (initial) Product Item attributes, and have to satisfy the attribute rules\n configured in the Product.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `CreateProductItemRequest`, assigned by the\n request account in the `issuerId` field.\n\n If a `toAccountId` is specified, that account needs to be assigned `Product` permission by the product's issuer for\n the request.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ValueHasTooManyDigits] | An amount in the holding selector exceeds maximum precision. |\n | [NonPositiveTransferAmount] | An amount in the holding selector is negative or zero. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [NegativeInitialAmount] | The `initialAmount` cannot be negative. |\n | [NonPositiveUnitAmount] | The `unitAmount` cannot be negative or zero. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ProductIsDeleted] | Referenced product is deleted |\n | [ProductNotFound] | Referenced product not found |\n | [IncorrectIssuer] | The account in `issuerId` is not issuer of the referenced product. |\n | [ProductCantInflate] | Referenced product doesn't allow inflatable product items. |\n | [ProductCantFractionalize] | Referenced product doesn't allow fractionalizable product items. |\n | [InvalidUnitAmount] | The `unitAmount` specified cannot be represented with the product's `maxDecimalPos`. |\n | [RequiresInitialAmount] | Non-inflatable product items require an initial amount. |\n | [InitialIndexNotAllowed] | An inflatable product item cannot contain an initial index. |\n | [UnderlyingNotAllowedForUnassigned] | Unassigned product items cannot have underlying baked holdings. |\n | [ProductItemRequiresUnderlying] | Creating a product item for this product requires a baked holding for each of the required products. |\n | [InitialIndexNotUnique] | Initial index is less than next possible index. |\n | [MissingAttributeRequired] | Missing required attribute. |\n | [AttributeNotAllowed] | The request contains a forbidden attribute. |\n | [InvalidAttributeRule] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed)|\n | [InvalidEnum] | The ordinal or name referenced as an enum value is not valid. |\n | [DisabledEnum] | The referenced enum value is disabled. |",
        "required" : [ "canFractionalize", "canInflate", "initialAmount", "isUnassigned", "issuerId", "productId", "type", "unitAmount" ]
      },
      "CreateProductRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "assignAfterSeconds" : {
              "type" : "integer",
              "format" : "int64",
              "default" : 0,
              "description" : "Number of seconds to wait before auto-assigning.",
              "minimum" : 0
            },
            "assignIfAvailable" : {
              "type" : "boolean",
              "default" : true,
              "description" : "Automatically assign product items when they are/become available?"
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Additional attributes for this product."
            },
            "canFractionalize" : {
              "type" : "boolean",
              "default" : true,
              "description" : "Can product items be fractionalized."
            },
            "canInflate" : {
              "type" : "boolean",
              "default" : false,
              "description" : "Can normal product items allow inflation/deflation? 'Unassigned' product items can always allow inflation."
            },
            "canSpendUnassigned" : {
              "type" : "boolean",
              "default" : false,
              "description" : "Can unassigned holdings be already spent?"
            },
            "code" : {
              "type" : "string",
              "description" : "Immutable short 'currency' code for this product. Maybe later we'll add a meta-data attribute to override,\n but alternatively all holdings could be moved to a new product if required and the 'old' product retired.",
              "example" : "XYZ"
            },
            "fixedQuantity" : {
              "type" : "number",
              "description" : "Each product item will require this exact quantity."
            },
            "hasUniqueIndices" : {
              "type" : "boolean",
              "default" : false,
              "description" : "If true, ensure that product item indices are unique across the whole product. If no initialIndex is given for a\n product item, the system will assign the next available starting index. If false, each product item can have an\n arbitrary starting index (or zero)."
            },
            "issuerId" : {
              "type" : "string",
              "description" : "Issuer account that is creating the product.",
              "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
            },
            "itemAttributes" : {
              "type" : "array",
              "description" : "Allowed / required attributes for product items.",
              "items" : {
                "$ref" : "#/components/schemas/AttributeUseData"
              }
            },
            "maxDecimalPos" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "Maximum number of decimal digits to track for quantities of this product.",
              "example" : 8
            },
            "minDecimalPos" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "Minimum number of decimal digits to show for quantities of this product.",
              "example" : 0
            },
            "name" : {
              "type" : "string",
              "description" : "Internal 'default' name for this product. Other (internationalized) names can be attached to the product\n using metadata.",
              "example" : "Our XYZ product"
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "underlying" : {
              "type" : "array",
              "description" : "List of product ids for which holdings must be baked for each (assignable) product item.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Issuer creates a new product.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `CreateProductRequest`, assigned by the\n request account in the `issuerId` field.\n\n In addition, the Issuer Administrator account must have assigned `Issuer` permission to the `issuerId` account for the request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `issuerId` account did not grant permission for the request. |\n | [IssuerAccessDenied] | The Issuer administrator did not grant `Issuer` permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidDecimalPrecision] | Decimal position has to be between 0 and 18 |\n | [DuplicateUnderlyingProduct] | Duplicated underlying product |\n | [DuplicateAttributeRule] | Duplicated attribute |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ProductCantInflate] | Product cannot inflate if it has a fixed quantity. |\n | [PrecisionExceedsMaxDecimalPos] | Fixed quantity has a higher precision than the maximum allowed. |",
        "required" : [ "code", "issuerId", "maxDecimalPos", "minDecimalPos", "name", "type" ]
      },
      "CreateSecurityGroupRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Transaction attributes."
            },
            "data" : {
              "$ref" : "#/components/schemas/SecurityGroupPermissionData",
              "description" : "Initial permission set for this security group."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "ownerId" : {
              "type" : "string",
              "description" : "The owner of the security group."
            }
          }
        } ],
        "description" : "Create a new security group.\n The security group is created with initial permissions.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `CreateSecurityGroupRequest`, assigned by the\n request account in the `ownerId` field.\n\n In addition, the Issuer Administrator account must have assigned `Issuer` permission to the `ownerId` account for the request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `ownerId` account did not grant permission for the request. |\n | [IssuerAccessDenied] | The Issuer administrator did not grant `Issuer` permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | A permission statement has an empty conditions list, or one of the conditions has an empty set. |\n | [DuplicateEntry] | A permission statement has a condition with a list that contains duplicates. |\n | [NotSameHierarchy] | A permission statement combines conditions from different context hierarchies. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request is not expected to fail.",
        "required" : [ "data", "ownerId", "type" ]
      },
      "DecimalPosRule" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AttributeRule"
        }, {
          "type" : "object",
          "properties" : {
            "maxDecimalPos" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        } ],
        "description" : "Validate the scale of each BigDecimal element.",
        "required" : [ "maxDecimalPos" ]
      },
      "DefineAttributeRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "definition" : {
              "$ref" : "#/components/schemas/AttributeDefinitionData",
              "description" : "Attribute definition."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            }
          }
        } ],
        "description" : "Request to define an attribute.\n\n Previously, the system allowed requests to set the tag number for the attribute, this is no longer the case.\n From now on, the tag number in the attribute definition data must be zero and the system will automatically assign\n the next available tag number to the attribute definition.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `DefineAttributeRequest`, assigned by the\n request account in the `definition.createdBy` field.\n\n In addition, the Issuer Administrator account must have assigned `Issuer` permission to the `definition.createdBy` account for the request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `definition.createdBy` account did not grant permission for the request. |\n | [IssuerAccessDenied] | The Issuer administrator did not grant `Issuer` permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeRule] | A rule defined for the new attribute is not valid. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [AttributeNameExists] | Attribute name already exists. |\n | [InvalidTagNumber] | Attribute tag number has to be zero. |",
        "required" : [ "definition", "type" ]
      },
      "DeflateProductItemRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "from" : {
              "$ref" : "#/components/schemas/HoldingSelector",
              "description" : "Holdings to deflate. The holdings must be held by the issuer."
            },
            "issuerId" : {
              "type" : "string",
              "description" : "The issuer that owns the product (items)."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            }
          }
        } ],
        "description" : "Deflate product item.\n An inflatable Product Item can be 'deflated', i.e. the total supply of the item can be decreased.\n The selected holdings must be held by the issuer to allow them to be deflated.\n To deflate holdings not held by the issuer, Transfer (from the non-issuer account) or Adjust (to force them to be\n re-assigned to the issuer) the holdings first.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `DeflateProductItemRequest`, assigned by the\n request account in the `issuerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ValueHasTooManyDigits] | An amount in the holding selector exceeds maximum precision. |\n | [NonPositiveTransferAmount] | An amount in the holding selector is negative or zero. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InsufficientHoldings] | Insufficient amount to transfer. |\n | [QuantityOverflow] | The exact quantity computed overflows its type. |\n | [HoldingAccessDenied] | A specified holding is not held by the issuer. |\n | [HoldingsMustBeSameProduct] | Referenced holdings must be from the same product. |\n | [HoldingIsEscrowed] | An attempt was made to select an 'input' holding that was already locked. |\n | [HoldingIsUnassigned] | An attempt was made to select an 'input' holding that was not assigned yet. |\n | [NotMultipleOfUnitAmount] | The amount specified needs to be an integer multiple of the configured `unitAmount` |",
        "required" : [ "from", "issuerId", "type" ]
      },
      "DeleteAccountGroupEntry" : {
        "type" : "object",
        "properties" : {
          "accountGroupId" : {
            "type" : "string",
            "description" : "The account group to delete."
          },
          "versionId" : {
            "type" : "string",
            "description" : "Optionally, a version to check. If specified and the version does not match the group's current version, the request will fail."
          }
        },
        "required" : [ "accountGroupId" ]
      },
      "DeleteAccountGroupsRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Transaction attributes."
            },
            "groups" : {
              "type" : "array",
              "description" : "Non-empty list of updates to perform.",
              "items" : {
                "$ref" : "#/components/schemas/DeleteAccountGroupEntry"
              },
              "maxItems" : 2147483647,
              "minItems" : 1
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "ownerId" : {
              "type" : "string",
              "description" : "The owner of the account group(s) tp delete."
            }
          }
        } ],
        "description" : "Delete account group(s).\n\n The account group will be marked as deleted and can no longer be used.\n Multiple account groups can be deleted at the same time.\n Any security group assignments to the account group are removed.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `DeleteAccountGroupsRequest`, assigned by the\n request account in the `ownerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | Empty list of updates, or the request contains an empty update. |\n | [DuplicateAccountGroupId] | A list of account group IDs contains a duplicate entry. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectIssuer] | An account group being deleted is not owner by the `ownerId` account. |\n | [IncorrectVersion] | An account group version was specified that was not the latest version of that account group. |\n | [AccountGroupNotFound] | Referenced account group does not exist. |\n | [AccountGroupIsDeleted] | Referenced account group has been deleted. |",
        "required" : [ "groups", "ownerId", "type" ]
      },
      "DeleteIdentityProviderRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "account" : {
              "type" : "string",
              "description" : "Tenant owner account. The account field here has to be the owner of the tenant referenced in this same request.\n It is also the account that has to be the requesting account, as only the tenant owner can effect changes within the tenant.",
              "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the request."
            },
            "id" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "Internal provider ID.",
              "example" : 1
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "version" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Version of the identity provider in the repository.",
              "example" : 1
            }
          }
        } ],
        "description" : "Tenant owner deletes an identity provider.\n\n This transaction request is processed by the Tenant API itself and not forwarded to the mint-service. Therefore, it\n must be submitted to the [CoreTenantApi.identityProviderConfigRequest] endpoint instead of the normal transaction endpoints.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `DeleteIdentityProviderRequest`, assigned by the\n request account in the `account` field.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `account` account did not grant permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction or provider attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [TenantOwnerIncorrect] | The referenced tenant owner is not the owner of the referenced tenant  |\n | [TenantIdUnknown] | Referenced tenant does not exist  |\n | [IdentityProviderVersionInvalid] | Identity provider request version does not match repository version |\n | [IdentityProviderUnknown] | Identity provider does not exist |",
        "required" : [ "account", "id", "type", "version" ]
      },
      "DeleteIdentityTenantRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "account" : {
              "type" : "string",
              "description" : "Tenant owner account. The account field here has to be the owner of the tenant referenced in this same request.\n It is also the account that has to be the requesting account, as only the tenant owner can effect changes within the tenant.",
              "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the request."
            },
            "id" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "Internal tenant ID.",
              "example" : 1
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            }
          }
        } ],
        "description" : "Tenant owner deletes tenant.\n\n This transaction request is processed by the Tenant API itself and not forwarded to the mint-service. Therefore, it\n must be submitted to the [CoreTenantApi.identityTenantConfigRequest] endpoint instead of the normal transaction endpoints.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `DeleteIdentityTenantRequest`, assigned by the\n request account in the `account` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [TenantUsersOrProvidersNotEmpty] | The tenant cannot be deleted because users and/or identity providers are associated with it. |\n | [TenantOwnerIncorrect] | The referenced tenant owner is not the owner of the referenced tenant. |\n | [TenantIdUnknown] | Referenced tenant does not exist. |",
        "required" : [ "account", "id", "type" ]
      },
      "DeletePendingTransactionRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "byAccountId" : {
              "type" : "string",
              "description" : "AccountId attempting delete"
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "txId" : {
              "type" : "string",
              "description" : "Target txId."
            }
          }
        } ],
        "description" : "Delete a cancelled pending transaction request.\n\n This transaction request is processed by the Wallet API itself and not forwarded to the mint-service. Therefore, it\n must be submitted to the [CoreWalletApi.deletePendingTx] endpoint instead of the normal transaction endpoints.\n\n #### Transaction permission\n\n This transaction request can be submitted by any access key that has signed the pending transaction, or any possible\n signatory of the pending transaction. Even an access key with SECONDARY access can still submit this request with only\n its signature.\n\n Alternatively, the transaction request requires `Request` permission for transaction type `DeletePendingTransactionRequest`, assigned by the\n request account in the `byAccountId` field.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The access key is not a signatory of the pending transaction and the `byAccountId` request account did not grant permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction or provider attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [NotFound] | Referenced transaction does not exist. |\n | [TransactionNotFound] | Referenced transaction does not exist. |",
        "required" : [ "byAccountId", "txId", "type" ]
      },
      "DeleteProductItemRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "deflationMode" : {
              "type" : "string",
              "description" : "Determines how the given holdings are re-assigned. Defaults to DontDeflate.",
              "enum" : [ "DontDeflate", "Deflate", "DeflateAndDelete" ]
            },
            "issuerId" : {
              "type" : "string",
              "description" : "Issuer account that created the product."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "productItemId" : {
              "type" : "string",
              "description" : "Product item to delete"
            }
          }
        } ],
        "description" : "Delete Product Item.\n\n When all holdings of a Product Item are held by the issuer, the product item can be deleted (and holdings deflated).\n To force all holdings to be deleted, even though they may be held by non-issuer accounts, specify a `deflationMode`\n of [DeflationMode.DeflateAndDelete].\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `DeleteProductItemRequest`, assigned by the\n request account in the `issuerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [UnsupportedDeflationMode] | `deflationMode` can only be null, [DeflationMode.DontDeflate], or [DeflationMode.DeflateAndDelete]. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectIssuer] | The `issuerId` request account is not the issuer of the product. |\n | [ProductItemIsDeleted] | Referenced product item is already deleted. |\n | [ProductItemNotFound] | Referenced product item does not exist. |\n | [HoldingIsEscrowed] | The product item cannot be deleted because some of its holdings are escrowed. |\n | [HoldingIsNotWithIssuer] | The product item cannot be deleted because not all holdings are with the issuer, and `deflationMode` is not `DeflateAndDelete`. |",
        "required" : [ "issuerId", "productItemId", "type" ]
      },
      "DeleteProductRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "issuerId" : {
              "type" : "string",
              "description" : "Issuer account that owns the product."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "productId" : {
              "type" : "string",
              "description" : "Product to delete."
            }
          }
        } ],
        "description" : "Delete Product.\n\n When a Product has no more product items, it can be deleted.\n Deletion marks the product as 'deleted'. Historical queries can still reference the product but it will no longer\n be returned in the queries (unless `includeDeleted` is selected).\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `DeleteProductRequest`, assigned by the\n request account in the `issuerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectIssuer] | The `issuerId` request account is not the issuer of the product. |\n | [ProductIsDeleted] | Referenced product is already deleted  |\n | [ProductNotFound] | Referenced product does not exist. |",
        "required" : [ "issuerId", "productId", "type" ]
      },
      "DeleteSecurityGroupEntry" : {
        "type" : "object",
        "properties" : {
          "securityGroupId" : {
            "type" : "string",
            "description" : "The security group to delete."
          },
          "versionId" : {
            "type" : "string",
            "description" : "Optionally, a version to check. If specified and the version does not match the group's current version, the request will fail."
          }
        },
        "required" : [ "securityGroupId" ]
      },
      "DeleteSecurityGroupsRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Transaction attributes."
            },
            "entries" : {
              "type" : "array",
              "description" : "Non-empty list of updates to perform.",
              "items" : {
                "$ref" : "#/components/schemas/DeleteSecurityGroupEntry"
              },
              "maxItems" : 2147483647,
              "minItems" : 1
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "ownerId" : {
              "type" : "string",
              "description" : "The owner of the security group(s)."
            }
          }
        } ],
        "description" : "Delete security group(s).\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `DeleteSecurityGroupsRequest`, assigned by the\n request account in the `ownerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | The request contains no entries to delete. |\n | [DuplicateSecurityGroupId] | The request contains duplicate entries. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [SecurityGroupNotFound] | Referenced security group does not exist. |\n | [IncorrectIssuer] | Requester is not the owner of the security group. |\n | [IncorrectVersion] | A security group version was specified that was not the latest version of that security group. |\n | [SecurityGroupIsDeleted] | Referenced security group has been deleted. |",
        "required" : [ "entries", "ownerId", "type" ]
      },
      "DocumentData" : {
        "type" : "object",
        "description" : "Temporary class that embeds document data in a transaction.",
        "properties" : {
          "contentType" : {
            "type" : "string"
          },
          "sha256Hash" : {
            "type" : "string",
            "format" : "byte"
          },
          "url" : {
            "type" : "string"
          }
        },
        "required" : [ "contentType", "sha256Hash", "url" ]
      },
      "EndpointTypeCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "oneOf" : {
              "type" : "array",
              "items" : {
                "type" : "string",
                "enum" : [ "Unsupported", "Info", "GetAccountAccess", "ListEscrow", "GetIssuer", "ListProducts", "GetProduct", "ListProductItems", "GetProductItem", "QueryBalances", "ListProductItemUnderlyingHoldings", "ListProductItemHoldings", "ListCurrentHoldings", "ListSpentHoldings", "ListHoldingBalances", "GetHolding", "ListBalanceHistory", "ListCurrentBalances", "ListTransactions", "GetTransaction", "GetTransactionProof", "GetBlockHeader", "ListBlocks", "GetAccountGroup", "ListAccountGroups", "ListAccountGroupMembers", "GetSecurityGroup", "ListSecurityGroups", "ListAssignedSecurityGroups", "ListAccounts", "IdentityUserData", "IdentityTenantData", "IdentityProviderData", "IdentityTenantHistory", "CreateMetadataDefinitions", "UpdateMetadataDefinitions", "QueryMetadataDefinitions", "SetMetadata", "QueryMetadata", "SetUserMetadata", "QueryUserMetadata", "QueryAllUserMetadata", "UploadFile", "SaveTransactionProof", "ListPendingTransactions", "ListPendingSignatures", "CancelPendingTransaction", "DeletePendingTransaction", "GetHoldingHistory", "ListVisibleAccountGroups", "Notifications", "ListUnderlyingHoldings", "ListAccessibleAccounts", "ListEnumValues", "ListAttributeDefinitions", "ListSystemStateUpdates", "QueryMetadataDefinitionsAudit", "QueryMetadataValuesAudit" ]
              },
              "maxItems" : 2147483647,
              "minItems" : 1
            }
          }
        } ],
        "description" : "Access condition that matches on the request transaction type.",
        "required" : [ "oneOf", "type" ]
      },
      "EntityRef" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "Reference to the original entity (block and index where it was created)"
          },
          "type" : {
            "type" : "string",
            "description" : "The type of entity that is referenced by the id.",
            "enum" : [ "Product", "ProductItem", "BakedHolding", "Transaction", "AccountGroup", "SecurityGroup" ]
          }
        },
        "required" : [ "id", "type" ]
      },
      "EntityRefCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "oneOf" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/EntityRef"
              },
              "maxItems" : 2147483647,
              "minItems" : 1
            }
          }
        } ],
        "description" : "Condition that tests if entities being operated on are part of a set of allowed entities.\n The entities being validated differ depending on the request type:\n * [AssignHoldingRequest] - `productItems`\n * [AssignHoldingSelectorRequest] - `productItems`\n * [CreateProductRequest] - `productId`\n * [AssignSecurityGroupsRequest] - `updates.setSecurityGroupIds + updates.addSecurityGroupIds + updates.remoteSecurityGroupIds + updates.accountGroupIds`\n * [CreateProductItemRequest] - `productId`\n * [DeleteAccountGroupsRequest] - `groups.accountGroupId`\n * [DeleteProductItemRequest] - `productItemId`\n * [DeleteProductRequest] - `productId`\n * [DeleteSecurityGroupsRequest] - `entries.securityGroupId`\n * [InflateProductItemRequest] - `productItemId`\n * [SetAttributeRequest] - `entity` (generic entity reference)\n * [SetMultiAttributeRequest] - `entities.ids` (generic entity references)\n * [UpdateAccountGroupsRequest] - `updates.accountGroupId`\n * [UpdateSecurityGroupsRequest] - `entries.securityGroupId`",
        "required" : [ "oneOf", "type" ]
      },
      "EnumValue" : {
        "type" : "object",
        "description" : "Used for referencing an enum when used as an attribute value.",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the enumerator unique for the given attribute."
          },
          "ordinal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Ordinal of the enumerator unique for the given attribute."
          },
          "parent" : {
            "$ref" : "#/components/schemas/AttributeDefinitionData",
            "description" : "Enum attribute that owns this value"
          },
          "status" : {
            "type" : "string",
            "description" : "Actual status of the enumerated value.",
            "enum" : [ "ENABLED", "DISABLED" ]
          }
        },
        "required" : [ "parent", "status" ]
      },
      "EnumValueData" : {
        "type" : "object",
        "properties" : {
          "attribute" : {
            "type" : "string",
            "description" : "Enum attribute reference."
          },
          "enumValue" : {
            "$ref" : "#/components/schemas/EnumValue",
            "description" : "Allowed value for the attribute enum."
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata that was queried for the enum value (entity references: [MetadataEntityRefType.ATTRIBUTE_ENUM])."
          },
          "ordinal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Allowed ordinal for the attribute enum."
          },
          "status" : {
            "type" : "string",
            "description" : "If the value is enabled or disabled.",
            "enum" : [ "ENABLED", "DISABLED" ]
          }
        },
        "required" : [ "attribute", "enumValue", "ordinal", "status" ]
      },
      "EnumValueDefinition" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the enumerator. Must be unique for the given attribute."
          },
          "ordinal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Ordinal, number defining the position of an enum. Must be unique for the given attribute."
          }
        },
        "required" : [ "name", "ordinal" ]
      },
      "EnumValueRef" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "ordinal" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "EscrowAmount" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/HoldingSelector"
        }, {
          "type" : "object",
          "properties" : {
            "amount" : {
              "type" : "number",
              "description" : "Amount to select holdings for (null for all)."
            },
            "escrowId" : {
              "type" : "string",
              "description" : "Original escrow id the holdings were escrowed under."
            },
            "holderAccountId" : {
              "type" : "string",
              "description" : "Actual holder of the amount."
            },
            "productId" : {
              "type" : "string",
              "description" : "Product to select."
            }
          }
        } ],
        "description" : "Request for a specific amount of a particular product in escrow from a specific account.\n The requesting account needs to be the controller of the escrowed holding.",
        "required" : [ "escrowId", "holderAccountId", "productId", "type" ]
      },
      "EscrowCancelledNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "data" : {
              "$ref" : "#/components/schemas/EscrowTransactionData",
              "description" : "Transaction data for the cancelled escrow."
            },
            "tx" : {
              "$ref" : "#/components/schemas/TransactionData",
              "description" : "Original cancel request."
            }
          }
        } ],
        "description" : "Notifies a controller that an ordered was cancelled by the holder account.\n (Or notifies the holder account that the controller cancelled an order)",
        "required" : [ "data", "tx" ]
      },
      "EscrowReceivedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "data" : {
              "$ref" : "#/components/schemas/EscrowTransactionData",
              "description" : "Transaction data for the escrow received."
            },
            "tx" : {
              "$ref" : "#/components/schemas/TransactionData",
              "description" : "Original transaction request."
            }
          }
        } ],
        "description" : "Notifies an account that it became the controller of a new escrow order.",
        "required" : [ "data", "tx" ]
      },
      "EscrowTransactionData" : {
        "type" : "object",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "Account that holds this escrow."
          },
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Attributes from original CreateEscrowRequest."
          },
          "controllerAccountId" : {
            "type" : "string",
            "description" : "Controller for this escrow."
          },
          "escrowId" : {
            "type" : "string",
            "description" : "Unique id for this escrow."
          },
          "productId" : {
            "type" : "string",
            "description" : "Product"
          },
          "remainingAmount" : {
            "type" : "number",
            "description" : "Current balance of the escrow."
          }
        },
        "required" : [ "accountId", "controllerAccountId", "escrowId", "productId", "remainingAmount" ]
      },
      "HoldingAdjustedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/TransactionData",
              "description" : "Transaction request details."
            }
          }
        } ],
        "description" : "Notifies accounts that holdings were adjusted by the issuer.",
        "required" : [ "tx" ]
      },
      "HoldingAmount" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/HoldingSelector"
        }, {
          "type" : "object",
          "properties" : {
            "amount" : {
              "type" : "number",
              "description" : "Amount to select holdings for (null for all)."
            },
            "inputList" : {
              "type" : "array",
              "description" : "Holdings to select. If an amount is specified, the amount will be selected from these holdings\n in the order they are presented. If no amount is specified, the full holdings will be selected.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Select an amount from a specific set of holdings (holdings must be same product).",
        "required" : [ "inputList", "type" ]
      },
      "HoldingAmountEntry" : {
        "type" : "object",
        "properties" : {
          "amount" : {
            "type" : "number",
            "description" : "Amount to select holdings for (null for all)."
          },
          "inputList" : {
            "type" : "array",
            "description" : "Holdings to select. If an amount is specified, the amount will be selected from these holdings\n in the order they are presented. If no amount is specified, the full holdings will be selected.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "inputList" ]
      },
      "HoldingAmounts" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/HoldingSelector"
        }, {
          "type" : "object",
          "properties" : {
            "holdings" : {
              "type" : "array",
              "description" : "Each entry selects an amount from a list of holdings.",
              "items" : {
                "$ref" : "#/components/schemas/HoldingAmountEntry"
              }
            }
          }
        } ],
        "description" : "Select specific amounts from multiple holdings (of the same product).",
        "required" : [ "holdings", "type" ]
      },
      "HoldingAssignedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/TransactionData",
              "description" : "Transaction request details."
            }
          }
        } ],
        "description" : "Notifies accounts that holdings were assigned to (new) product items.",
        "required" : [ "tx" ]
      },
      "HoldingData" : {
        "type" : "object",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "Account that 'holds' this holding."
          },
          "amount" : {
            "type" : "number",
            "description" : "Computed amount for this product."
          },
          "bakedAttributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Final attributes when holding was baked."
          },
          "bakedIntoProductItem" : {
            "$ref" : "#/components/schemas/ProductItemData",
            "description" : "Product item that this holding was baked into."
          },
          "bakedIntoProductItemId" : {
            "type" : "string",
            "description" : "Product item id that this holding was baked into."
          },
          "controllerAccountId" : {
            "type" : "string",
            "description" : "If escrowed, the controller of the escrow."
          },
          "escrowId" : {
            "type" : "string",
            "description" : "If escrowed, the unique id of the escrow."
          },
          "holdingId" : {
            "type" : "string",
            "description" : "Unique holding id."
          },
          "index" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Start index in the product item (for non-inflatable items)"
          },
          "issuedIn" : {
            "type" : "string",
            "description" : "Hash of the transaction that issued this holding"
          },
          "issuedInTransaction" : {
            "type" : "string",
            "description" : "Block and index of the transaction that issued this holding."
          },
          "issuedTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Timestamp of the transaction that issued the holding"
          },
          "issuer" : {
            "$ref" : "#/components/schemas/IssuerData",
            "description" : "Issuer data (present if issuer data is requested)."
          },
          "issuerId" : {
            "type" : "string",
            "description" : "Issuer id for this product (present if issuer data is not included)"
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata that was queried for the holding (entity references: [MetadataEntityRefType.BAKED_HOLDING])."
          },
          "product" : {
            "$ref" : "#/components/schemas/ProductData",
            "description" : "Product data (present if product data is requested)."
          },
          "productId" : {
            "type" : "string",
            "description" : "Product id."
          },
          "productItem" : {
            "$ref" : "#/components/schemas/ProductItemData",
            "description" : "Product item data (present if product item data is requested)."
          },
          "productItemId" : {
            "type" : "string",
            "description" : "Product item id."
          },
          "quantity" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Quantity assigned."
          },
          "spentInTransaction" : {
            "type" : "string",
            "description" : "Block and index of the transaction that issued this holding."
          },
          "spentTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Timestamp of the transaction that issued the holding"
          },
          "state" : {
            "type" : "string",
            "description" : "Holding state.",
            "enum" : [ "Spent", "Unassigned", "Unspent", "Escrowed", "Baked", "Deflated" ]
          },
          "underlying" : {
            "type" : "array",
            "description" : "If `includeUnderluy",
            "items" : {
              "$ref" : "#/components/schemas/UnderlyingHoldingBalance"
            }
          }
        },
        "required" : [ "accountId", "amount", "holdingId", "issuedIn", "issuedInTransaction", "issuedTime", "productId", "productItemId", "quantity", "state" ]
      },
      "HoldingQuantity" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/HoldingSelector"
        }, {
          "type" : "object",
          "properties" : {
            "holdings" : {
              "type" : "array",
              "description" : "Each entry selects a specific starting index and quantity from a list of holdings.",
              "items" : {
                "$ref" : "#/components/schemas/HoldingQuantityEntry"
              }
            }
          }
        } ],
        "description" : "Select specific index (i.e. serial number) ranges from multiple holdings (of the same product),\n i.e. which specific parts of the holdings are to be transacted.\n If multiple entries reference the same holding id, they must be disjunct.",
        "required" : [ "holdings", "type" ]
      },
      "HoldingQuantityEntry" : {
        "type" : "object",
        "properties" : {
          "holdingId" : {
            "type" : "string",
            "description" : "Holding to select from. The holding must be held by the from/request account."
          },
          "index" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Start index in the holding's product item to select.\n The index must be greater than or equal to the holding's index and less than the holding's index+quantity.\n If absent, the first index of the holding will be selected."
          },
          "quantity" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Quantity of the holding to select. The request index + quantity must not exceed the holding's index + quantity.\n If no quantity is given, the remainder of the holding is selected."
          }
        },
        "required" : [ "holdingId" ]
      },
      "HoldingSelector" : {
        "type" : "object",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "EscrowAmount" : "#/components/schemas/EscrowAmount",
            "HoldingAmount" : "#/components/schemas/HoldingAmount",
            "HoldingAmounts" : "#/components/schemas/HoldingAmounts",
            "HoldingQuantity" : "#/components/schemas/HoldingQuantity",
            "ProductAmount" : "#/components/schemas/ProductAmount",
            "ProductItemAmount" : "#/components/schemas/ProductItemAmount",
            "ProductItemQuantity" : "#/components/schemas/ProductItemQuantity",
            "ProductItemsAmount" : "#/components/schemas/ProductItemsAmount"
          }
        },
        "properties" : {
          "type" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      },
      "HoldingTransactionData" : {
        "type" : "object",
        "properties" : {
          "holding" : {
            "$ref" : "#/components/schemas/HoldingData"
          },
          "transaction" : {
            "$ref" : "#/components/schemas/TransactionData"
          }
        },
        "required" : [ "holding", "transaction" ]
      },
      "IdentityProviderData" : {
        "type" : "object",
        "properties" : {
          "applicationIds" : {
            "type" : "array",
            "description" : "applicationIds",
            "items" : {
              "type" : "string"
            }
          },
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Identity provider attributes"
          },
          "clientId" : {
            "type" : "string",
            "description" : "clientId"
          },
          "createdOn" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Creation timestamp"
          },
          "displayName" : {
            "type" : "string",
            "description" : "Display name"
          },
          "enabled" : {
            "type" : "boolean"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "issuerUri" : {
            "type" : "string",
            "description" : "Issuer URI"
          },
          "lastUpdatedOn" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Last update timestamp"
          },
          "migrateFromSubjectIdClaim" : {
            "type" : "string",
            "description" : "Name of the claim the Identity Provider is migrating from when updating the [subjectIdClaim].\n When updating the [subjectIdClaim], a migration from the previous or default [subjectIdClaim] might be needed\n if there are already users authenticating with this Identity Provider."
          },
          "responseType" : {
            "type" : "string",
            "description" : "response type ( ex: code)"
          },
          "scopes" : {
            "type" : "array",
            "description" : "scopes",
            "items" : {
              "type" : "string"
            }
          },
          "subjectIdClaim" : {
            "type" : "string",
            "description" : "Name of the claim used by the identity provider token to identity a user"
          },
          "tenantId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Tenant ID"
          },
          "tenantOwnerAccount" : {
            "type" : "string",
            "description" : "Tenant Owner accountId"
          },
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Version"
          },
          "visible" : {
            "type" : "boolean"
          }
        },
        "required" : [ "applicationIds", "clientId", "displayName", "enabled", "id", "issuerUri", "responseType", "scopes", "subjectIdClaim", "tenantId", "tenantOwnerAccount", "version", "visible" ]
      },
      "IdentityProviderDeletedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/IdentityProviderData"
            }
          }
        } ],
        "description" : "Notifies account that an identity provider was deleted.",
        "required" : [ "tx" ]
      },
      "IdentityProviderSetNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/IdentityProviderData"
            }
          }
        } ],
        "description" : "Notifies account that an identity provider was created or updated.",
        "required" : [ "tx" ]
      },
      "IdentityTenantData" : {
        "type" : "object",
        "properties" : {
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Tenant attributes"
          },
          "createdOn" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Creation timestamp"
          },
          "deletedOn" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Deletion timestamp"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Internal id"
          },
          "lastUpdatedOn" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Last update timestamp"
          },
          "ownerAccountId" : {
            "type" : "string",
            "description" : "Account id that owns this tenant"
          },
          "tenantDisplayName" : {
            "type" : "string",
            "description" : "Display name"
          },
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Version"
          }
        },
        "required" : [ "id", "ownerAccountId", "version" ]
      },
      "IdentityTenantDeletedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/IdentityTenantData"
            }
          }
        } ],
        "description" : "Notifies account that an identity tenant was deleted.",
        "required" : [ "tx" ]
      },
      "IdentityTenantSetNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/IdentityTenantData"
            }
          }
        } ],
        "description" : "Notifies account that an identity tenant was created or updated.",
        "required" : [ "tx" ]
      },
      "IdentityUserData" : {
        "type" : "object",
        "description" : "Information about account / access key associated with an Authorization token user id.",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "Access key id for the server-managed key."
          },
          "createdOn" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Created timestamp"
          },
          "displayName" : {
            "type" : "string",
            "description" : "Display name. One of the following: preferred_username, username, email, sub"
          },
          "subjectId" : {
            "type" : "string",
            "description" : "Unique user identitier within the tenant.\n By default, this value is the 'sub' claim from the user's token.\n Different configured providers can use different claims to identify the user,\n as long as those claims contain the same ID value for the same user."
          },
          "tenantId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Tenant id"
          }
        },
        "required" : [ "accountId", "subjectId", "tenantId" ]
      },
      "InflateProductItemRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "amount" : {
              "type" : "number",
              "description" : "Amount of product in each quantity unit."
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "issuerId" : {
              "type" : "string",
              "description" : "The issuer of the product."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "productItemId" : {
              "type" : "string",
              "description" : "Product item to inflate."
            },
            "toAccountId" : {
              "type" : "string",
              "description" : "Account to receive the inflated holding."
            }
          }
        } ],
        "description" : "Inflate Product Item.\n Creates a new holding in the given Product Item and assigns it to the given account. This will inflate the supply\n of the Product. Only inflatable Product Items may be inflated.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `DeleteSecurityGroupsRequest`, assigned by the\n request account in the `issuerId` field.\n\n The `toAccountId` needs to be assigned `Product` permission by the product's issuer for the request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `issuerId` account did not grant permission for the request. |\n | [ProductAccessDenied] | The issuer of the product did not grant `Product` permission to the `toAccountId`. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ValueHasTooManyDigits] | An amount in the holding selector exceeds maximum precision. |\n | [NonPositiveTransferAmount] | An amount in the holding selector is negative or zero. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectIssuer] | Requester is not the issuer of the product. |\n | [ProductItemIsDeleted] | Referenced product item is deleted. |\n | [ProductItemNotFound] | Referenced product item does not exist. |\n | [ProductItemCantInflate] | Product item does not allow inflation. |\n | [NotMultipleOfUnitAmount] | The amount specified needs to be an integer multiple of the `unitAmount` of the product item. |\n | [QuantityOverflow] | The exact quantity computed overflows its type. |",
        "required" : [ "amount", "issuerId", "productItemId", "toAccountId", "type" ]
      },
      "IntegerMinMaxRule" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AttributeRule"
        }, {
          "type" : "object",
          "properties" : {
            "max" : {
              "type" : "integer",
              "format" : "int64"
            },
            "min" : {
              "type" : "integer",
              "format" : "int64"
            }
          }
        } ],
        "description" : "Validate each element against a minimum and/or maximum value."
      },
      "IssuedHoldingResponse" : {
        "type" : "object",
        "properties" : {
          "accountId" : {
            "type" : "string"
          },
          "holdingId" : {
            "type" : "string"
          },
          "index" : {
            "type" : "integer",
            "format" : "int64"
          },
          "productItem" : {
            "type" : "string"
          },
          "quantity" : {
            "type" : "integer",
            "format" : "int64"
          }
        },
        "required" : [ "accountId", "holdingId", "productItem", "quantity" ]
      },
      "IssuerData" : {
        "type" : "object",
        "description" : "Short data about issuers on the system.",
        "properties" : {
          "issuerId" : {
            "type" : "string",
            "description" : "Unique id for this issuer. The issuer id is equal to the issuer's primary account id."
          }
        },
        "required" : [ "issuerId" ]
      },
      "MetadataAccessKeyRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataAccountGroupRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataAccountRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataAttributeDefRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataBakedHoldingRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataDefCreateData" : {
        "type" : "object",
        "properties" : {
          "entityType" : {
            "type" : "string",
            "description" : "Type of entity that metadata entries of this definition can reference\n Can be one of:\n Product,\n ProductItem,\n BakedHolding,\n Transaction,\n AttributeDefinition,\n Account,\n AccessKey,\n AccountGroup",
            "enum" : [ "PRODUCT", "PRODUCT_ITEM", "BAKED_HOLDING", "TRANSACTION", "ATTRIBUTE_DEFINITION", "ACCOUNT", "ACCESS_KEY", "ACCOUNT_GROUP", "SECURITY_GROUP", "ATTRIBUTE_ENUM", "TRANSACTION_ID" ]
          },
          "isAuditValues" : {
            "type" : "boolean",
            "description" : "For auditable metadata(`isAudited=true`) indicates whether value changes are stored in audit logs,\n or not (in case metadata values contain PII, etc.)."
          },
          "isAudited" : {
            "type" : "boolean",
            "description" : "Indicates whether any operations on the metadata definition and metadata entries of this definition\n will be audited for reporting purposes."
          },
          "isIndexed" : {
            "type" : "boolean",
            "description" : "Indicates whether values stored in metadata entries of this definition will be indexed or not.\n Indexed values can be queried and used to query entities which are mapped by metadata entries."
          },
          "isPublic" : {
            "type" : "boolean",
            "description" : "Indicates whether metadata entries of this definition will be publicly accessible\n (without requiring authentication or authorization)"
          },
          "isUser" : {
            "type" : "boolean",
            "description" : "Indicates whether the metadata definition and metadata entries of this definition are only accessible by the\n user that has defined and set them, via the metadata user endpoints."
          },
          "name" : {
            "type" : "string",
            "description" : "Metadata definition name, unique per issuer.\n\n Metadata name must:\n - contain only alphanumeric characters and \"_\"(underscore),\n - start with a letter,\n - contain minimum 5 characters,\n - contain maximum 128 characters,"
          },
          "uniqueValues" : {
            "type" : "boolean",
            "description" : "Indicates that metadata entries of this definition referring any kind of entity type have to be unique."
          },
          "valueType" : {
            "type" : "string",
            "description" : "Type of value that metadata entries of this definition can hold\n String, Decimal, Integer, Json, File",
            "enum" : [ "STRING", "DECIMAL", "INTEGER", "JSON", "FILE", "URI", "TIMESTAMP" ]
          }
        },
        "required" : [ "entityType", "isAuditValues", "isAudited", "isIndexed", "isPublic", "isUser", "name", "valueType" ]
      },
      "MetadataDefinitionAuditData" : {
        "type" : "object",
        "description" : "Represents the audit data for metadata definition changes, encapsulating details about\n the auditable action, its originator, and the modifications made to the metadata definition.",
        "properties" : {
          "action" : {
            "type" : "string",
            "description" : "Type of action executed",
            "enum" : [ "CREATE", "UPDATE" ]
          },
          "id" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Audit entry id"
          },
          "issuerId" : {
            "type" : "string",
            "description" : "Issuer of entity on which the auditable action is performed by [originatorAccessKeyId]"
          },
          "name" : {
            "type" : "string",
            "description" : "Metadata definition name"
          },
          "newValue" : {
            "$ref" : "#/components/schemas/MetadataDefinitionData",
            "description" : "Metadata definition state after executing the changes"
          },
          "oldValue" : {
            "$ref" : "#/components/schemas/MetadataDefinitionData",
            "description" : "Metadata definition state before executing the changes"
          },
          "originatorAccessKeyId" : {
            "type" : "string",
            "description" : "Access key used by the originator of the auditable action"
          },
          "originatorUserAccountId" : {
            "type" : "string",
            "description" : "User account ID of the originator of the auditable action"
          },
          "tag" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Metadata definition tag"
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Time of execution"
          }
        },
        "required" : [ "action", "id", "issuerId", "name", "newValue", "originatorAccessKeyId", "originatorUserAccountId", "tag", "timestamp" ]
      },
      "MetadataDefinitionData" : {
        "type" : "object",
        "properties" : {
          "entityType" : {
            "type" : "string",
            "description" : "Type of entity that metadata entries of this definition can reference\n Can be one of:\n Product,\n ProductItem,\n BakedHolding,\n Transaction,\n AttributeDefinition,\n Account,\n AccessKey,\n AccountGroup",
            "enum" : [ "PRODUCT", "PRODUCT_ITEM", "BAKED_HOLDING", "TRANSACTION", "ATTRIBUTE_DEFINITION", "ACCOUNT", "ACCESS_KEY", "ACCOUNT_GROUP", "SECURITY_GROUP", "ATTRIBUTE_ENUM", "TRANSACTION_ID" ]
          },
          "isAuditValues" : {
            "type" : "boolean",
            "description" : "For auditable metadata(`isAudited=true`) indicates whether value changes are stored in audit logs,\n or not (in case metadata values contain PII, etc.)."
          },
          "isAudited" : {
            "type" : "boolean",
            "description" : "Indicates whether any operations on the metadata definition and metadata entries of this definition\n will be audited for reporting purposes."
          },
          "isIndexed" : {
            "type" : "boolean",
            "description" : "Indicates whether values stored in metadata entries of this definition will be indexed or not.\n Indexed values can be queried and used to query entities which are mapped by metadata entries."
          },
          "isPublic" : {
            "type" : "boolean",
            "description" : "Indicates whether metadata entries of this definition will be publicly accessible\n (without requiring authentication or authorization)"
          },
          "isUser" : {
            "type" : "boolean",
            "description" : "Indicates whether the metadata definition and metadata entries of this definition are only accessible by the\n user that has defined and set them, via the metadata user endpoints."
          },
          "issuerId" : {
            "type" : "string",
            "description" : "Owner of this metadata definition and all metadata entries of this definition"
          },
          "name" : {
            "type" : "string",
            "description" : "Metadata definition name, unique per issuer.\n\n Metadata name must:\n - contain only alphanumeric characters and \"_\"(underscore),\n - start with a letter,\n - contain minimum 5 characters,\n - contain maximum 128 characters"
          },
          "tag" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Unique metadata definition tag, mapping a metadata definition to an issuer"
          },
          "uniqueValues" : {
            "type" : "boolean",
            "description" : "Indicates that metadata entries of this definition referring any kind of entity type have to be unique."
          },
          "valueType" : {
            "type" : "string",
            "description" : "Type of value that metadata entries of this definition can hold\n String, Decimal, Integer, Json, File",
            "enum" : [ "STRING", "DECIMAL", "INTEGER", "JSON", "FILE", "URI", "TIMESTAMP" ]
          }
        },
        "required" : [ "entityType", "isAuditValues", "isAudited", "isIndexed", "isPublic", "isUser", "issuerId", "name", "tag", "uniqueValues", "valueType" ]
      },
      "MetadataDefinitionUpdateData" : {
        "type" : "object",
        "properties" : {
          "isAuditValues" : {
            "type" : "boolean",
            "description" : "For auditable metadata(`isAudited=true`) indicates whether value changes are stored in audit logs,\n or not (in case metadata values contain PII, etc.)."
          },
          "isAudited" : {
            "type" : "boolean",
            "description" : "Indicates whether any operations on the metadata definition and metadata entries of this definition\n will be audited for reporting purposes."
          },
          "metadataRef" : {
            "type" : "string",
            "description" : "Metadata reference (either by tag or issuer:name)"
          }
        },
        "required" : [ "metadataRef" ]
      },
      "MetadataEntityRef" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ACCESS_KEY" : "#/components/schemas/MetadataAccessKeyRef",
            "ACCOUNT" : "#/components/schemas/MetadataAccountRef",
            "ACCOUNT_GROUP" : "#/components/schemas/MetadataAccountGroupRef",
            "ATTRIBUTE_DEFINITION" : "#/components/schemas/MetadataAttributeDefRef",
            "ATTRIBUTE_ENUM" : "#/components/schemas/MetadataEnumRef",
            "BAKED_HOLDING" : "#/components/schemas/MetadataBakedHoldingRef",
            "PRODUCT" : "#/components/schemas/MetadataProductRef",
            "PRODUCT_ITEM" : "#/components/schemas/MetadataProductItemRef",
            "SECURITY_GROUP" : "#/components/schemas/MetadataSecurityGroupRef",
            "TRANSACTION" : "#/components/schemas/MetadataTransactionRef",
            "TRANSACTION_ID" : "#/components/schemas/MetadataTransactionIdRef"
          }
        },
        "properties" : {
          "type" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      },
      "MetadataEntryData" : {
        "type" : "object",
        "description" : "Metadata entry that maps a metadata definition to a referenced entity anda value.",
        "properties" : {
          "createdOn" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "When this metadata entry was first set"
          },
          "data" : {
            "$ref" : "#/components/schemas/MetadataValueDataObject",
            "description" : "Actual metadata value\n Can be one of:\n MetadataValueStringData,\n MetadataValueDecimalData,\n MetadataValueIntegerData,\n MetadataValueJsonData,\n MetadataValueFileWrapperData"
          },
          "entityRef" : {
            "$ref" : "#/components/schemas/MetadataEntityRef",
            "description" : "Which entity this metadata entry points to"
          },
          "ref" : {
            "type" : "string",
            "description" : "Metadata definition reference data"
          },
          "updatedOn" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "When this metadata was last updated"
          },
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Current version of this metadata entry"
          }
        },
        "required" : [ "data", "entityRef", "ref", "version" ]
      },
      "MetadataEnumRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataMap" : {
        "type" : "object",
        "description" : "A map of metadata for entities that are referenced in a response.\n The metadata for the response entries themselves will be in the `metadata` field of the respective `*Data` clasess,\n but any other metadata that is requested in the response will be available in this map.",
        "properties" : {
          "accessKey" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for access keys referenced in the response."
          },
          "account" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for accounts referenced in the response."
          },
          "accountGroup" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for account groups referenced in the response."
          },
          "attribute" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for attributes referenced in the response."
          },
          "bakedHolding" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for baked holdings referenced in the response."
          },
          "enumValue" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for enumerated values referenced in the response."
          },
          "product" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for products referenced in the response."
          },
          "productItem" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for product items referenced in the response."
          },
          "securityGroup" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for security groups referenced in the response."
          },
          "transaction" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for transactions referenced in the response."
          },
          "transactionId" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              }
            },
            "description" : "Metadata for transaction request hashes ([TransactionId]) referenced in the response."
          }
        }
      },
      "MetadataProductItemRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataProductRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataSecurityGroupRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataTransactionIdRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataTransactionRef" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataEntityRef"
        }, {
          "type" : "object",
          "properties" : {
            "ref" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "ref" ]
      },
      "MetadataUserEntryData" : {
        "type" : "object",
        "description" : "Metadata entry that maps a metadata definition to a user, referenced entity and a value.",
        "properties" : {
          "createdOn" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "When this metadata entry was first set"
          },
          "data" : {
            "$ref" : "#/components/schemas/MetadataValueDataObject",
            "description" : "Actual metadata value\n Can be one of:\n MetadataValueStringData,\n MetadataValueDecimalData,\n MetadataValueIntegerData,\n MetadataValueJsonData,\n MetadataValueFileWrapperData"
          },
          "entityRef" : {
            "$ref" : "#/components/schemas/MetadataEntityRef",
            "description" : "Which entity this metadata entry points to"
          },
          "ref" : {
            "type" : "string",
            "description" : "Metadata definition reference data"
          },
          "updatedOn" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "When this metadata was last updated"
          },
          "userId" : {
            "type" : "string",
            "description" : "User that owns the current value"
          },
          "version" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Current version of this metadata entry"
          }
        },
        "required" : [ "data", "entityRef", "ref", "userId", "version" ]
      },
      "MetadataValueAuditData" : {
        "type" : "object",
        "description" : "Represents the audit data for metadata value changes, encapsulating details about\n the auditable action, its originator, and the changes made to the metadata.",
        "properties" : {
          "action" : {
            "type" : "string",
            "description" : "Type of action executed",
            "enum" : [ "CREATE", "UPDATE" ]
          },
          "entityRef" : {
            "$ref" : "#/components/schemas/MetadataEntityRef",
            "description" : "Type of entity that the value is referencing"
          },
          "id" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Audit entry id"
          },
          "isUser" : {
            "type" : "boolean",
            "description" : "Indicates whether the metadata definition and metadata entries of this definition are only accessible by the\n user that has defined and set them, via the metadata user endpoints."
          },
          "issuerId" : {
            "type" : "string",
            "description" : "Issuer of entity on which the auditable action is performed by [originatorAccessKeyId]"
          },
          "name" : {
            "type" : "string",
            "description" : "Metadata definition name"
          },
          "newValue" : {
            "$ref" : "#/components/schemas/MetadataValueDataObject",
            "description" : "Metadata definition state after executing the changes"
          },
          "oldValue" : {
            "$ref" : "#/components/schemas/MetadataValueDataObject",
            "description" : "Metadata definition state before executing the changes"
          },
          "originatorAccessKeyId" : {
            "type" : "string",
            "description" : "Access key used by the originator of the auditable action"
          },
          "originatorUserAccountId" : {
            "type" : "string",
            "description" : "User account ID of the originator of the auditable action"
          },
          "tag" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Metadata definition tag"
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Time of execution"
          },
          "userId" : {
            "type" : "string",
            "description" : "User that owns the metadata value"
          }
        },
        "required" : [ "action", "entityRef", "id", "isUser", "issuerId", "name", "newValue", "originatorAccessKeyId", "originatorUserAccountId", "tag", "timestamp", "userId" ]
      },
      "MetadataValueDataObject" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DECIMAL" : "#/components/schemas/MetadataValueDecimalData",
            "FILE" : "#/components/schemas/MetadataValueFileWrapperData",
            "INTEGER" : "#/components/schemas/MetadataValueIntegerData",
            "JSON" : "#/components/schemas/MetadataValueJsonData",
            "STRING" : "#/components/schemas/MetadataValueStringData",
            "TIMESTAMP" : "#/components/schemas/MetadataValueTimeStampData",
            "URI" : "#/components/schemas/MetadataValueUriData"
          }
        },
        "properties" : {
          "type" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      },
      "MetadataValueDecimalData" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataValueDataObject"
        }, {
          "type" : "object",
          "properties" : {
            "value" : {
              "type" : "number"
            }
          }
        } ],
        "required" : [ "value" ]
      },
      "MetadataValueFileData" : {
        "type" : "object",
        "properties" : {
          "fileName" : {
            "type" : "string"
          },
          "fileUrl" : {
            "type" : "string"
          },
          "mediaType" : {
            "type" : "string"
          },
          "sha256Hash" : {
            "type" : "string",
            "format" : "byte"
          },
          "sizeBytes" : {
            "type" : "integer",
            "format" : "int64"
          },
          "uploadedFileId" : {
            "type" : "string"
          }
        },
        "required" : [ "fileName", "mediaType", "sha256Hash" ]
      },
      "MetadataValueFileWrapperData" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataValueDataObject"
        }, {
          "type" : "object",
          "properties" : {
            "value" : {
              "$ref" : "#/components/schemas/MetadataValueFileData"
            }
          }
        } ],
        "required" : [ "value" ]
      },
      "MetadataValueIntegerData" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataValueDataObject"
        }, {
          "type" : "object",
          "properties" : {
            "value" : {
              "type" : "integer"
            }
          }
        } ],
        "required" : [ "value" ]
      },
      "MetadataValueJsonData" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataValueDataObject"
        }, {
          "type" : "object",
          "properties" : {
            "value" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "value" ]
      },
      "MetadataValueStringData" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataValueDataObject"
        }, {
          "type" : "object",
          "properties" : {
            "value" : {
              "type" : "string"
            }
          }
        } ],
        "required" : [ "value" ]
      },
      "MetadataValueTimeStampData" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataValueDataObject"
        }, {
          "type" : "object",
          "properties" : {
            "value" : {
              "type" : "string",
              "format" : "date-time"
            }
          }
        } ],
        "required" : [ "value" ]
      },
      "MetadataValueUriData" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/MetadataValueDataObject"
        }, {
          "type" : "object",
          "properties" : {
            "value" : {
              "type" : "string",
              "format" : "uri"
            }
          }
        } ],
        "required" : [ "value" ]
      },
      "MintTransactionFailed" : {
        "type" : "object",
        "properties" : {
          "accessKeyIds" : {
            "type" : "array",
            "description" : "The access key ids of signatories to the request.",
            "items" : {
              "type" : "string"
            }
          },
          "accountId" : {
            "type" : "string",
            "description" : "The account id for which the request was requested.\n Typically, signature verification and access control errors don't contain an account id in the failure response."
          },
          "errorCode" : {
            "type" : "string",
            "description" : "- `AccessTypeNotAllowed`: The access type is only allowed for account groups owned by the Issuer Admin account.\n- `AccessUpdateCausingPermanentAccessLossNotAllowed`: The access update request causes permanent access loss to the target account.\n- `AccessUpdateContainsDuplicateAccountKey`: The access update request contains duplicate account ids.\n- `AccountGroupIsDeleted`: The selected account group has been deleted.\n- `AccountGroupNotFound`: The requested account group does not exist.\n- `AccountIsAlreadyMember`: The added account is already a member of the group.\n- `AccountIsNotMember`: The removed account is not a member of the group.\n- `AttributeNameExists`: An attempt was made to define an attribute with a name that is already defined.\n- `AttributeTagExists`: An attempt was made to define an attribute with a tag that is already defined.\n- `AttributeTagNotAllowed`: The attribute tag must be 0.\n- `BakeIntoItemNotHeld`: The bake request account has no holdings of the destination product item.\n- `BakedHoldingIsUsed`: The selected holding is already 'baked'.\n- `BakedHoldingNotUnderlying`: Holding being baked is not an underlying of the destination product item.\n- `ControllerAccessDenied`: The controller of an escrow did not grant permission for the escrow request.\n- `DeflationModeNotAllowedForProductItem`: The requested deflation mode is not allowed for a product item. Ensure that `Deflate` is not selected for non-inflatable items.\n- `EntityAlreadyUpdated`: This transaction already updated this entity.\n- `EntityNotFound`: The entity/product/item was not found.\n- `EnumAlreadyExists`: The enumerated value already exists.\n- `EnumValueNotFound`: The enumerated value does not exist.\n- `EscrowNotFound`: The combination of `escrowId`, `holderAccountId`, and `controllerAccountId` could not (any longer) be found.\n- `HasProductItems`: The product cannot be deleted because it still has product items.\n- `HoldingAccessDenied`: The specified holding is not owned by the requestor's account.\n- `HoldingIsAlreadyWithIssuer`: An attempt was made to reassign a holding that was already with the issuer of the product.\n- `HoldingIsEscrowed`: An attempt was made to select an 'input' holding that was already locked.\n- `HoldingIsNotUnassigned`: An attempt was made to assign a holding that was already assigned.\n- `HoldingIsNotWithIssuer`: The product item still has holdings with non-issuer accounts.\n- `HoldingIsSpent`: A holding was referenced that has already been spent.\n- `HoldingIsUnassigned`: An attempt was made to select an 'input' holding that was not assigned yet.\n- `HoldingsMustBeSameProduct`: The `HoldingSelector` selected holdings that are not for the same product. When specifying existing holding ids in a holding selector, ensure that they are holdings of product items of the same product.\n- `IncorrectIssuer`: The requesting account is not an issuer of the product or item.\n- `IncorrectVersion`: An attempt was made to update an entity's attributes with an incorrect current version. Ensure that the attribute update request is based on the most recent entity version.\n- `InflationModeNotAllowedForProductItem`: The requested inflation mode is not allowed for a product item. Ensure that `Inflate` is not selected for non-inflatable items.\n- `InitialIndexNotAllowed`: An inflatable product item may not contain an initial index.\n- `InitialIndexNotUnique`: The supplied index is invalid/not unique.\n- `InsufficientAvailableToAssign`: Insufficient product items were provided to re-assign the requested holdings.\n- `InsufficientHoldings`: The account has insufficient holdings to complete the transaction.\n- `InternalError`: An (unexpected) internal error occurred while processing the transaction. Try again when things have stabilized.\n- `InvalidAmount`: Product item requires an specific amount.\n- `InvalidRequest`: The request failed validation and/or configured rules. This transaction error is an indication that upstream components failed to properly validate the request and may be penalized with velocity checks.\n- `InvalidUnitAmount`: The `unitAmount` specified cannot be represented with the product's `maxDecimalPos`.\n- `IssuerAccessDenied`: The system administrator did not grant 'issuer' permission for the request.\n- `NotInitialized`: The system has not caught up with the block storage yet. Resend the request at a later time.\n- `NotMultipleOfUnitAmount`: The amount specified needs to be an integer multiple of the configured `unitAmount`\n- `PrecisionExceedsMaxDecimalPos`: The quantity specified exceeds the `maxDecimalPos` of the product.\n- `ProductAccessDenied`: The issuer of the product did not grant permission for a transfer or issuance.\n- `ProductCantFractionalize`: This product doesn't allow fractionalizable product items.\n- `ProductCantInflate`: This product doesn't allow inflatable product items.\n- `ProductCantSpendUnassigned`: Spending `Unassigned` holdings is not allowed for this product.\n- `ProductIsDeleted`: This product doesn't allow any interaction as it is deleted.\n- `ProductItemCantInflate`: An inflate transaction was attempted on a product item that does not allow inflation.\n- `ProductItemIsDeleted`: The referenced product item is deleted.\n- `ProductItemNotFound`: The referenced product item does not exist.\n- `ProductItemRequiresUnderlying`: Creating a product item for this product requires a baked holding for each of the required products.\n- `ProductItemsMustBeSameProduct`: When re-assigning holdings to a different Product Item, the product item must be of the same product.\n- `ProductNotFound`: The referenced product does not exist.\n- `QuantityOverflow`: The exact quantity computed overflows its type.\n- `RequestAccessDenied`: The request was not signed by parties with sufficient access.\n- `RequiresInitialAmount`: Non-inflatable product items require an initial amount.\n- `SecurityGroupIsDeleted`: The selected security group has been deleted.\n- `SecurityGroupNotFound`: The requested security group does not exist.\n- `TransactionHasBeenProcessed`: Duplicate transaction id. A transaction with this id has already been processed.\n- `UnderlyingNotAllowedForUnassigned`: Unassigned product items cannot have underlying baked holdings.\n- `UnsupportedTransactionRequest`: The type of transaction request was not supported by this system."
          },
          "message" : {
            "type" : "string",
            "description" : "Optionally, an additional error message text."
          },
          "subSystem" : {
            "type" : "string",
            "description" : "The subsystem that failed the processing."
          },
          "txId" : {
            "type" : "string",
            "description" : "The transaction id from the request."
          }
        },
        "required" : [ "accessKeyIds", "errorCode", "subSystem", "txId" ]
      },
      "MintTransactionRequest" : {
        "type" : "object",
        "properties" : {
          "requestBytes" : {
            "type" : "string",
            "format" : "byte",
            "description" : "Binary encoded request.",
            "example" : "/CDiUGXYpBKjXjnDbuWrW55yKARkVEVTVGxUZXN0IFByb2R1Y3QCBOHh4OAA6YDtgOM="
          },
          "signatures" : {
            "type" : "array",
            "description" : "Request signatures.",
            "items" : {
              "$ref" : "#/components/schemas/AccessKeySignature"
            }
          },
          "systemId" : {
            "type" : "string",
            "description" : "Unique SystemId that the transaction request is signed for. The SystemId can be retrieved from the config endpoint.",
            "example" : "0x0070395e71dfb166ba5414b8f3dafbca7fac4bf7f0830dac96bfe8474913f514"
          },
          "txId" : {
            "type" : "string",
            "description" : "Informational transaction id, the transaction id is actually the hash of the request.",
            "example" : "0x233c04beef01370ef4b0e2bb6301cda077666ed81a76dc5e93aacd830e59bb36"
          }
        },
        "required" : [ "requestBytes", "signatures", "systemId", "txId" ]
      },
      "MintTransactionResponse" : {
        "type" : "object",
        "description" : "Response to a (successful) transaction request.\n The response contains the blockNumber and indexInBlock of the processed transaction as well as basic information\n about holdings that were spent and issued by the transaction.",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "Account to which this response applies."
          },
          "blockNumber" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Block number that the transaction is committed in."
          },
          "indexInBlock" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Transaction index in said block."
          },
          "issuedHoldings" : {
            "type" : "array",
            "description" : "Holdings that were issued in this transaction (to this account).",
            "items" : {
              "$ref" : "#/components/schemas/IssuedHoldingResponse"
            }
          },
          "issuedToOthers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IssuedHoldingResponse"
            }
          },
          "issuedToSelf" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IssuedHoldingResponse"
            }
          },
          "spentHoldings" : {
            "type" : "array",
            "description" : "Holdings that were spent in this transaction.",
            "items" : {
              "$ref" : "#/components/schemas/SpentHoldingResponse"
            }
          },
          "txId" : {
            "type" : "string",
            "description" : "Transaction hash."
          }
        },
        "required" : [ "accountId", "blockNumber", "indexInBlock", "issuedHoldings", "issuedToOthers", "issuedToSelf", "spentHoldings", "txId" ]
      },
      "PagedListResponseAccessibleRequestAccountData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/AccessibleRequestAccountData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseAccessibleUserAccountData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/AccessibleUserAccountData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseAccountAccessData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/AccountAccessData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseAccountData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/AccountData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseAccountGroupData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/AccountGroupData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseAssignedSecurityGroupData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/AssignedSecurityGroupData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseAttributeDefinitionData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/AttributeDefinitionData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseAttributeValuesBalanceData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/AttributeValuesBalanceData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseBalanceData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/BalanceData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseBalanceHistoryData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/BalanceHistoryData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseBlockData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/BlockData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseCoreNotification" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/CoreNotification"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseEnumValueData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/EnumValueData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseEnumValueDefinition" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/EnumValueDefinition"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseEscrowTransactionData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/EscrowTransactionData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseHoldingData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/HoldingData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseHoldingTransactionData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/HoldingTransactionData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseIdentityProviderData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/IdentityProviderData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseIdentityTenantData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/IdentityTenantData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseIdentityUserData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/IdentityUserData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseIssuerData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/IssuerData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseMetadataDefinitionAuditData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/MetadataDefinitionAuditData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseMetadataDefinitionData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/MetadataDefinitionData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseMetadataEntryData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/MetadataEntryData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseMetadataUserEntryData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/MetadataUserEntryData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseMetadataValueAuditData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/MetadataValueAuditData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponsePendingSignatureData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/PendingSignatureData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponsePendingTransactionData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/PendingTransactionData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseProductData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/ProductData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseSecurityGroupData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/SecurityGroupData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseSystemStateUpdateData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/SystemStateUpdateData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseTransactionData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/TransactionData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseUnderlyingHoldingData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/UnderlyingHoldingData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PagedListResponseWalletTransactionData" : {
        "type" : "object",
        "description" : "Paged response.",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "If `page.withCount` was set to `true` on the request, the total result count of the query."
          },
          "list" : {
            "type" : "array",
            "description" : "Result list.",
            "items" : {
              "$ref" : "#/components/schemas/WalletTransactionData"
            }
          },
          "metadata" : {
            "$ref" : "#/components/schemas/MetadataMap"
          },
          "nextPage" : {
            "type" : "string",
            "description" : "If `nextPage` is not present, there are no more results.\n If `nextPage` contains a value, it must be supplied (with the same criteria) in the `page.from`\n parameter of the next request to retrieve the next page."
          }
        },
        "required" : [ "list" ]
      },
      "PendingRequestSignatureEntry" : {
        "type" : "object",
        "properties" : {
          "accessKeyId" : {
            "type" : "string",
            "description" : "Access key that is to sign."
          },
          "accountAccessType" : {
            "type" : "string",
            "description" : "Type of account access for this access key.",
            "enum" : [ "FULL", "PRIMARY", "SECONDARY", "REVOKED" ]
          },
          "accountRoleType" : {
            "type" : "string",
            "description" : "Role of this user account in the request account.",
            "enum" : [ "SINGLE", "INITIATOR", "APPROVER" ]
          },
          "processedAttributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Attributes given for rejection."
          },
          "processedTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Timestamp for the signature or rejection."
          },
          "status" : {
            "type" : "string",
            "description" : "Current status for this possible signatory.",
            "enum" : [ "SIGNED", "PENDING", "REJECTED" ]
          },
          "userAccessType" : {
            "type" : "string",
            "description" : "Access type of the user account at the time of the request.",
            "enum" : [ "NoAccessType", "AuditAccess", "UserAccess", "AdminAccess", "OperatorAccess" ]
          },
          "userAccountId" : {
            "type" : "string",
            "description" : "User account id to sign for."
          }
        },
        "required" : [ "accessKeyId", "accountAccessType", "accountRoleType", "status", "userAccessType", "userAccountId" ]
      },
      "PendingSignatureCount" : {
        "type" : "object",
        "description" : "Structure that reports the number of pending requests that could be signed by a particular access key.",
        "properties" : {
          "accessKeyId" : {
            "type" : "string",
            "description" : "Access key to sign a pending request."
          },
          "pendingCount" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Number of pending requests for this key."
          }
        },
        "required" : [ "accessKeyId", "pendingCount" ]
      },
      "PendingSignatureData" : {
        "type" : "object",
        "description" : "A data structure to retrieve pending signatures and data about the transaction request.",
        "properties" : {
          "accessKeyId" : {
            "type" : "string",
            "description" : "Access key that is to sign."
          },
          "accountAccessType" : {
            "type" : "string",
            "description" : "Type of account access for this access key.",
            "enum" : [ "FULL", "PRIMARY", "SECONDARY", "REVOKED" ]
          },
          "accountRoleType" : {
            "type" : "string",
            "description" : "Role of this user account for the request account.",
            "enum" : [ "SINGLE", "INITIATOR", "APPROVER" ]
          },
          "created" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Created"
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata for this transaction if requested with `includeMetadata`."
          },
          "processedTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Processing time"
          },
          "processingAttributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Processing attributes"
          },
          "rejectedBy" : {
            "type" : "array",
            "description" : "The signatures that rejected the transaction.",
            "items" : {
              "$ref" : "#/components/schemas/TransactionSignatoryData"
            }
          },
          "request" : {
            "$ref" : "#/components/schemas/TransactionRequest",
            "description" : "Decoded transaction request for thin clients."
          },
          "requestAccountId" : {
            "type" : "string",
            "description" : "Request account for this transaction."
          },
          "signedBy" : {
            "type" : "array",
            "description" : "Other signatures already present on the pending transaction.",
            "items" : {
              "$ref" : "#/components/schemas/TransactionSignatoryData"
            }
          },
          "signedRequest" : {
            "$ref" : "#/components/schemas/MintTransactionRequest",
            "description" : "Transaction request to sign."
          },
          "status" : {
            "type" : "string",
            "description" : "Status",
            "enum" : [ "SIGNED", "PENDING", "REJECTED" ]
          },
          "transactionStatus" : {
            "type" : "string",
            "description" : "Transaction type",
            "enum" : [ "PENDING", "REJECTED" ]
          },
          "txId" : {
            "type" : "string",
            "description" : "Transaction request hash."
          },
          "userAccessType" : {
            "type" : "string",
            "description" : "Type of user at the time of the transaction.",
            "enum" : [ "NoAccessType", "AuditAccess", "UserAccess", "AdminAccess", "OperatorAccess" ]
          },
          "userAccountId" : {
            "type" : "string",
            "description" : "User account id to sign for."
          }
        },
        "required" : [ "accessKeyId", "accountAccessType", "accountRoleType", "created", "request", "requestAccountId", "signedRequest", "status", "transactionStatus", "txId", "userAccessType", "userAccountId" ]
      },
      "PendingTransactionData" : {
        "type" : "object",
        "description" : "Information about a pending transaction request.",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "Request account id."
          },
          "created" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Created time"
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Requested metadata associated with the pending transaction (by TRANSACTION_ID)."
          },
          "request" : {
            "$ref" : "#/components/schemas/TransactionRequest",
            "description" : "Transaction request data."
          },
          "signatures" : {
            "type" : "array",
            "description" : "Pending and received signatures",
            "items" : {
              "$ref" : "#/components/schemas/PendingRequestSignatureEntry"
            }
          },
          "signedRequest" : {
            "$ref" : "#/components/schemas/MintTransactionRequest",
            "description" : "Current pending transaction request."
          },
          "status" : {
            "type" : "string",
            "description" : "Current status of this pending transaction.",
            "enum" : [ "PENDING", "REJECTED" ]
          },
          "txId" : {
            "type" : "string",
            "description" : "Transaction request hash."
          }
        },
        "required" : [ "accountId", "created", "request", "signedRequest", "status", "txId" ]
      },
      "PermissionStatement" : {
        "type" : "object",
        "properties" : {
          "action" : {
            "type" : "string",
            "description" : "Result of this statement if all rules match.",
            "enum" : [ "GRANT_IF_MATCH", "DENY_IF_MATCH", "DENY_IF_NO_MATCH" ]
          },
          "conditions" : {
            "type" : "array",
            "description" : "Conjunction of rules.",
            "items" : {
              "$ref" : "#/components/schemas/AccessCondition"
            }
          }
        },
        "required" : [ "action", "conditions" ]
      },
      "ProductAmount" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/HoldingSelector"
        }, {
          "type" : "object",
          "properties" : {
            "amount" : {
              "type" : "number",
              "description" : "Amount to select from the product holdings."
            },
            "isUnassigned" : {
              "type" : "boolean"
            },
            "productId" : {
              "type" : "string",
              "description" : "Product to select from."
            }
          }
        } ],
        "description" : "Request for a specific amount of a particular product.",
        "required" : [ "amount", "productId", "type" ]
      },
      "ProductBalanceData" : {
        "type" : "object",
        "description" : "Balance data for a particular product.\n When querying the 'effect' of a transaction or collection of transactions on a particular grouping, the result contains\n separate totals for the different amounts (depending on the holding state).\n The `amount` represents a transaction amount, i.e. the total of the transacted amounts.\n The other amounts represent 'net' balance movements, where a negative amount signifies a net debit and a positive amount\n signifies a net credit.",
        "properties" : {
          "amount" : {
            "type" : "number",
            "description" : "Absolute (i.e., greater than 0) amount of transactions."
          },
          "assignedAmount" : {
            "type" : "number",
            "description" : "Net assigned amount (including with amounts assigned to issuer)."
          },
          "bakedAmount" : {
            "type" : "number",
            "description" : "Amount that has been baked."
          },
          "escrowAmount" : {
            "type" : "number",
            "description" : "Amount in escrow."
          },
          "issuerAmount" : {
            "type" : "number",
            "description" : "Amount held by issuer."
          },
          "productId" : {
            "type" : "string",
            "description" : "The product for these balances."
          },
          "unassignedAmount" : {
            "type" : "number",
            "description" : "Net unassigned amount."
          }
        },
        "required" : [ "amount", "assignedAmount", "escrowAmount", "issuerAmount", "productId", "unassignedAmount" ]
      },
      "ProductCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "productIds" : {
              "type" : "array",
              "description" : "List of product ids that are match this condition. The transfer context must contain one of these products to match.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Matches a specific product.",
        "required" : [ "type" ]
      },
      "ProductData" : {
        "type" : "object",
        "description" : "Detail for a Product. Products are identified by the block-and-index of the transaction that originally created them.\n Additionally, there's a version that indicates the version of the product's definition. The version is the block-and-index\n of the SetAttribute transaction that updated the product's attributes.",
        "properties" : {
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Current attributes of the product."
          },
          "data" : {
            "$ref" : "#/components/schemas/CreateProductRequest",
            "description" : "Original immutable data for this product."
          },
          "isDeleted" : {
            "type" : "boolean",
            "description" : "Indicates this product has been deleted."
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata that was queried for the product (entity references: [MetadataEntityRefType.PRODUCT])."
          },
          "productId" : {
            "type" : "string",
            "description" : "Unique ID for this product."
          },
          "version" : {
            "type" : "string",
            "description" : "If the product's attributes have been updated, the version of the current state."
          }
        },
        "required" : [ "data", "productId" ]
      },
      "ProductItemAmount" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/HoldingSelector"
        }, {
          "type" : "object",
          "properties" : {
            "amount" : {
              "type" : "number"
            },
            "productItemId" : {
              "type" : "string"
            }
          }
        } ],
        "description" : "Request for a quantity of a specific product item.",
        "required" : [ "amount", "productItemId", "type" ]
      },
      "ProductItemData" : {
        "type" : "object",
        "description" : "Current state of a product item that is held by an account",
        "properties" : {
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Current attributes of the product item."
          },
          "createdTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Timestamp of the transaction that created the product item"
          },
          "data" : {
            "$ref" : "#/components/schemas/CreateProductItemRequest",
            "description" : "Original immutable data for this product."
          },
          "isDeleted" : {
            "type" : "boolean",
            "description" : "Indicates this product item has been deleted."
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata that was queried for the product item (entity references: [MetadataEntityRefType.PRODUCT_ITEM])."
          },
          "productItemId" : {
            "type" : "string",
            "description" : "Unique ID for this product."
          },
          "version" : {
            "type" : "string",
            "description" : "If the product item's attributes have been updated, the version of the current state."
          }
        },
        "required" : [ "createdTime", "data", "productItemId" ]
      },
      "ProductItemQuantity" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/HoldingSelector"
        }, {
          "type" : "object",
          "properties" : {
            "productItemId" : {
              "type" : "string",
              "description" : "Product item to select from."
            },
            "quantity" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Quantity to select from the product items."
            }
          }
        } ],
        "description" : "Request for a quantity of a specific product item.",
        "required" : [ "productItemId", "quantity", "type" ]
      },
      "ProductItemResponse" : {
        "type" : "object",
        "properties" : {
          "product" : {
            "$ref" : "#/components/schemas/ProductData"
          },
          "productItem" : {
            "$ref" : "#/components/schemas/ProductItemData"
          }
        },
        "required" : [ "product", "productItem" ]
      },
      "ProductItemsAmount" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/HoldingSelector"
        }, {
          "type" : "object",
          "properties" : {
            "amount" : {
              "type" : "number",
              "description" : "Amount to select from the product items."
            },
            "productItemIds" : {
              "type" : "array",
              "description" : "Product items to select from. The amount will be selected from these items in the order they are presented.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Request for a quantity of several product items, or a specific product item.",
        "required" : [ "amount", "productItemIds", "type" ]
      },
      "ProductTransferCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "productIds" : {
              "type" : "array",
              "description" : "List of product ids that are match this condition. The transfer context must contain one of these products to match.",
              "items" : {
                "type" : "string"
              }
            },
            "toAccountGroupIds" : {
              "type" : "array",
              "description" : "If specified, a list of accounts that these products can be transferred to.",
              "items" : {
                "type" : "string"
              }
            },
            "toAccountIds" : {
              "type" : "array",
              "description" : "If specified, a list of accounts that these products can be transferred to.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Matches a transfer of a specific product.\n If toAccountIds or toAccountGroupIds are specified, the condition matches the toAccount of the transfer context.\n If neither toAccountIds nor toAccountGroupIds are specified, the condition matches any account.",
        "required" : [ "type" ]
      },
      "PublicContentConfig" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          }
        },
        "required" : [ "enabled" ]
      },
      "PublicContentLinkData" : {
        "type" : "object",
        "description" : "Link to a (publicly browseable) transaction proof.",
        "properties" : {
          "downloadUrl" : {
            "type" : "string",
            "description" : "URL for downloading the JSON encoding of the proof."
          },
          "viewUrl" : {
            "type" : "string",
            "description" : "URL for viewing the proof in a browser."
          }
        },
        "required" : [ "downloadUrl", "viewUrl" ]
      },
      "RangeValueCriterionInstant" : {
        "type" : "object",
        "description" : "Criterium to match attributes where the value is in the given range. Either side of the range may be null, but not both.",
        "properties" : {
          "ge" : {
            "type" : "string",
            "format" : "date-time"
          },
          "le" : {
            "type" : "string",
            "format" : "date-time"
          },
          "lt" : {
            "type" : "string",
            "format" : "date-time"
          }
        }
      },
      "RequiredRefCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "accountGroups" : {
              "type" : "array",
              "description" : "When present, the corresponding filter must have a value and any referenced entity must be in this list.\n When absent, the condition does not check this type of reference (i.e. any reference of this type is allowed).\n To ensure no entities of this type are referenced, set to an empty list.",
              "items" : {
                "type" : "string"
              }
            },
            "accounts" : {
              "type" : "array",
              "description" : "When present, the corresponding filter must have a value and any accounts specified may only be from this list.\n When absent, the condition does not check this type of reference (i.e. any reference of this type is allowed).\n To ensure no entities of this type are referenced, set to an empty list.",
              "items" : {
                "type" : "string"
              }
            },
            "metadata" : {
              "type" : "array",
              "description" : "List of metadata references to match.\n\n How the references are evaluated depends on the context in which the condition is evaluated. In the normal\n transaction or endpoint context for Request permissions, the condition has the 'filter' semantic where a request\n MUST contain metadata references from the permitted list and can not be empty. i.e.,\n\n - When present, the corresponding filter must have a value and any metadata refs may only be from this list.\n - When absent, the condition does not check this type of reference (i.e. any reference of this type is allowed).\n - To ensure no entities of this type are referenced, set to an empty list.\n\n The filtering semantic is used when using this condition to permit Issuer (i.e. Metadata) API itself.\n\n When an Account / Inventory API endpoint is used with `includeMetadata` or metadata sorts and filters, the response\n will include the values for the metadata requested. To ensure that private issuer metadata is allowed to be requested\n the system checks for a `Product` permission with a special 'endpoint owner' context. The private metadata references\n are grouped by issuer and each issuer needs to grant `Product` permission for the request. If there are no\n metadata references in the request, no issuers are checked for Product permission.",
              "items" : {
                "type" : "string"
              }
            },
            "onlyUserAccount" : {
              "type" : "boolean",
              "description" : "When `true`, the account(s) request parameter must be present and must only contain the authenticated user account.\n When `false`, the account request parameter is ignored."
            },
            "onlyVisibleAccountGroups" : {
              "type" : "boolean",
              "description" : "When `true`, the account group request parameter must be present and must only contain groups that are visible\n to the requesting user account.\n When `false`, the account group request parameter is ignored."
            },
            "productItems" : {
              "type" : "array",
              "description" : "When present, the corresponding filter must have a value and any referenced entity must be in this list.\n When absent, the condition does not check this type of reference (i.e. any reference of this type is allowed).\n To ensure no entities of this type are referenced, set to an empty list.",
              "items" : {
                "type" : "string"
              }
            },
            "products" : {
              "type" : "array",
              "description" : "When present, the corresponding filter must have a value and any referenced entity must be in this list.\n When absent, the condition does not check this type of reference (i.e. any reference of this type is allowed).\n To ensure no entities of this type are referenced, set to an empty list.",
              "items" : {
                "type" : "string"
              }
            },
            "securityGroups" : {
              "type" : "array",
              "description" : "When present, the corresponding filter must have a value and any referenced entity must be in this list.\n When absent, the condition does not check this type of reference (i.e. any reference of this type is allowed).\n To ensure no entities of this type are referenced, set to an empty list.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Match references to different types of entities in the request parameters.\n This condition can be applied to both Transaction contexts and Endpoint contexts.\n\n The condition matches when the expression for each entity type matches.\n If an expression is given for a particular entity type, then that type of entity\n must be supported by the transaction type or endpoint type. This ensures that a statement will not match if\n it doesn't restrict the correct endpoint types.\n\n The semantic here is that for transactions you can only operate on particular entity parameters, and all other values\n are denied but the request can contain a subset as long as the subset is not empty.\n For endpoint parameters, the condition forces the use of a filter criterion (effectively disallowing requests that\n don't filter by a particular type) and restricts the values that can be used in the filter.\n\n | Condition parameter | Request value | Result |\n |-|-|-|\n | null (absent) | X | &#x2611; match |\n | null (absent) | [] or null | &#x2611; match |\n | null (absent) | unsupported | &#x2611; match |\n | [] | X | - no match |\n | [] | [] or null | &#x2611; match |\n | [] | unsupported | - no match |\n | [X, ...] | Y | - no match |\n | [X, ...] | X | &#x2611; match |\n | [X, ...] | [X, Y, ...] | - no match |\n | [X, ...] | [] or null | - no match |\n | [X, ...] | unsupported | - no match |",
        "required" : [ "type" ]
      },
      "SecurityGroupAssignedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "accountGroupId" : {
              "type" : "string",
              "description" : "Optional account group id, set when an account group is updated."
            },
            "tx" : {
              "$ref" : "#/components/schemas/AssignSecurityGroupEntry",
              "description" : "Details for the update that relate to the notified account."
            }
          }
        } ],
        "description" : "Notifies all individual accounts and owners of the account groups when a security group assignment is made.",
        "required" : [ "tx" ]
      },
      "SecurityGroupData" : {
        "type" : "object",
        "description" : "Details of a Security Group.",
        "properties" : {
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Custom attributes assigned to this security group."
          },
          "data" : {
            "$ref" : "#/components/schemas/SecurityGroupPermissionData",
            "description" : "Permission statements in this security group."
          },
          "isDeleted" : {
            "type" : "boolean",
            "description" : "When true, the security group has been deleted."
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata that was queried for the security group (entity references: [MetadataEntityRefType.SECURITY_GROUP])."
          },
          "ownerId" : {
            "type" : "string",
            "description" : "The owner account that created the security group and can make modifications to it."
          },
          "securityGroupId" : {
            "type" : "string",
            "description" : "Unique id for this security group. This is the block and index of the transaction that created the group."
          },
          "versionId" : {
            "type" : "string",
            "description" : "Version id of the last transaction that updated the security group."
          }
        },
        "required" : [ "data", "ownerId", "securityGroupId", "versionId" ]
      },
      "SecurityGroupPermissionData" : {
        "type" : "object",
        "description" : "Version indicator for the permission data.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SecurityGroupPermissionDataV1" : "#/components/schemas/SecurityGroupPermissionDataV1"
          }
        },
        "properties" : {
          "permissionType" : {
            "type" : "string",
            "enum" : [ "Request", "Product", "Issuer", "Controller" ]
          },
          "type" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      },
      "SecurityGroupPermissionDataV1" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/SecurityGroupPermissionData"
        }, {
          "type" : "object",
          "properties" : {
            "statements" : {
              "type" : "array",
              "description" : "Statement list that is evaluated in order.",
              "items" : {
                "$ref" : "#/components/schemas/PermissionStatement"
              }
            }
          }
        } ],
        "description" : "Collection of permissions assigned in a security group.",
        "required" : [ "statements", "type" ]
      },
      "SecurityGroupUpdatedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/UpdateSecurityGroupEntry",
              "description" : "Details for the update that relate to the notified account."
            }
          }
        } ],
        "description" : "Notifies the owner when a security group is updated.",
        "required" : [ "tx" ]
      },
      "SetAttributeCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "array",
              "description" : "List of required and optional attributes with additional validation rules.",
              "items" : {
                "$ref" : "#/components/schemas/AttributeUseData"
              }
            },
            "noOthers" : {
              "type" : "boolean",
              "description" : "When true, no other attributes are allowed."
            },
            "noneOf" : {
              "type" : "array",
              "description" : "Specific attributes that are not allowed. The condition will not match if any of these are present.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "required" : [ "attributes", "noOthers", "noneOf", "type" ]
      },
      "SetAttributeRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction itself."
            },
            "entity" : {
              "$ref" : "#/components/schemas/VersionedEntityRef",
              "description" : "Transaction reference  in which this entity was last updated."
            },
            "issuerId" : {
              "type" : "string",
              "description" : "Target account that issues the entity being modified."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "removeAttributes" : {
              "type" : "array",
              "description" : "Attribute values to remove.",
              "items" : {
                "type" : "string"
              }
            },
            "setAttributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Attribute values to set."
            }
          }
        } ],
        "description" : "Set, update, or remove one or more attributes on a [EntityRefType.Product]/[EntityRefType.ProductItem],[EntityRefType.SecurityGroup], [EntityRefType.AccountGroup].\n\n Each entity that can be updated has a version reference. The version reference is the block-and-index of the\n transaction that last changed the entity, which is either the transaction that created the entity for the initial\n version, or the last attribute update transaction.\n\n To ensure consistent updates when multiple clients may be updating the same entities, specify the last known version\n in the `VersionEntityRef` of the entity. If a `null` version is specified, the system will not check the version of\n the entity when updating.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `SetAttributeRequest`, assigned by the\n request account in the `issuerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | Neither `setAttributes` nor `removeAttributes` contain a value. |\n | [InvalidSetAttributeRequest] | The referenced entity does not support attribute updates. |\n | [InvalidAttributeValue] | The value for a transaction attribute, or `setAttributes`, is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A referenced attribute was not defined. |\n | [AttributeNotFoundByName] | A referenced attribute was not defined. |\n | [InvalidEnum] | The value used for an enumerated attribute is not defined. |\n | [DisabledEnum] | The value used for an enumerated attribute is not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectIssuer] | Requester is not the issuer of the entity |\n | [MissingAttributeRequired] | Missing required attribute. |\n | [AttributeNotAllowed] | The request contains a forbidden attribute. |",
        "required" : [ "entity", "issuerId", "removeAttributes", "setAttributes", "type" ]
      },
      "SetMetadataEntryData" : {
        "type" : "object",
        "properties" : {
          "data" : {
            "$ref" : "#/components/schemas/MetadataValueDataObject",
            "description" : "Actual metadata value\n Can be one of:\n MetadataValueStringData,\n MetadataValueDecimalData,\n MetadataValueIntegerData,\n MetadataValueJsonData,\n MetadataValueFileWrapperData"
          },
          "entityRef" : {
            "$ref" : "#/components/schemas/MetadataEntityRef",
            "description" : "Referenced entity in this metadata entry"
          },
          "metadataRef" : {
            "type" : "string",
            "description" : "Metadata definition reference"
          }
        },
        "required" : [ "data", "entityRef", "metadataRef" ]
      },
      "SetMetadataRequest" : {
        "type" : "object",
        "properties" : {
          "values" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SetMetadataEntryData"
            }
          }
        },
        "required" : [ "values" ]
      },
      "SetMetadataResponse" : {
        "type" : "object",
        "properties" : {
          "values" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MetadataEntryData"
            }
          }
        },
        "required" : [ "values" ]
      },
      "SetMultiAttributeRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction itself."
            },
            "entries" : {
              "type" : "array",
              "description" : "Each entry updates or removes attributes on a number of entities. If multiple entities require the same set of\n updates, they can be grouped into an entry.",
              "items" : {
                "$ref" : "#/components/schemas/SetMultiAttributeRequestEntry"
              }
            },
            "issuerId" : {
              "type" : "string",
              "description" : "Target account that owns the entities being modified."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            }
          }
        } ],
        "description" : "Set, update, or remove one or more attributes on multiple Entities of type [EntityRefType.Product]/[EntityRefType.ProductItem],[EntityRefType.SecurityGroup], [EntityRefType.AccountGroup].\n\n Each entity that can be updated has a version reference. The version reference is the block-and-index of the\n transaction that last changed the entity, which is either the transaction that created the entity for the initial\n version, or the last attribute update transaction.\n\n To ensure consistent updates when multiple clients may be updating the same entities, specify the last known version\n in the `VersionEntityRef` of the entity. If a `null` version is specified, the system will not check the version of\n the entity when updating.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `SetMultiAttributeRequest`, assigned by the\n request account in the `issuerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | Neither `setAttributes` nor `removeAttributes` contain a value. |\n | [InvalidSetAttributeRequest] | A referenced entity does not support attribute updates. |\n | [InvalidAttributeValue] | The value for a transaction attribute, or `setAttributes`, is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A referenced attribute was not defined. |\n | [AttributeNotFoundByName] | A referenced attribute was not defined. |\n | [InvalidEnum] | The ordinal or name referenced as an enum value is not valid. |\n | [DisabledEnum] | The referenced enum value is disabled. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectIssuer] | Requester is not the issuer of the entity |\n | [MissingAttributeRequired] | Missing required attribute. |\n | [AttributeNotAllowed] | The request contains a forbidden attribute. |",
        "required" : [ "entries", "issuerId", "type" ]
      },
      "SetMultiAttributeRequestEntry" : {
        "type" : "object",
        "properties" : {
          "entities" : {
            "$ref" : "#/components/schemas/VersionedEntityRefs"
          },
          "removeAttributes" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "setAttributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            }
          }
        },
        "required" : [ "entities", "removeAttributes", "setAttributes" ]
      },
      "SignAndSubmitTransactionRequest" : {
        "type" : "object",
        "description" : "Transaction that requires signatures. After signing the transaction will be submitted for processing.",
        "properties" : {
          "accessKeyId" : {
            "type" : "string",
            "description" : "Signing key id"
          },
          "request" : {
            "$ref" : "#/components/schemas/TransactionRequest",
            "description" : "JSON encoded request."
          },
          "signatures" : {
            "type" : "array",
            "description" : "Request signatures.",
            "items" : {
              "$ref" : "#/components/schemas/AccessKeySignature"
            }
          },
          "txId" : {
            "type" : "string",
            "description" : "Informational transaction id, the transaction id is actually the hash of the request."
          },
          "userAccountId" : {
            "type" : "string",
            "description" : "Account to sign for."
          }
        },
        "required" : [ "accessKeyId", "request", "signatures" ]
      },
      "SignAndSubmitTransactionResponse" : {
        "type" : "object",
        "description" : "Transaction that required signatures. After signing the transaction was submitted for processing.",
        "properties" : {
          "txId" : {
            "type" : "string",
            "description" : "Informational transaction id, the transaction id is actually the hash of the request."
          }
        },
        "required" : [ "txId" ]
      },
      "SignTransactionRequest" : {
        "type" : "object",
        "description" : "Request a signature for a TransactionRequest. The signed TransactionRequest will not be submitted for\n processing.",
        "properties" : {
          "accessKeyId" : {
            "type" : "string",
            "description" : "Signing key id"
          },
          "request" : {
            "$ref" : "#/components/schemas/TransactionRequest",
            "description" : "JSON encoded request."
          },
          "signatures" : {
            "type" : "array",
            "description" : "Existing request signatures.",
            "items" : {
              "$ref" : "#/components/schemas/AccessKeySignature"
            }
          },
          "txId" : {
            "type" : "string",
            "description" : "If a transaction id (hash) is provided, it will be checked against the encoded version of the transaction request."
          },
          "userAccountId" : {
            "type" : "string",
            "description" : "Account id to sign for (if different from the accessKeyId)."
          }
        },
        "required" : [ "accessKeyId", "request" ]
      },
      "SignTransactionResponse" : {
        "type" : "object",
        "description" : "Requested a signature for a TransactionRequest. The signed TransactionRequest was not submitted for\n processing.",
        "properties" : {
          "mintTransactionRequest" : {
            "$ref" : "#/components/schemas/MintTransactionRequest",
            "description" : "Informational transaction id, the transaction id is actually the hash of the request."
          }
        },
        "required" : [ "mintTransactionRequest" ]
      },
      "SignatureRequestedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/PendingTransactionData"
            }
          }
        } ],
        "description" : "Notifies accounts that a transaction is pending a signature from them.",
        "required" : [ "tx" ]
      },
      "SpentHoldingResponse" : {
        "type" : "object",
        "properties" : {
          "holdingId" : {
            "type" : "string"
          },
          "state" : {
            "type" : "string",
            "enum" : [ "Spent", "Unassigned", "Unspent", "Escrowed", "Baked", "Deflated" ]
          }
        },
        "required" : [ "holdingId", "state" ]
      },
      "StringLengthRule" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AttributeRule"
        }, {
          "type" : "object",
          "properties" : {
            "maxLength" : {
              "type" : "integer",
              "format" : "int32"
            },
            "minLength" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        } ]
      },
      "StringRegexRule" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AttributeRule"
        }, {
          "type" : "object",
          "properties" : {
            "regex" : {
              "type" : "string"
            }
          }
        } ],
        "description" : "Ensure String matches the given regular expression.",
        "required" : [ "regex" ]
      },
      "SubmitTransactionResponse" : {
        "type" : "object",
        "description" : "Response to submitTransaction.",
        "properties" : {
          "txId" : {
            "type" : "string",
            "description" : "Informational transaction id, the transaction id is actually the hash of the request."
          }
        },
        "required" : [ "txId" ]
      },
      "SystemStateData" : {
        "type" : "object",
        "description" : "Description of the current system state.",
        "properties" : {
          "expectedEndTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Expected end time of this system state for presentation to the user, or handling of the retry-after header."
          },
          "message" : {
            "type" : "string",
            "description" : "Message associated with the system state (if available)."
          },
          "startTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Time this state went into effect."
          },
          "state" : {
            "type" : "string",
            "description" : "Current system state.",
            "enum" : [ "Public", "Transparent", "Private", "Suspended", "Administration", "Maintenance", "Reconciliation" ]
          }
        },
        "required" : [ "startTime", "state" ]
      },
      "SystemStateUpdateData" : {
        "type" : "object",
        "description" : "Encapsulates a historical, current or future system state change..",
        "properties" : {
          "endTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "End time for this state change. This field is modified when new start times are added."
          },
          "expectedEndTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "End time for this state change. Either a future planned end time, or a historical end time when the next state took effect."
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Unique ID for the state change."
          },
          "message" : {
            "type" : "string",
            "description" : "Message associated with the system state (if available)."
          },
          "startTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Time this state went into effect."
          },
          "state" : {
            "type" : "string",
            "description" : "System state change.",
            "enum" : [ "Public", "Transparent", "Private", "Suspended", "Administration", "Maintenance", "Reconciliation" ]
          },
          "transaction" : {
            "$ref" : "#/components/schemas/WalletTransactionData",
            "description" : "Transaction that created this state change."
          }
        },
        "required" : [ "id", "startTime", "state" ]
      },
      "TransactionAttributeCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "array",
              "description" : "List of required and optional attributes with additional validation rules.",
              "items" : {
                "$ref" : "#/components/schemas/AttributeUseData"
              }
            },
            "noOthers" : {
              "type" : "boolean",
              "description" : "When true, no other attributes are allowed."
            },
            "noneOf" : {
              "type" : "array",
              "description" : "Specific attributes that are not allowed. The condition will not match if any of these are present.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Condition that tests:\n - If required attributes are present\n - If disallowed attributes are absent\n - If attribute values are valid according to additional rules",
        "required" : [ "attributes", "noOthers", "noneOf", "type" ]
      },
      "TransactionCancelledNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/PendingTransactionData"
            }
          }
        } ],
        "description" : "Notifies account that a pending transaction request was cancelled.",
        "required" : [ "tx" ]
      },
      "TransactionData" : {
        "type" : "object",
        "description" : "Compact transaction detail. If an accountId was given in the request, the cumulative holding movements are included in the detail.",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "The request account of the transaction request."
          },
          "amounts" : {
            "type" : "object",
            "additionalProperties" : { },
            "description" : "Net effect of this transaction on account balances (by product)."
          },
          "blockAndIndex" : {
            "type" : "string",
            "description" : "Block and index for this transaction"
          },
          "blockNumber" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Block number for this transaction."
          },
          "index" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Index in block."
          },
          "issuedHoldings" : {
            "type" : "array",
            "description" : "When transaction details is requested, the data will contain a list of all holdings that are issued in this transaction.",
            "items" : {
              "$ref" : "#/components/schemas/HoldingData"
            }
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Metadata that was queried for the transaction (entity references: [MetadataEntityRefType.TRANSACTION], [MetadataEntityRefType.TRANSACTION_ID])."
          },
          "request" : {
            "$ref" : "#/components/schemas/TransactionRequest",
            "description" : "Transaction request data."
          },
          "signatories" : {
            "type" : "array",
            "description" : "When signatories are requested (`includeSignatories==true`), the list of signatories for this transaction.",
            "items" : {
              "$ref" : "#/components/schemas/TransactionSignatoryData"
            }
          },
          "spentHoldings" : {
            "type" : "array",
            "description" : "When transaction detail is requested, the data will contain a list of all holdings that are spent in this transaction.",
            "items" : {
              "$ref" : "#/components/schemas/HoldingData"
            }
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Timestamp of the block."
          },
          "txId" : {
            "type" : "string",
            "description" : "Transaction request hash."
          }
        },
        "required" : [ "accountId", "blockAndIndex", "blockNumber", "index", "request", "timestamp", "txId" ]
      },
      "TransactionDeletedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/PendingTransactionData"
            }
          }
        } ],
        "description" : "Notifies account that a pending transaction request was deleted.",
        "required" : [ "tx" ]
      },
      "TransactionFailedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "mintTransactionFailed" : {
              "$ref" : "#/components/schemas/MintTransactionFailed"
            }
          }
        } ],
        "description" : "Encapsulates the mint's transaction failure message after a transaction has failed to process.\n The notification is sent to the signatories of the transaction as well as the request account.",
        "required" : [ "mintTransactionFailed" ]
      },
      "TransactionInBlockProofData" : {
        "type" : "object",
        "description" : "Combines the transaction hash proof with the block signature proof.",
        "properties" : {
          "block" : {
            "$ref" : "#/components/schemas/BlockBodyProofData",
            "description" : "Proof the transaction is part of the block."
          },
          "transaction" : {
            "$ref" : "#/components/schemas/TransactionProofData",
            "description" : "Proof of the transaction itself."
          }
        },
        "required" : [ "block", "transaction" ]
      },
      "TransactionPendingNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/PendingTransactionData"
            }
          }
        } ],
        "description" : "Notifies account that a request was submitted for further signatures.",
        "required" : [ "tx" ]
      },
      "TransactionProofContent" : {
        "type" : "object",
        "properties" : {
          "attributeTypes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string",
              "enum" : [ "BOOLEAN", "INTEGER", "DECIMAL", "BYTESTRING", "STRING", "MAP", "URI", "TIMESTAMP", "PRODUCT", "DOCUMENT", "LATLON", "TRANSACTION_TYPE", "ENUMERATED", "DATE", "DATETIME", "YEARMONTH" ]
            },
            "description" : "Just the type for each attribute."
          },
          "productItems" : {
            "type" : "array",
            "description" : "Additional information for product items in the proof.",
            "items" : {
              "$ref" : "#/components/schemas/ProductItemData"
            }
          },
          "products" : {
            "type" : "array",
            "description" : "Additional information for products in the proof.",
            "items" : {
              "$ref" : "#/components/schemas/ProductData"
            }
          },
          "proof" : {
            "$ref" : "#/components/schemas/TransactionInBlockProofData",
            "description" : "The proof data itself."
          }
        },
        "required" : [ "proof" ]
      },
      "TransactionProofData" : {
        "type" : "object",
        "description" : "Data and required hashes to proof a transaction and/or holdings hashes up to the transaction hash.",
        "properties" : {
          "accessKeys" : {
            "type" : "array",
            "description" : "Access key public keys if signatures were requested.",
            "items" : {
              "$ref" : "#/components/schemas/BlockPublicKeyData"
            }
          },
          "bakedHoldings" : {
            "type" : "array",
            "description" : "Baked spent holdings if requested.",
            "items" : {
              "$ref" : "#/components/schemas/BlockSpentHolding"
            }
          },
          "baseHoldingsHash" : {
            "type" : "string",
            "format" : "byte",
            "description" : "Base hash for the holdings side of the proof.\n If issued holdings (and baked holdings) are returned, this is the 'selfHoldingsHash'.\n If only baked holdings are returned, this is the 'otherIssuedHoldingsHash',\n If no holdings data is returned, this is the 'holdingsHash'."
          },
          "issuedHoldings" : {
            "type" : "array",
            "description" : "Holdings issued to non-self accounts if requested.",
            "items" : {
              "$ref" : "#/components/schemas/BlockAccountIssuedHoldings"
            }
          },
          "request" : {
            "$ref" : "#/components/schemas/TransactionRequest",
            "description" : "Request details if requested."
          },
          "requestSignatureHash" : {
            "type" : "string",
            "format" : "byte",
            "description" : "Hash of the request signatures. The signatures themselves may or may not be returned."
          },
          "requestSignatures" : {
            "type" : "array",
            "description" : "Access key signatures of the request if requested.",
            "items" : {
              "$ref" : "#/components/schemas/BlockSignatureData"
            }
          },
          "systemId" : {
            "type" : "string",
            "description" : "Unique identifier for the system that generated this proof."
          },
          "transactionHash" : {
            "type" : "string",
            "format" : "byte",
            "description" : "Final transaction hash."
          },
          "transactionId" : {
            "type" : "string",
            "description" : "Id for the transaction being proven. The transaction id is also the hash of the request bytes."
          }
        },
        "required" : [ "baseHoldingsHash", "requestSignatureHash", "systemId", "transactionHash", "transactionId" ]
      },
      "TransactionRequest" : {
        "type" : "object",
        "description" : "\n Transaction request structure. Every transaction processed by the mint has a corresponding transaction request structure.\n The `type` field specifies the request type and determines the fields of the request.\n \n #### Attribute errors\n | Error | Cause |\n |:----|:----|\n | [MissingAttributeRequired] | Missing required attribute |\n | [AttributeNotAllowed] | The request contains a forbidden attribute |\n | [InvalidAttributeValue] | Attribute's value does not match the requirements of its definition |\n | [InvalidAttributeRule] | A transaction signature failed to verify (i.e., the signature does not match the data that was to be signed)|\n | [AttributeNotFoundByName] | Referenced attribute does not exist |\n | [AttributeNotFoundByTag] | Referenced attribute does not exist |\n | [InvalidEnum] | The ordinal or name referenced as an enum value is not valid. |\n | [DisabledEnum] | The referenced enum value is disabled |\n",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AdjustHoldingRequest" : "#/components/schemas/AdjustHoldingRequest",
            "AssignHoldingRequest" : "#/components/schemas/AssignHoldingRequest",
            "AssignHoldingSelectorRequest" : "#/components/schemas/AssignHoldingSelectorRequest",
            "AssignSecurityGroupsRequest" : "#/components/schemas/AssignSecurityGroupsRequest",
            "BakeHoldingRequest" : "#/components/schemas/BakeHoldingRequest",
            "CancelEscrowRequest" : "#/components/schemas/CancelEscrowRequest",
            "CancelEscrowedHoldingsRequest" : "#/components/schemas/CancelEscrowedHoldingsRequest",
            "CancelPendingTransactionRequest" : "#/components/schemas/CancelPendingTransactionRequest",
            "CreateAccessKeysRequest" : "#/components/schemas/CreateAccessKeysRequest",
            "CreateAccountGroupRequest" : "#/components/schemas/CreateAccountGroupRequest",
            "CreateEscrowRequest" : "#/components/schemas/CreateEscrowRequest",
            "CreateIdentityProviderRequest" : "#/components/schemas/CreateIdentityProviderRequest",
            "CreateIdentityTenantRequest" : "#/components/schemas/CreateIdentityTenantRequest",
            "CreateProductItemRequest" : "#/components/schemas/CreateProductItemRequest",
            "CreateProductRequest" : "#/components/schemas/CreateProductRequest",
            "CreateSecurityGroupRequest" : "#/components/schemas/CreateSecurityGroupRequest",
            "DefineAttributeRequest" : "#/components/schemas/DefineAttributeRequest",
            "DeflateProductItemRequest" : "#/components/schemas/DeflateProductItemRequest",
            "DeleteAccountGroupsRequest" : "#/components/schemas/DeleteAccountGroupsRequest",
            "DeleteIdentityProviderRequest" : "#/components/schemas/DeleteIdentityProviderRequest",
            "DeleteIdentityTenantRequest" : "#/components/schemas/DeleteIdentityTenantRequest",
            "DeletePendingTransactionRequest" : "#/components/schemas/DeletePendingTransactionRequest",
            "DeleteProductItemRequest" : "#/components/schemas/DeleteProductItemRequest",
            "DeleteProductRequest" : "#/components/schemas/DeleteProductRequest",
            "DeleteSecurityGroupsRequest" : "#/components/schemas/DeleteSecurityGroupsRequest",
            "InflateProductItemRequest" : "#/components/schemas/InflateProductItemRequest",
            "SetAttributeRequest" : "#/components/schemas/SetAttributeRequest",
            "SetMultiAttributeRequest" : "#/components/schemas/SetMultiAttributeRequest",
            "TransferEscrowRequest" : "#/components/schemas/TransferEscrowRequest",
            "TransferRequest" : "#/components/schemas/TransferRequest",
            "UpdateAccountAccessRequest" : "#/components/schemas/UpdateAccountAccessRequest",
            "UpdateAccountGroupsRequest" : "#/components/schemas/UpdateAccountGroupsRequest",
            "UpdateAttributeDefinitionRequest" : "#/components/schemas/UpdateAttributeDefinitionRequest",
            "UpdateEnumValuesRequest" : "#/components/schemas/UpdateEnumValuesRequest",
            "UpdateIdentityProviderRequest" : "#/components/schemas/UpdateIdentityProviderRequest",
            "UpdateIdentityTenantRequest" : "#/components/schemas/UpdateIdentityTenantRequest",
            "UpdateProductRequest" : "#/components/schemas/UpdateProductRequest",
            "UpdateSecurityGroupsRequest" : "#/components/schemas/UpdateSecurityGroupsRequest",
            "UpdateSystemStateRequest" : "#/components/schemas/UpdateSystemStateRequest"
          }
        },
        "properties" : {
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Transaction attributes."
          },
          "nonce" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Request can have a nonce to distinguish between different requests with the same data."
          },
          "type" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      },
      "TransactionSignatoryData" : {
        "type" : "object",
        "properties" : {
          "accessKeyId" : {
            "type" : "string",
            "description" : "Access key that signed the request."
          },
          "accountAccessType" : {
            "type" : "string",
            "description" : "Access type for the access key to the user account.",
            "enum" : [ "FULL", "PRIMARY", "SECONDARY", "REVOKED" ]
          },
          "accountRoleType" : {
            "type" : "string",
            "description" : "User account role for the request account.",
            "enum" : [ "SINGLE", "INITIATOR", "APPROVER" ]
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Timestamp for signature."
          },
          "userAccessType" : {
            "type" : "string",
            "description" : "User access type at the time of transaction processing.",
            "enum" : [ "NoAccessType", "AuditAccess", "UserAccess", "AdminAccess", "OperatorAccess" ]
          },
          "userAccountId" : {
            "type" : "string",
            "description" : "User account that the request was signed for."
          }
        },
        "required" : [ "accessKeyId", "accountAccessType", "accountRoleType", "timestamp", "userAccessType", "userAccountId" ]
      },
      "TransactionSuccessNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "mintTransactionResponse" : {
              "$ref" : "#/components/schemas/MintTransactionResponse"
            }
          }
        } ],
        "description" : "Encapsulates the mint's transaction response after a transaction has been successfully processed.\n The notification is sent to the signatories of the transaction as well as the request account.",
        "required" : [ "mintTransactionResponse" ]
      },
      "TransactionTypeCondition" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AccessCondition"
        }, {
          "type" : "object",
          "properties" : {
            "oneOf" : {
              "type" : "array",
              "items" : {
                "type" : "string"
              },
              "maxItems" : 2147483647,
              "minItems" : 1
            }
          }
        } ],
        "description" : "Access condition that matches on the request transaction type.",
        "required" : [ "oneOf", "type" ]
      },
      "TransferEscrowRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Attributes for the new escrowid."
            },
            "controllerId" : {
              "type" : "string",
              "description" : "Request account is the current controller of the escrowed holdings."
            },
            "from" : {
              "type" : "array",
              "description" : "List of escrow holdings to reassign.",
              "items" : {
                "$ref" : "#/components/schemas/EscrowAmount"
              }
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "toAccountId" : {
              "type" : "string",
              "description" : "Account to assign the holdings to."
            },
            "toControllerId" : {
              "type" : "string",
              "description" : "Optionally, the holdings can be assigned to a different controller."
            }
          }
        } ],
        "description" : "Transfer existing escrowed holdings to another holder while retaining the escrow state.\n The holdings will be assigned to a single new escrowId.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `TransferEscrowRequest`, assigned by the\n request account in the `controllerId` field.\n\n In addition, the new `toAccountId` needs to be assigned `Product` permission by the issuer of the product for this request.\n\n In addition, if a new `toControllerId` is assigned, the new controller must have assigned `Controller` permission\n to the existing controller for this request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The controller account did not grant permission for the request. |\n | [ProductAccessDenied] | The issuer of the product did not grant permission for the transfer. |\n | [ControllerAccessDenied] | The prospective new controller did not grant permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ValueHasTooManyDigits] | An amount in the holding selector exceeds maximum precision. |\n | [NonPositiveTransferAmount] | An amount in the holding selector is negative or zero. |\n | [InvalidAttributeValue] | The value for a transaction attribute, or `setAttributes`, is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A referenced attribute was not defined. |\n | [AttributeNotFoundByName] | A referenced attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InsufficientHoldings] | Insufficient amount to transfer |\n | [EscrowNotFound] | A referenced escrow ID does not exist, or is not assigned to this controller. |\n | [QuantityOverflow] | The exact quantity computed overflows its type. |\n | [HoldingAccessDenied] | The specified holding is not owned by the requester's account |\n | [HoldingsMustBeSameProduct] | Referenced holdings must be from the same product. |\n | [HoldingIsEscrowed] | An attempt was made to select an 'input' holding that was already locked. |\n | [HoldingIsUnassigned] | An attempt was made to select an 'input' holding that was not assigned yet. |\n | [HoldingIsNotUnassigned] | An attempt was made to assign a holding that was already assigned. |\n | [NotMultipleOfUnitAmount] | The amount specified needs to be an integer multiple of the `unitAmount` of the product item. |",
        "required" : [ "controllerId", "from", "toAccountId", "type" ]
      },
      "TransferReceivedNotification" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/CoreNotification"
        }, {
          "type" : "object",
          "properties" : {
            "tx" : {
              "$ref" : "#/components/schemas/TransactionData",
              "description" : "Transaction request details."
            }
          }
        } ],
        "description" : "Notifies accounts that new holdings were received.",
        "required" : [ "tx" ]
      },
      "TransferRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Transfer attributes."
            },
            "fromAccountId" : {
              "type" : "string",
              "description" : "Source account for the transfer."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "outputList" : {
              "type" : "array",
              "description" : "List of requested outputs. All entries in the list are processed atomically.",
              "items" : {
                "$ref" : "#/components/schemas/TransferRequestOutput"
              }
            }
          }
        } ],
        "description" : "Request to transfer partial holdings.\n\n The `fromAccountId` needs to have sufficient holdings to be transferred. Each entry in the outputList can contain\n a different recipient accountId and holdings can be selected based on amount or specific holdings. Attributes can\n be attached to the transfer, which will be visible to the recipient.\n\n A nonce may be added to be able to repeat a transfer with the same parameters (which would otherwise be seen as\n a retry of a previous request).\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `TransferRequest`, assigned by the\n request account in the `fromAccountId` field.\n\n In addition, the `toAccountId` needs to be assigned `Product` permission by the issuer of the product for each transfer entry in the request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The from account did not grant permission for the request. |\n | [ProductAccessDenied] | The issuer of the product did not grant permission for the transfer. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | The request contains no `outputList` entries. |\n | [ValueHasTooManyDigits] | An amount in the holding selector exceeds maximum precision. |\n | [NonPositiveTransferAmount] | An amount in the holding selector is negative or zero. |\n | [InvalidAttributeValue] | The value for a transaction attribute, or `setAttributes`, is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A referenced attribute was not defined. |\n | [AttributeNotFoundByName] | A referenced attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InsufficientHoldings] | Insufficient amount to transfer |\n | [EscrowNotFound] | A referenced escrow ID does not exist, or is not assigned to this controller. |\n | [QuantityOverflow] | The exact quantity computed overflows its type. |\n | [HoldingAccessDenied] | The specified holding is not owned by the requester's account |\n | [HoldingsMustBeSameProduct] | Referenced holdings must be from the same product. |\n | [HoldingIsEscrowed] | An attempt was made to select an 'input' holding that was already locked. |\n | [HoldingIsUnassigned] | An attempt was made to select an 'input' holding that was not assigned yet. |\n | [HoldingIsNotUnassigned] | An attempt was made to assign a holding that was already assigned. |\n | [NotMultipleOfUnitAmount] | The amount specified needs to be an integer multiple of the `unitAmount` of the product item. |",
        "required" : [ "fromAccountId", "outputList", "type" ]
      },
      "TransferRequestOutput" : {
        "type" : "object",
        "properties" : {
          "from" : {
            "$ref" : "#/components/schemas/HoldingSelector"
          },
          "toAccountId" : {
            "type" : "string"
          }
        },
        "required" : [ "from", "toAccountId" ]
      },
      "UnderlyingHoldingBalance" : {
        "type" : "object",
        "description" : "Balance of an underlying holding with different levels of detail.",
        "properties" : {
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "Product item attribute data if grouping on underlying productItem attributes."
          },
          "bakedAmount" : {
            "type" : "number",
            "description" : "Total baked amount for this grouping."
          },
          "holding" : {
            "description" : "Individual baked holding, if grouping by holdings.",
            "required" : [ "accountId", "amount", "holdingId", "issuedIn", "issuedInTransaction", "issuedTime", "productId", "productItemId", "quantity", "state" ]
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "When grouping by specific metadata values, the combination of metadata values for which these balances apply."
          },
          "proRataAmount" : {
            "type" : "number",
            "description" : "Total effective baked amount. For each holding, the ratio of the holding amount to the holding's product item\n is multiplied by the baked amount into that product item."
          },
          "productId" : {
            "type" : "string",
            "description" : "Underlying product id."
          },
          "productItem" : {
            "$ref" : "#/components/schemas/ProductItemData",
            "description" : "Product item detail if grouping on productItem or holding."
          }
        },
        "required" : [ "bakedAmount", "proRataAmount", "productId" ]
      },
      "UnderlyingHoldingData" : {
        "type" : "object",
        "description" : "Response entry for the [io.trovio.core.api.CoreMintInfoApi.listUnderlyingHoldings] endpoint.\n Each entry contains a balance amount of underlying product of an account's holding.",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "Holding account if grouping by account."
          },
          "attributes" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "When grouping by specific holding attribute values, the combination of values for which these balances apply."
          },
          "depth" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Depth of underlying hierarchy for this entry."
          },
          "holding" : {
            "$ref" : "#/components/schemas/HoldingData",
            "description" : "Full Account Holding information for which underlying information is returned.\n This field will only be returned if the criteria have `groupHoldingsBy=Holding`."
          },
          "holdingAmount" : {
            "type" : "number",
            "description" : "Amount of the current holding that applies to this entry."
          },
          "metadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "object"
            },
            "description" : "When grouping by specific metadata values, the combination of metadata values for which these balances apply."
          },
          "productId" : {
            "type" : "string",
            "description" : "Product of holding for which underlying is reported."
          },
          "productItem" : {
            "$ref" : "#/components/schemas/ProductItemData",
            "description" : "Full Product Item information.\n This field will only be returned if the criteria have `groupHoldingsBy=ProductItem`."
          },
          "productItemAmount" : {
            "type" : "number",
            "description" : "Total amount of baked-into product items that this baked amount applies to."
          },
          "underlying" : {
            "$ref" : "#/components/schemas/UnderlyingHoldingBalance",
            "description" : "Underlying balance entry for this grouping."
          }
        },
        "required" : [ "depth", "holdingAmount", "productId", "productItemAmount", "underlying" ]
      },
      "UpdateAccountAccessRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "forAccountId" : {
              "type" : "string",
              "description" : "Target account for which the access is updated."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "updates" : {
              "type" : "array",
              "description" : "List of access modifications.",
              "items" : {
                "$ref" : "#/components/schemas/AccountAccessData"
              }
            }
          }
        } ],
        "description" : "Set, update, or remove access to an account by the given access keys.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `UpdateAccountAccessRequest`, assigned by the\n request account in the `forAccountId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | The request contains no `updates` entries. |\n | [InvalidAttributeValue] | The value for a transaction attribute, or `setAttributes`, is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A referenced attribute was not defined. |\n | [AttributeNotFoundByName] | A referenced attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [AccessUpdateContainsDuplicateAccountKey] | The access update request contains duplicate account ids |\n | [AccessUpdateCausingPermanentAccessLossNotAllowed] | The access update request causes permanent access loss to the target account |",
        "required" : [ "forAccountId", "type", "updates" ]
      },
      "UpdateAccountGroupEntry" : {
        "type" : "object",
        "properties" : {
          "accessType" : {
            "type" : "string",
            "description" : "When set, the access type of the account group is updated. The owner can set any access type,\n except [UserAccessType.OperatorAccess] which can only be set if the owner of the group\n is the Issuer Admin account.",
            "enum" : [ "NoAccessType", "AuditAccess", "UserAccess", "AdminAccess", "OperatorAccess" ]
          },
          "accountGroupId" : {
            "type" : "string",
            "description" : "The account group to update."
          },
          "addAccounts" : {
            "type" : "array",
            "description" : "Accounts to add to the group.",
            "items" : {
              "type" : "string"
            }
          },
          "isVisibleToMembers" : {
            "type" : "boolean",
            "description" : "Update the 'visible to members' flag."
          },
          "removeAccounts" : {
            "type" : "array",
            "description" : "Accounts to remove from the group.",
            "items" : {
              "type" : "string"
            }
          },
          "setAccounts" : {
            "type" : "array",
            "description" : "Replace all group members with the given list. If `setAccounts` is set (even set empty), neither `addAccounts` nor `removeAccounts` may be set.",
            "items" : {
              "type" : "string"
            }
          },
          "versionId" : {
            "type" : "string",
            "description" : "Optionally, a version to check. If specified and the version does not match the group's current version, the request will fail."
          },
          "visibleToMembersOf" : {
            "type" : "array",
            "description" : "Update the 'visible to members of' account group.\n There is only one 'visible to members of' account group, so the list can only contain 0 or 1 entries.\n 0 entries to remove the current 'visibleToMembersOf' account group, 1 to set a different one.",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "accountGroupId" ]
      },
      "UpdateAccountGroupsRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Transaction attributes."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "ownerId" : {
              "type" : "string",
              "description" : "The owner of the account group."
            },
            "updates" : {
              "type" : "array",
              "description" : "Non-empty list of updates to perform.",
              "items" : {
                "$ref" : "#/components/schemas/UpdateAccountGroupEntry"
              },
              "maxItems" : 2147483647,
              "minItems" : 1
            }
          }
        } ],
        "description" : "Update the members of an account group.\n Multiple account groups can be updated in a single request. Each entry can add members, remove members or replace\n all the members with a new list.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `UpdateAccountGroupsRequest`, assigned by the\n request account in the `ownerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | Empty list of updates, or the request contains an empty update. |\n | [EmptyOptionalList] | Optional lists in the request should be absent or `null` instead of `[]`. |\n | [MixingAddRemoveWithSet] | The request mixes the `add`/`remove` pattern with the 'set' pattern. |\n | [BothAddAndRemove] | The request removes an entity that it just added. |\n | [ListExceedsLimit] | The `visibleToMembersOf` list is limited to a single account group ID. |\n | [DuplicateAccountGroupId] | A list of account group IDs contains a duplicate entry. |\n | [DuplicateAccountId] | A list of account IDs contains a duplicate entry. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A referenced attribute was not defined. |\n | [AttributeNotFoundByName] | A referenced attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectIssuer] | Requester is not the owner of the account group. |\n | [IncorrectVersion] | The request was made with an outdated version. |\n | [AccountGroupNotFound] | Referenced account group does not exist. |\n | [AccountGroupIsDeleted] | Referenced account group has been deleted. |",
        "required" : [ "ownerId", "type", "updates" ]
      },
      "UpdateAttributeDefinitionRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "issuerId" : {
              "type" : "string",
              "description" : "Target account that issued the attribute."
            },
            "maxCount" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "Lists maximum count. If the attribute is not a list cannot be changed."
            },
            "minCount" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "Lists minimum count. If the attribute is not a list cannot be changed."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data.\n Using the version field instead of a nonce will ensure updates are 'safe'."
            },
            "ref" : {
              "type" : "string",
              "description" : "Attribute reference, unique within the system."
            },
            "validationRules" : {
              "type" : "array",
              "description" : "New validation rules.",
              "items" : {
                "$ref" : "#/components/schemas/AttributeRule"
              }
            },
            "version" : {
              "type" : "string",
              "description" : "Last known version of the attribute definition. If the version is set, and it does not equal the actual\n current version of the attribute's definition, the transaction will fail."
            }
          }
        } ],
        "description" : "Update an attribute definition.\n Only the attribute definition [validationRules] and if it's a list, [minCount] and [maxCount] can be updated.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `DefineAttributeRequest`, assigned by the\n request account in the `issuerId` field.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `issuerId` account did not grant permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeRule] | A rule defined for the new attribute is not valid. |\n | [NotAListAttribute] | The update changes `minCount` or `maxCount` but the attribute is not a list. |\n | [EmptyRequest] | The request contains no updates. |\n | [InvalidAttributeRule] | A rule defined for the new attribute is not valid. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectVersion] | The requested version is not the current version of the attribute definition. |",
        "required" : [ "issuerId", "ref", "type" ]
      },
      "UpdateEnumValuesRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "addValues" : {
              "type" : "array",
              "description" : "List of enums to add to the attribute.",
              "items" : {
                "$ref" : "#/components/schemas/EnumValueDefinition"
              }
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "disableValues" : {
              "type" : "array",
              "description" : "List of enums to disable from the attribute. These enums will still exist in the system but not be available for use.",
              "items" : {
                "$ref" : "#/components/schemas/EnumValueRef"
              }
            },
            "enableValues" : {
              "type" : "array",
              "description" : "List of enums to enable from the attribute. This enums will be available for use again.",
              "items" : {
                "$ref" : "#/components/schemas/EnumValueRef"
              }
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "ref" : {
              "type" : "string",
              "description" : "Reference to an attribute of type [AttributeType.ENUMERATED]."
            },
            "updatedBy" : {
              "type" : "string",
              "description" : "Account updating the attribute enums. Only the account that created an enumerated attribute can update its values."
            }
          }
        } ],
        "description" : "Set, or remove enumerators for an enumerated attribute.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `UpdateEnumValuesRequest`, assigned by the\n request account in the `updatedBy` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [UpdateEnumNotAllowed] | The requestor is not the owner of the attribute. |\n | [AttributeIsNotEnum] | The referenced attribute is not an enum. |\n | [EmptyOptionalList] | Optional lists in the request should be absent or `null` instead of `[]`. |\n | [EmptyRequest] | The request contains no updates. |\n | [DuplicateEnumValueDef] | The `addValues` contains duplicate definitions of either name or ordinal. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EnumAlreadyExists] | The value being added already exists or has already been disabled/enabled. |\n | [EnumValueNotFound] | The enum value referenced does not exist. |",
        "required" : [ "ref", "type", "updatedBy" ]
      },
      "UpdateIdentityProviderRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "account" : {
              "type" : "string",
              "description" : "Tenant owner account. The account field here has to be the owner of the tenant referenced in this same request.\n It is also the account that has to be the requesting account, as only the tenant owner can effect changes within the tenant.",
              "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
            },
            "additionalApplicationIds" : {
              "type" : "array",
              "description" : "Additional application IDs (used to set more than one applicationId)",
              "example" : "XYZ,ABC",
              "items" : {
                "type" : "string"
              }
            },
            "applicationId" : {
              "type" : "string",
              "description" : "Application ID (the aud claim of the access token will be validated against this value, an empty value will disable this validation).",
              "example" : "XYZ"
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the request."
            },
            "clientId" : {
              "type" : "string",
              "description" : "Client ID (used for frontend login).",
              "example" : "XYZ"
            },
            "displayName" : {
              "type" : "string",
              "description" : "Display name for UI.",
              "example" : "XYZ"
            },
            "enabled" : {
              "type" : "boolean",
              "description" : "Enable or not this identity provider (not effective if the issuerUri is used in other identity providers and aud claim validation is disabled).",
              "example" : true
            },
            "id" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "Internal ID of the identity provider to update.",
              "example" : 1
            },
            "identityProviderAttributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the identity provider."
            },
            "issuerUri" : {
              "type" : "string",
              "description" : "Issuer URI (must provide an openid discovery endpoint).",
              "example" : "https://my-identity-provider-domain.dev.io/v2.0"
            },
            "migrateFromSubjectIdClaim" : {
              "type" : "string",
              "description" : "Name of the claim the Identity Provider is migrating from when updating the [tokenSubjectIdClaim].\n When updating the [tokenSubjectIdClaim], a migration from the previous or default [tokenSubjectIdClaim] might be needed\n if there are already users authenticating with this Identity Provider.",
              "example" : "sub"
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "responseType" : {
              "type" : "string",
              "description" : "Authentication flow response type. One of or combination of: id_token, none, code, token (except none, values can be combined). See https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#OAuthResponseTypesReg",
              "example" : "code"
            },
            "scopes" : {
              "type" : "array",
              "description" : "Scopes used in openid authentication/authorization.",
              "example" : "openid,email",
              "items" : {
                "type" : "string"
              }
            },
            "tenantId" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "Tenant ID.",
              "example" : 1
            },
            "tokenSubjectIdClaim" : {
              "type" : "string",
              "description" : "Name of the claim used by the identity provider token to identity a user. If none is set, the default will be \"sub\".",
              "example" : "sub"
            },
            "version" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Version of the identity provider in the repository.",
              "example" : 1
            },
            "visible" : {
              "type" : "boolean",
              "description" : "Control the visibility of this identity provider via the configuration endpoint. Setting an identity provider to visible=false does not disable it. Defaults to \"true\".",
              "example" : true
            }
          }
        } ],
        "description" : "Tenant owner updates identity provider.\n\n This transaction request is processed by the Tenant API itself and not forwarded to the mint-service. Therefore, it\n must be submitted to the [CoreTenantApi.identityProviderConfigRequest] endpoint instead of the normal transaction endpoints.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `UpdateIdentityProviderRequest`, assigned by the\n request account in the `account` field.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `account` account did not grant permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction or provider attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction or provider attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction or provider attribute was not defined. |\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [TenantOwnerIncorrect] | The referenced tenant owner is not the owner of the referenced tenant  |\n | [TenantIdUnknown] | Referenced tenant does not exist  |\n | [IdentityProviderWithMatchingIssuerUriExists] | An identity provider with this issuer URI already exists. |\n | [IdentityProviderVersionInvalid] | Identity provider request version does not match repository version |",
        "required" : [ "account", "clientId", "displayName", "enabled", "id", "issuerUri", "responseType", "scopes", "tenantId", "type", "version" ]
      },
      "UpdateIdentityTenantRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "account" : {
              "type" : "string",
              "description" : "Tenant owner account. The account field here has to be the owner of the tenant referenced in this same request.\n It is also the account that has to be the requesting account, as only the tenant owner can effect changes within the tenant.",
              "example" : "0x65d8a412a35e39c36ee5ab5b9e722804"
            },
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the request."
            },
            "id" : {
              "type" : "integer",
              "format" : "int32",
              "description" : "Internal tenant ID.",
              "example" : 1
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "tenantAttributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the tenant."
            },
            "tenantDisplayName" : {
              "type" : "string",
              "description" : "A display name for this tenant.",
              "example" : "My identity tenant"
            },
            "version" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Version of the identity tenant in the repository.",
              "example" : 1
            }
          }
        } ],
        "description" : "Tenant owner updates existing identity tenant.\n\n This transaction request is processed by the Tenant API itself and not forwarded to the mint-service. Therefore, it\n must be submitted to the [CoreTenantApi.identityTenantConfigRequest] endpoint instead of the normal transaction endpoints.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `UpdateIdentityTenantRequest`, assigned by the\n request account in the `account` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [InvalidAttributeValue] | The value for a transaction or tenant attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction or tenant attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction or tenant attribute was not defined. |\n\n #### Wallet host errors\n\n Processing of this transaction request may result in one of the following errors from [WalletHostErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IdentityTenantVersionInvalid] | Identity tenant request version does not match repository version. |\n | [TenantOwnerIncorrect] | The referenced tenant owner is not the owner of the referenced tenant. |\n | [TenantIdUnknown] | Referenced tenant does not exist. |",
        "required" : [ "account", "id", "tenantDisplayName", "type", "version" ]
      },
      "UpdateMetadataDefinitionsRequest" : {
        "type" : "object",
        "properties" : {
          "updates" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MetadataDefinitionUpdateData"
            },
            "maxItems" : 2147483647,
            "minItems" : 1
          }
        },
        "required" : [ "updates" ]
      },
      "UpdateMetadataDefinitionsResponse" : {
        "type" : "object",
        "properties" : {
          "defs" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MetadataDefinitionData"
            }
          }
        },
        "required" : [ "defs" ]
      },
      "UpdateProductRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Optionally, attributes can be associated with the transaction."
            },
            "issuerId" : {
              "type" : "string",
              "description" : "Target account that issued the product."
            },
            "itemAttributes" : {
              "type" : "array",
              "description" : "Override allowed / required attributes for product items. An empty list will remove all of them. Null to not apply.",
              "items" : {
                "$ref" : "#/components/schemas/AttributeUseData"
              }
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data.\n Using the version field instead of a nonce will ensure updates are 'safe'."
            },
            "productId" : {
              "type" : "string",
              "description" : "Product to update"
            },
            "underlying" : {
              "type" : "array",
              "description" : "Override list of product ids for which holdings must be baked for each (assignable) product item. An empty list will remove all of them. Null to not apply.",
              "items" : {
                "type" : "string"
              }
            }
          }
        } ],
        "description" : "Allows to add or update product item attributes and updating the list of underlying products.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `UpdateProductRequest`, assigned by the\n request account in the `issuerId` field.\n\n In addition, the Issuer Administrator account must have assigned `Issuer` permission to the `issuerId` account for the request.\n\n | Error | Cause |\n |:----|:----|\n | [RequestAccessDenied] | The `issuerId` account did not grant permission for the request. |\n | [IssuerAccessDenied] | The Issuer administrator did not grant `Issuer` permission for the request. |\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [DuplicateUnderlyingProduct] | Duplicated underlying product |\n | [DuplicateAttributeRule] | Duplicated attribute |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [ProductIsDeleted] | Referenced product is deleted |\n | [ProductNotFound] | Referenced product not found |",
        "required" : [ "issuerId", "productId", "type" ]
      },
      "UpdateSecurityGroupEntry" : {
        "type" : "object",
        "properties" : {
          "data" : {
            "$ref" : "#/components/schemas/SecurityGroupPermissionData",
            "description" : "New permission set for this security group."
          },
          "securityGroupId" : {
            "type" : "string",
            "description" : "The security group to update."
          },
          "versionId" : {
            "type" : "string",
            "description" : "Optionally, a version to check. If specified and the version does not match the group's current version, the request will fail."
          }
        },
        "required" : [ "data", "securityGroupId" ]
      },
      "UpdateSecurityGroupsRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Transaction attributes."
            },
            "entries" : {
              "type" : "array",
              "description" : "Non-empty list of updates to perform.",
              "items" : {
                "$ref" : "#/components/schemas/UpdateSecurityGroupEntry"
              },
              "maxItems" : 2147483647,
              "minItems" : 1
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "ownerId" : {
              "type" : "string",
              "description" : "The owner of the security group."
            }
          }
        } ],
        "description" : "#### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `UpdateSecurityGroupsRequest`, assigned by the\n request account in the `ownerId` field.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [DuplicateSecurityGroupId] | `entries` has duplicated security group. |\n | [EmptyRequest] | There are no `entries` to update, or a permission statement has an empty conditions list, or one of the conditions has an empty set. |\n | [DuplicateEntry] | A permission statement has a condition with a list that contains duplicates. |\n | [NotSameHierarchy] | A permission statement combines conditions from different context hierarchies. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A transaction attribute was not defined. |\n | [AttributeNotFoundByName] | A transaction attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [MintServiceErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [SecurityGroupNotFound] | Referenced security group does not exist. |\n | [IncorrectIssuer] | Requestor is not the owner of the security group. |\n | [IncorrectVersion] | Outdated security group version. |\n | [SecurityGroupIsDeleted] | Referenced security group has been deleted. |",
        "required" : [ "entries", "ownerId", "type" ]
      },
      "UpdateSystemStateRequest" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/TransactionRequest"
        }, {
          "type" : "object",
          "properties" : {
            "attributes" : {
              "type" : "object",
              "additionalProperties" : {
                "type" : "object"
              },
              "description" : "Transaction attributes."
            },
            "expectedEndTime" : {
              "type" : "string",
              "format" : "date-time",
              "description" : "When available, an expected 'resolution' time will be communicated downstream."
            },
            "message" : {
              "type" : "string",
              "description" : "The status message to return for the current system state. If no message is given,\n the previous message for this state will be used."
            },
            "nonce" : {
              "type" : "integer",
              "format" : "int64",
              "description" : "Request can include a nonce to distinguish between different requests with the same data."
            },
            "requestAccount" : {
              "type" : "string",
              "description" : "The request account must be the Issuer Admin account."
            },
            "startTime" : {
              "type" : "string",
              "format" : "date-time",
              "description" : "Planned start of this system state. If not specified, the state will change immediately (i.e. current time). If\n specified, it must be a future time."
            },
            "systemState" : {
              "type" : "string",
              "description" : "The new system state.",
              "enum" : [ "Public", "Transparent", "Private", "Suspended", "Administration", "Maintenance", "Reconciliation" ]
            }
          }
        } ],
        "description" : "Update the system state.\n\n The system state determines which user types are allowed to access the system.\n The system state can only be updated by the Issuer Admin account (or its delegates).\n\n This transaction request is processed by the Tenant API itself and not forwarded to the mint-service. Therefore, it\n must be submitted to the [CoreTenantApi.updateSystemState] endpoint instead of the normal transaction endpoints.\n\n #### Transaction permission\n\n This transaction request requires `Request` permission for transaction type `UpdateSystemStateRequest`, assigned by the\n issuer admin.\n\n #### Validation errors\n\n Validation of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [EmptyRequest] | Empty list of updates, or the request contains an empty update. |\n | [InvalidAttributeValue] | The value for a transaction attribute is not valid given the attribute definition. |\n | [AttributeNotFoundByTag] | A referenced attribute was not defined. |\n | [AttributeNotFoundByName] | A referenced attribute was not defined. |\n\n #### Mint service errors\n\n Processing of this transaction request may result in one of the following errors from [CoreApiErrorCode]:\n\n | Error | Cause |\n |:----|:----|\n | [IncorrectIssuer] | The request account is not the issuer admin account. |",
        "required" : [ "requestAccount", "systemState", "type" ]
      },
      "VersionedBlockAndIndex" : {
        "type" : "object",
        "properties" : {
          "blockNumber" : {
            "type" : "integer",
            "format" : "int64",
            "minimum" : 0
          },
          "index" : {
            "type" : "integer",
            "format" : "int32",
            "minimum" : 0
          },
          "version" : {
            "type" : "string",
            "description" : "Version is the block and index of the previous attribute modification transaction."
          }
        },
        "required" : [ "blockNumber", "index" ]
      },
      "VersionedEntityRef" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "Reference to the original entity (block and index where it was created)"
          },
          "type" : {
            "type" : "string",
            "description" : "The type of entity that is referenced by the id.",
            "enum" : [ "Product", "ProductItem", "BakedHolding", "Transaction", "AccountGroup", "SecurityGroup" ]
          },
          "version" : {
            "type" : "string",
            "description" : "Version is the block and index of the previous attribute modification transaction."
          }
        },
        "required" : [ "id", "type" ]
      },
      "VersionedEntityRefs" : {
        "type" : "object",
        "properties" : {
          "ids" : {
            "type" : "array",
            "description" : "Reference to the original entity (block and index where it was created).",
            "items" : {
              "$ref" : "#/components/schemas/VersionedBlockAndIndex"
            }
          },
          "type" : {
            "type" : "string",
            "description" : "The type of entity that is referenced by the id.",
            "enum" : [ "Product", "ProductItem", "BakedHolding", "Transaction", "AccountGroup", "SecurityGroup" ]
          }
        },
        "required" : [ "ids", "type" ]
      },
      "WalletHostStatusData" : {
        "type" : "object",
        "description" : "Data returned for host status.",
        "properties" : {
          "buildVersion" : {
            "type" : "string",
            "description" : "Build version of this server."
          },
          "latestBlockNumber" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Latest block number that was processed into the cache."
          },
          "latestNotificationBlockNumber" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Latest block number notification received from the mint service"
          },
          "status" : {
            "type" : "string",
            "description" : "Current wallet host node status."
          },
          "systemId" : {
            "type" : "string",
            "description" : "When initialized, the system id is the `prevBlockHash` of block number 1."
          }
        },
        "required" : [ "buildVersion", "status" ]
      },
      "WalletTransactionData" : {
        "type" : "object",
        "description" : "Entity for (non-mint) transactions that are processed by the wallet-host.",
        "properties" : {
          "accountId" : {
            "type" : "string",
            "description" : "The request account of the transaction request."
          },
          "requestBytes" : {
            "$ref" : "#/components/schemas/TransactionRequest",
            "description" : "Transaction request."
          },
          "signatories" : {
            "type" : "array",
            "description" : "Collection of signatories that initiated/approved the transaction.",
            "items" : {
              "$ref" : "#/components/schemas/TransactionSignatoryData"
            }
          },
          "tenantId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Identity tenant ID (where applicable)"
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time"
          },
          "transactionType" : {
            "type" : "string",
            "description" : "Transaction request type."
          },
          "txId" : {
            "type" : "string"
          }
        },
        "required" : [ "accountId", "requestBytes", "signatories", "timestamp", "transactionType", "txId" ]
      }
    },
    "securitySchemes" : {
      "accessToken" : {
        "description" : "\n        The Authorization header supports two types of token:\n          - Bearer token from a configured Tenant Identity Provider. The format is the `Bearer` scheme prefix followed by the token.\n          - Access token signed with a core AccessKey. Format is `X-Trovio-AccessToken` scheme prefix followed by a Base64-URLEncoded `SignedAccessToken` structure.\n        ",
        "in" : "header",
        "name" : "Authorization",
        "type" : "apiKey"
      }
    }
  }
}